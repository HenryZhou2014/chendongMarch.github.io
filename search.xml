<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[编译FFmpeg]]></title>
      <url>%2F2017%2F05%2F25%2FAndroid%E5%BC%80%E5%8F%91%2F%E7%BC%96%E8%AF%91ffmpeg%2F</url>
      <content type="text"><![CDATA[配置NDK环境打开~/.bash_profile文件，添加ndk的环境变量，最后别忘了source .bash_profile更新配置 12345678910#androidexport ANDROID_HOME=/Users/march/AndroidRes/sdk# sdkexport PATH=$ANDROID_HOME/platform-tools:$PATHexport PATH=$ANDROID_HOME/tools:$PATH# ndk export NDK_HOME=$ANDROID_HOME/ndk-bundle export PATH=$NDK_ROOT:$PATH 修改ffmpeg-3.3.1/configure这个主要是生成的lib包的包名规范成以libxxx.so的形式。 否则生成的so文件在android下是无法加载的，替换过程一定要谨慎，需要全部替换掉。这里我提供一个替换好的configure文件供参考:thumbsup: 1234567891011# 找到下面几行替换一下SLIBNAME_WITH_MAJOR='$(SLIBNAME).$(LIBMAJOR)' LIB_INSTALL_EXTRA_CMD='$$(RANLIB)"$(LIBDIR)/$(LIBNAME)"' SLIB_INSTALL_NAME='$(SLIBNAME_WITH_VERSION)' SLIB_INSTALL_LINKS='$(SLIBNAME_WITH_MAJOR)$(SLIBNAME)'# 替换后的结果SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)' LIB_INSTALL_EXTRA_CMD='$$(RANLIB)"$(LIBDIR)/$(LIBNAME)"' SLIB_INSTALL_NAME='$(SLIBNAME_WITH_MAJOR)' SLIB_INSTALL_LINKS='$(SLIBNAME)' 新增ffmpeg-3.3.1/build_android.sh脚本注意,NDK后面的路径换成自己的路径，可以参考编写好的文件 12345678910111213141516171819202122232425262728293031323334#!/bin/shNDK=/Users/march/AndroidRes/sdk/ndk-bundleSYSROOT=$NDK/platforms/android-23/arch-armTOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64function build_one&#123;./configure \--prefix=$PREFIX \--enable-shared \--disable-static \--disable-doc \--disable-ffmpeg \--disable-ffplay \--disable-ffprobe \--disable-ffserver \--disable-avdevice \--disable-doc \--disable-symver \--cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \--target-os=linux \--arch=arm \--enable-cross-compile \--sysroot=$SYSROOT \--extra-cflags="-Os -fpic $ADDI_CFLAGS" \--extra-ldflags="$ADDI_LDFLAGS" \$ADDITIONAL_CONFIGURE_FLAGmake cleanmakemake install&#125;CPU=armPREFIX=$(pwd)/android/$CPUADDI_CFLAGS="-marm"build_one 编译执行build_android.sh脚本，如果没有权限可以使用chomd +x增加执行权限。然后等一段时间，你会发现在FFmpeg中出现了一个名为android的文件夹。目录如下 将编译生成的文件copy到AS中目录如下 编写Android.mk12345678910111213141516171819202122232425262728293031323334353637383940LOCAL_PATH :=$(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := avcodecLOCAL_SRC_FILES := libavcodec-57.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := avfilterLOCAL_SRC_FILES := libavfilter-6.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := avformatLOCAL_SRC_FILES := libavformat-57.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := avutilLOCAL_SRC_FILES := libavutil-55.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := swresampleLOCAL_SRC_FILES := libswresample-2.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := swscaleLOCAL_SRC_FILES := libswscale-4.soinclude $(PREBUILT_SHARED_LIBRARY)#Programinclude $(CLEAR_VARS)LOCAL_MODULE :=sffhelloworldLOCAL_SRC_FILES := simplest_ffmpeg_helloworld.cLOCAL_C_INCLUDES += $(LOCAL_PATH)/includeLOCAL_LDLIBS := -llog -lzLOCAL_SHARED_LIBRARIES := avcodec avfilter avformat avutil swresample swscaleinclude $(BUILD_SHARED_LIBRARY) 编写Application.mk1APP_ABI := armeabi armeabi-v7a 编译生成solocal.properties 配置ndk目录,通常是默认配置好的。然后进入到terminal，cd到jni目录，执行ndk-build,(一般情况下ndk的目录应该在local.properties由系统自动创建了) 12ndk.dir=/Users/march/AndroidRes/sdk/ndk-bundlesdk.dir=/Users/march/AndroidRes/sdk 运行项目编辑app/build.gradle配置好so加载路径，将so文件拷贝进jniLibs目录，当然你如果喜欢放在libs目录里面也是可以的，一定要记得armeabi/xxx.so，abi目录不要忘记，不然会提示找不到，不要问我为什么特别提醒 :smile: 1234567sourceSets &#123; //定义编译时编译文件的路径 main &#123; res.srcDirs = [&apos;src/main/res&apos;] jniLibs.srcDirs = [&apos;src/main/jniLibs&apos;] &#125; &#125; 点击运行，出现了以下错误： Your project contains C++ files butit is not using a supported native build system。解决这个问题 123456789101112// 在gradle.properties添加Android.useDeprecatedNdk=true// 在app/build.gradle 添加jni.srcDirs = []这一行sourceSets &#123; //定义编译时编译文件的路径 main &#123; res.srcDirs = [&apos;src/main/res&apos;] jniLibs.srcDirs = [&apos;src/main/jniLibs&apos;] jni.srcDirs = [] &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Kotlin]]></title>
      <url>%2F2017%2F05%2F23%2F%E5%AD%A6%E4%B9%A0%2FKotlin%2F</url>
      <content type="text"><![CDATA[相关文章 微信文章-你为什么需要kotlin segmentfault上腾讯bugly的一篇文章，介绍了kotlin的基本特性 kotlin官网文档 ／ http://kotlinlang.org kotlin官网文档中文版 ／ https://hltj.gitbooks.io 《kotlin for andriod developers》中文翻译版 ／ https://wangjiegulu.gitbooks.io https://huanglizhuo.gitbooks.io Kotlin官方文档中文翻译版本 ／ http://www.liying-cn.net/kotlin/ 基本配置打开Setting -&gt; plugin下载插件，重启AS，创建项目 -&gt; new File -&gt; Kotlin Activity，会提示配置相关信息，点击配置即可，插件会在工程中作下面的相关配置，以上可以使用IDE很快完成，整体项目没有很大变化。 另外Android Studio提供了直接将java代码转换为kotlin代码的方式 ：顶部菜单栏 -&gt; code -&gt; covert java File to Kotlin File gradle文件一览 12345678910111213141516171819202122232425262728293031323334353637// project/build.gradlebuildscript &#123; ext.kotlin_version = '1.0.6' dependencies &#123; classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version" &#125;&#125;// module/build.gradleapply plugin: 'com.android.application'apply plugin: 'kotlin-android'// 基于Android的扩展apply plugin: 'kotlin-android-extensions'android &#123; compileSdkVersion 25 buildToolsVersion "25.0.1" defaultConfig &#123; ... &#125; buildTypes &#123; ... &#125; // 资源路径 sourceSets &#123; main.java.srcDirs += 'src/main/kotlin' &#125;&#125;dependencies &#123; // kotlin compile "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"&#125;// 需要加入这个repositories &#123; mavenCentral()&#125; 新特性直接引用xml中的控件再也不用findViewById()也不用ButterKnife注解啦。 123456789101112131415161718192021&lt;!--在xml定义，id为 mMsgTv --&gt;&lt;TextView android:id="@+id/mMsgTv" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" android:textColor="@color/black" android:textSize="30sp"/&gt; // 需要 kotlin-android-extensions 支持// Android 插件apply plugin: 'kotlin-android-extensions'// 在 Activity 中直接使用 id 引用控件// 此时会又如下包倒入 import kotlinx.android.synthetic.main.(你的xml文件名).*eg: import kotlinx.android.synthetic.main.activity_kt_test.*// 设置属性mMsgTv.text = "测试kotlin" 扩展方法可以扩展已有类的方法。 12345678910111213class KtTestActivity : BaseActivity() &#123; // 扩展Activity增加显示Toast的方法 fun Activity.showMsg(msg: String) &#123; Toaster.get().show(mContext, msg) &#125; override fun onCreate(savedInstanceState: Bundle?, persistentState: PersistableBundle?) &#123; super.onCreate(savedInstanceState, persistentState) setContentView(R.layout.activity_kt_test) showMsg("测试Toast") &#125;&#125; 支持lambda表达式1234567891011mMsgTv.setOnClickListener &#123; view -&gt; run &#123; Logger.e("chendong", "click view") &#125; &#125;mMsgTv.setOnClickListener &#123; view -&gt; doSomeThing() &#125; 数据类在java中定义数据结构类需要重复实现大量的getter/setter方法，kotlin为数据类提供新的创建方式，使用关键字data定义一个数据类，可以极大的简化数据类的定义 1234567891011// 有两个属性 name属性具有默认值data class Person(val name: String = "defaultValue", val age: Int)// 在数据类中定义方法data class Person(val name: String = "defaultValue", val age: Int)&#123; fun speak() &#123; &#125;&#125;var p = Person("chendong",12) 概念companion object，伴生对象 基本语法静态变量、静态方法kotlin中没有静态的概念，也没有static关键字，静态变量和静态方法需要使用companion object声明 12345678companion object &#123; // 静态变量 private val BASE_URL = "http://www.baidu.com/" // 静态方法 fun startTestActivity(activity: Activity)&#123; &#125; &#125; lateinit、lazy、属性代理 lateinitlateinit延迟初始化变量，lateinit的使用还是有很多限制的，比如只能在不可null的对象上使用，比须为var，不能为primitives（Int、Float之类）等等，不过这样逼迫你一定要初始化这个变量的做法，确实能减少我们在开发中的遗漏，从而提高开发效率。 123456 private lateinit var mQueryParam: GitHubSearchParam override fun onInitDatas() &#123; super.onInitDatas() mQueryParam = GitHubSearchParam()&#125; lazy是属性代理的基本运用，使用by lazy可以延迟初始化变量的值，注：必须是只读对象(不可变)，使用val声明 123456789101112131415class DemoActivity : Activity()&#123; // 第一次使用时才调用初始化代码 private val aTextView: TextView by lazy&#123; findViewById(R.id.a_textview) as TextView &#125; override fun onCreate(savedInstanceState: Bundle?)&#123; super.onCreate(savedInstanceState) setContentView(R.layout.main) // aTextView初始化 aTextView.text = "Hello" aTextView.textSize = 20 ... &#125;&#125; 自定义属性代理访问SharePreference,可以大大简化数据的读取和写入操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Suppress("UNCHECKED_CAST")class Preference&lt;T&gt;( val context: Context, val name: String, val defaultValue: T) : ReadWriteProperty&lt;Any?, T&gt; &#123; val preference: SharedPreferences by lazy &#123; context.getSharedPreferences("KEY", Context.MODE_PRIVATE) &#125; override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T &#123; return findPreference(name, defaultValue) &#125; override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) &#123; putPreference(name, value) &#125; private fun &lt;U&gt; findPreference(name: String, default: U): U = with(preference) &#123; val res: Any = when (default) &#123; is Long -&gt; getLong(name, default) is String -&gt; getString(name, default) is Int -&gt; getInt(name, default) is Boolean -&gt; getBoolean(name, default) is Float -&gt; getFloat(name, default) else -&gt; throw IllegalArgumentException("This type can be saved into Preferences") &#125; res as U &#125; private fun &lt;U&gt; putPreference(name: String, value: U) &#123; val editor = preference.edit() when (value) &#123; is Long -&gt; editor.putLong(name, value) is String -&gt; editor.putString(name, value) is Int -&gt; editor.putInt(name, value) is Boolean -&gt; editor.putBoolean(name, value) is Float -&gt; editor.putFloat(name, value) else -&gt; throw IllegalArgumentException("This type can be saved into Preferences") &#125; editor.apply() &#125;&#125;// 测试代码class DemoActivity : Activity()&#123; var aInt: Int by Preference(this, "aInt", 0) fun whatever()&#123; println(aInt)//会从SharedPreference取这个数据 aInt = 9 //会将这个数据写入SharedPreference &#125;&#125; 类与对象内部类 匿名内部类，需要使用object关键字声明内部类 123456// 设置一个监听dialog.setListener(object : GitHubSearchParamDialog.OnChooseSearchListener &#123; override fun onChoose(sortType: String, queryKeyWds: String) &#123; &#125; &#125;) Android 开发实现 Parcelable 接口1234567891011121314151617181920212223242526272829@SuppressLint("ParcelCreator")data class XiaoDetailDataModel( var linkUrl: String = "", var standardPicUrl: String = "") : Parcelable &#123; override fun describeContents(): Int &#123; return 0 &#125; override fun writeToParcel(dest: Parcel?, flags: Int) &#123; dest?.writeString(this.linkUrl) dest?.writeString(this.standardPicUrl) &#125; // 必须实现 primary constructor constructor(inData: Parcel) : this( inData.readString(),inData.readString()) companion object &#123; @JvmField val CREATOR: Parcelable.Creator&lt;XiaoDetailDataModel&gt; = object : Parcelable.Creator&lt;XiaoDetailDataModel&gt; &#123; override fun createFromParcel(source: Parcel): XiaoDetailDataModel &#123; return XiaoDetailDataModel(source) &#125; override fun newArray(size: Int): Array&lt;XiaoDetailDataModel?&gt; &#123; return arrayOfNulls(size) &#125; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL]]></title>
      <url>%2F2017%2F04%2F13%2F%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%2FSQL%2F</url>
      <content type="text"><![CDATA[1. 前言 SQL，指结构化查询语言，全称是(Structured Query Language)，SQL 语句是大小写不敏感的。说明：使用db_name作为数据库名，使用tb_name作为表名。使用col_name作为列名，使用row_name作为行名。使用alias_name作为别名。[xxx]表示可选使用的属性。(a…|b…|c…)表示三种情况任选一种使用。 2. 数据库配置123456789编辑 ./bash_profile 文件，加入别名open ~/.bash_profile# mysqlalias mysql=/usr/local/mysql/bin/mysql连接到mysql服务mysql -u root -p 3. 库操作语句1234567891011121314显示数据库列表SHOW databases;创建数据库CREATE DATABASE db_name; 使用数据库USE db_name; 删除数据库DROP database db_name;使用字符集SET names utf8; 4. 表操作语句关于表字段约束的讲解见附2 123456789101112131415161718192021222324252627282930313233343536373839404142434445创建表CREATE TABLE table_name(col_name1 data_type(size) [约束],col_name2 data_type(size) [约束],col_name3 data_type(size) [约束],....);eg:CREATE TABLE Persons(PersonID int,LastName varchar(255),FirstName varchar(255),Address varchar(255),City varchar(255));删除表DROP TABLE tb_name;删除表数据，但是保留表结构TRUNCATE TABLE tb_name增加一列ALTER TABLE tb_name ADD col_name 数据类型 [约束]删除一列ALTER TABLE tb_name DROP COLUMN col_name;修改一列ALTER TABLE tb_name ALTER old_col_name new_col_name 数据类型 [约束]修改一列的数据类型/* SQL Server / MS Access */ALTER TABLE tb_nameMODIFY COLUMN col_name 数据类型/* My SQL / Oracle */ALTER TABLE tb_nameALTER COLUMN col_name 数据类型添加主键ALTER TABLE tb_name ADD PRIMARY KEY(col_name);删除主键ALTER TABLE tb_name DROP PRIMARY KEY(col_name); 5. 增删改查语句5.1 SELECT 语句123456基本查询语句[DISTINCT] 可选，用于返回唯一不同的值。SELECT [DISTINCT] * FROM tb_name;SELECT [DISTINCT] col_name1,col_name2 FROM tb_name;eg:SELECT name,country FROM Websites; 5.2 SELECT INTO 语句使用SELECT INTO和 INSERT INTO SELECT 语句，复制表数据。MySQL 数据库不支持 SELECT INTO 语句，但支持 INSERT INTO SELECT。新表将会使用 SELECT 语句中定义的列名称和类型进行创建。您可以使用 AS 关键字来应用新名称。 12345678910111213141516171819复制全部数据或者使用WHERE子句筛选SELECT *INTO new_tb_name [IN db_name]FROM old_tb_name;or复制指定列数据或者使用WHERE子句筛选SELECT col_name...INTO new_tb_name [IN db_name]FROM old_tb_name;复制全部数据或者使用WHERE子句筛选INSERT INTO new_tb_nameSELECT * FROM old_tb_name;or复制指定列数据或者使用WHERE子句筛选INSERT INTO new_tb_name(col_name...)SELECT col_name...FROM old_tb_name; 5.3 INSERT INTO 语句1234567891011// 不指定列名插入INSERT INTO tb_nameVALUES (value1,value2,value3,...);// 指定列名插入INSERT INTO tb_name (col_name1,col_name2,col_name3,...)VALUES (value1,value2,value3,...);eg:INSERT INTO Websites (name, url, country)VALUES ('stackoverflow', 'http://stackoverflow.com/', 'IND'); 5.4 UPDATE 语句12345678910使用UPDATE语句时，一定要添加WHERE条件，否则会更新所有的数据。UPDATE tb_nameSET col_name1=value1,col_name2=value2,...WHERE (这里参照WHERE子句，匹配指定数据);eg:UPDATE Websites SET alexa='5000', country='USA' WHERE name='aasdfghjkl'; 5.5 DELETE 语句123456789DELETE FROM tb_nameWHERE (这里参照WHERE子句，匹配指定数据);DELETE * FROM tb_nameWHERE (这里参照WHERE子句，匹配指定数据);eg:DELETE FROM WebsitesWHERE name='百度' AND country='CN'; 6. WHERE 子句1234SELECT col_name1,col_name2FROM tb_nameWHERE col_name1 operator value1 [逻辑运算符 col_name2 operator value2...]; 6.1 逻辑运算符1234567891011逻辑运算符NOT 非操作AND 与操作，表达式前后条件必须都成立才为trueOR 或操作，表达式前后操作有一个成立即为true逻辑运算的优先级：() NOT AND OReg:SELECT * FROM WebsitesWHERE alexa &gt; 15AND (country='CN' OR country='USA'); 6.2 比较运算符123456789101112131415161718192021222324252627282930313233343536373839/*比较运算符=,&gt;,&lt;,&gt;=,&lt;=,&lt;&gt;(不等于，一些版本中写作!=),BETWEEN...AND(在范围内),LIKE(模糊查询),IN(指定所有可能值进行匹配),IS NULL(空值判断)*/eg:空值查询 IS NULLSELECT * FROM tb)nae WHERE col_name IS NULL;存在查询 INSELECT * FROM tb_name WHERE col_name IN (5000,3000,1500);SELECT * FROM tb_name WHERE col_name IN ('abc','tyu','test');区间查询 BETWEEN...AND...区间查询两边都是闭区间，类似[1,100]SELECT * FROM tb_name WHERE col_name BETWEEN 100 AND 200;模糊查询 LIKESELECT * FROM tb_name WHERE col_name LIKE 'M%';todo 模糊查询通配符% 表示多个字值，_ 下划线表示一个字符。 M% : 为能配符，正则表达式，表示的意思为模糊查询信息为 M 开头的。 %M% : 双百分号表示查询的信息在内容中间。 %M_% : 表示查询的字母在内容的倒数第二位。 7. JOIN 子句(表连接)JOIN 子句用于基于这些表之间的共同字段把来自两个或多个表的行结合起来。 连接方式 描述 INNER JOIN 如果表中有至少一个匹配，则返回行 LEFT JOIN 即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN 即使左表中没有匹配，也从右表返回所有的行 FULL JOIN 只要其中一个表中存在匹配，则返回行 7.1 INNER JOIN 内连接INNER JOIN 也可以简写为 JOININNER JOIN关键字在表中存在至少一个匹配时返回行。1234SELECT col_nameFROM tb_name1INNER JOIN tb_name2ON tb_name1.col_name=tb_name2.col_name; 7.2 LEFT OUTER JOIN 左外连接LEFT OUTER JOIN也可以简写为 LEFT JOINLEFT JOIN 关键字从左表返回所有的行，即使右表中没有匹配，如果右表中没有匹配，则结果为 NULL。1234SELECT col_nameFROM tb_name1LEFT OUTER JOIN tb_name2ON tb_name1.col_name=tb_name2.col_name; 7.3 RIGHT OUTER JOIN 右外连接RIGHT OUTER JOIN 也可以简写为 RIGHT JOINRIGHT JOIN 关键字从右表返回所有的行，即使左表中没有匹配，如果左表中没有匹配，则结果为NULL。1234SELECT col_nameFROM tb_name1RIGHT OUTER JOIN tb_name2ON tb_name1.col_name=tb_name2.col_name; 7.4 FULL OUTER JOIN 全外连接FULL OUTER JOIN 关键字只要左表 和右表 其中一个表中存在匹配，则返回行.FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。1234SELECT col_nameFROM tb_name1FULL OUTER JOIN tb_name2ON tb_name1.col_name=tb_name2.col_name; 8. 关键字8.1 AS 关键字,使用别名使用AS关键字，可以为表名称或列名称指定别名，基本上，创建别名是为了让列名称的可读性更强，以下情况使用别名很有用。 在查询中涉及超过一个表 在查询中使用了函数 列名称很长或者可读性差 需要把两个列或者多个列结合在一起 ps:别名如果包含空格，要求使用双引号或方括号。 12345678910111213141516列别名用法使用列别名查询之后的展示数据将使用别名来展示SELECT col_name AS alias_nameFROM tb_name;eg:SELECT name AS n, country AS cFROM Websites;表别名用法SELECT col_nameFROM tb_name AS alias_name;eg:SELECT w.name, w.url, a.count, a.date FROM Websites AS w, access_log AS a WHERE a.site_id=w.id and w.name="百度"; 8.2 ORDER BY 关键字12345678910ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。SELECT col_name1,col_name2FROM tb_nameORDER BY col_name (ASC|DESC)[,col_name (ASC|DESC)...];eg:SELECT * FROM WebsitesORDER BY alexa DESC; 8.3 LIMIT 关键字12345使用limit关键字，可以跳过m条数据，查询n条数据，m可以省略，表示从头开始查询。SELECT * FROM tb_name LIMIT [m,]n;eg：SELECT * FROM Websites LIMIT 3,2; 8.4 UNION 关键字UNION 操作符用于合并两个或多个 SELECT 语句的结果集。UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。UNION 只会选取不同的值。请使用 UNION ALL 来选取重复的值！ 1234567SELECT col_name FROM tb_name1UNIONSELECT col_name FROM tb_name2;SELECT col_name FROM tb_name1UNION ALLSELECT col_name FROM tb_name2; 9. 函数9.1 CONCAT()连接函数结果将会拼接CONCAT()函数中的全部值 1234下面的例子将会拼接三个字段的值(结果：'www.baidu.com,100,china')，并作为一列(site_info)显示SELECT name, CONCAT(url, ', ', alexa, ', ', country) AS site_infoFROM Websites; 10. 索引在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。在表中创建索引，以便更加快速高效地查询数据。用户无法看到索引，它们只能被用来加速搜索/查询。更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。 10.1 创建索引12345678910111213141516创建一个简单的索引。允许使用重复的值：CREATE INDEX index_nameON table_name (column_name)在表上创建一个唯一的索引。不允许使用重复的值：唯一的索引意味着两个行不能拥有相同的索引值。 CREATE UNIQUE INDEX index_nameON table_name (column_name)注释：用于创建索引的语法在不同的数据库中不一样。因此，检查您的数据库中创建索引的语法。 eg:创建索引CREATE INDEX PIndexON Persons (LastName)在多个列上创建索引CREATE INDEX PIndexON Persons (LastName, FirstName) 10.2 删除索引12345678/* MS Access */DROP INDEX index_name ON table_name/* MS SQL Server */DROP INDEX table_name.index_name/* DB2/Oracle */DROP INDEX index_name/* MySQL */ALTER TABLE table_name DROP INDEX index_name 附1. 模糊查询附1.1. 通配符 通配符 描述 示例 % 代替0个或者多个字符 chen%,匹配chen开头的全部数据 _ 代替一个字符 ch_n,匹配类似chan,chbn,chcn这种数据 [charlist] 字符序列中的任一个单个字符 [ABC],匹配A,B,C [^charlist] or [!charlist] 不在字符序列中的任一个字符 [!ABC],匹配除了A,B,C以外的其他字符 123SELECT col_nameFROM tb_nameWHERE col_name LIKE pattern; 附1.2 正则表达式1todo 附2. 表约束 约束 描述 NOT NULL 指示某列不能存储 NULL 值。 UNIQUE 保证某列的每行必须有唯一的值。 PRIMARY KEY NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。 FOREIGN KEY 保证一个表中的数据匹配另一个表中的值的参照完整 性。 CHECK 保证列中的值符合指定的条件。 DEFAULT 规定没有给列赋值时的默认值。 附2.1 NOT NULL 非空约束NOT NULL 约束强制列不接受NULL值。NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。 1234567CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255)); 附2.2 UNIQUE 唯一约束UNIQUE 约束唯一标识数据库表中的每条记录。UNIQUE和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。PRIMARY KEY 约束拥有自动定义的 UNIQUE 约束。请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。 1234567891011121314151617181920212223242526272829303132/* MySQL */CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),UNIQUE (P_Id))/* SQL Server / Oracle / MS Access */CREATE TABLE Persons(P_Id int NOT NULL UNIQUE,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255))命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName)) 更改UNIQUE约束12345678910111213ALTER TABLE PersonsADD UNIQUE (P_Id)如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，请使用下面的 SQL 语法：ALTER TABLE PersonsADD CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName)撤销 UNIQUE 约束 MySQL：ALTER TABLE PersonsDROP INDEX uc_PersonIDSQL Server / Oracle / MS Access：ALTER TABLE PersonsDROP CONSTRAINT uc_PersonID 附2.3 PRIMARY KEY 主键约束PRIMARY KEY 约束唯一标识数据库表中的每条记录。主键必须包含唯一的值。主键列不能包含 NULL 值。每个表都应该有一个主键，并且每个表只能有一个主键。 123456789101112131415161718192021222324252627282930313233/* MySQL */CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),PRIMARY KEY (P_Id))/* SQL Server / Oracle / MS Access */CREATE TABLE Persons(P_Id int NOT NULL PRIMARY KEY,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255))命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束 CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName))注释：在上面的实例中，只有一个主键 PRIMARY KEY（pk_PersonID）。然而，pk_PersonID 的值是由两个列（P_Id 和 LastName）组成的。 更改PRIMARY KEY约束123456789101112131415ALTER TABLE PersonsADD PRIMARY KEY (P_Id)如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束，请使用下面的 SQL 语法：ALTER TABLE PersonsADD CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName)注释：如果您使用 ALTER TABLE 语句添加主键，必须把主键列声明为不包含 NULL 值（在表首次创建时）。撤销 PRIMARY KEY 约束/* MySQL */ALTER TABLE PersonsDROP PRIMARY KEY/* SQL Server / Oracle / MS Access */ALTER TABLE PersonsDROP CONSTRAINT pk_PersonID 附2.4 FOREIGN KEY 外键约束一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。FOREIGN KEY 约束用于预防破坏表之间连接的行为。FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。 例如：我们现在有Persons表用来存储用户信息，Persons表主键P_Id表示用户id，Orders表用来存储用户订单，Orders表外键P_Id指向 Persons表的主键P_Id，来约束Orders表中所有订单的用户id必须是在用户表中出现的。 Orders 表中的 P_Id 列指向 Persons 表中的 P_Id 列。 Persons 表中的 P_Id 列是 Persons 表中的 PRIMARY KEY。 Orders 表中的 P_Id 列是 Orders 表中的 FOREIGN KEY。 1234567891011121314151617181920212223242526272829/* MySQL */CREATE TABLE Orders(O_Id int NOT NULL,OrderNo int NOT NULL,P_Id int,PRIMARY KEY (O_Id),FOREIGN KEY (P_Id) REFERENCES Persons(P_Id))/* SQL Server / Oracle / MS Access */CREATE TABLE Orders(O_Id int NOT NULL PRIMARY KEY,OrderNo int NOT NULL,P_Id int FOREIGN KEY REFERENCES Persons(P_Id))命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束CREATE TABLE Orders(O_Id int NOT NULL,OrderNo int NOT NULL,P_Id int,PRIMARY KEY (O_Id),CONSTRAINT fk_PerOrders FOREIGN KEY (P_Id)REFERENCES Persons(P_Id)) 更改外键约束 1234567891011121314151617ALTER TABLE OrdersADD FOREIGN KEY (P_Id)REFERENCES Persons(P_Id)如需命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束，请使用下面的 SQL 语法：ALTER TABLE OrdersADD CONSTRAINT fk_PerOrdersFOREIGN KEY (P_Id)REFERENCES Persons(P_Id)撤销 FOREIGN KEY 约束 /* MySQL */ALTER TABLE OrdersDROP FOREIGN KEY fk_PerOrders/* SQL Server / Oracle / MS Access */ALTER TABLE OrdersDROP CONSTRAINT fk_PerOrders 附2.5 CHECK 约束CHECK 约束用于限制列中的值的范围。如果对单个列定义 CHECK 约束，那么该列只允许特定的值。如果对一个表定义 CHECK 约束，那么此约束会基于行中其他列的值在特定的列中对值进行限制。1234567891011121314151617181920212223242526272829303132/* MySQL */CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CHECK (P_Id&gt;0))/* SQL Server / Oracle / MS Access */CREATE TABLE Persons(P_Id int NOT NULL CHECK (P_Id&gt;0),LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255))如需命名 CHECK 约束，并定义多个列的 CHECK 约束 CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT chk_Person CHECK (P_Id&gt;0 AND City='Sandnes')) 更改CHECK约束1234567891011121314ALTER TABLE PersonsADD CHECK (P_Id&gt;0)如需命名 CHECK 约束，并定义多个列的 CHECK 约束ALTER TABLE PersonsADD CONSTRAINT chk_Person CHECK (P_Id&gt;0 AND City='Sandnes')撤销 CHECK 约束 /* MySQL */ALTER TABLE PersonsDROP CHECK chk_Person/* SQL Server / Oracle / MS Access */ALTER TABLE PersonsDROP CONSTRAINT chk_Person 附2.6 DEFAULT 约束DEFAULT 约束用于向列中插入默认值。如果没有规定其他的值，那么会将默认值添加到所有的新记录。1234567891011121314151617CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255) DEFAULT 'Sandnes')通过使用类似 GETDATE() 这样的函数，DEFAULT 约束也可以用于插入系统值CREATE TABLE Orders(O_Id int NOT NULL,OrderNo int NOT NULL,P_Id int,OrderDate date DEFAULT GETDATE()) 更改DEFAULT约束1234567891011121314151617181920添加 DEFAULT 约束/* MySQL */：ALTER TABLE PersonsALTER City SET DEFAULT 'SANDNES'/* SQL Server / MS Access */ALTER TABLE PersonsALTER COLUMN City SET DEFAULT 'SANDNES'/* Oracle */ALTER TABLE PersonsMODIFY City DEFAULT 'SANDNES'撤销 DEFAULT 约束 /* MySQL */ALTER TABLE PersonsALTER City DROP DEFAULT/* SQL Server / Oracle / MS Access */ALTER TABLE PersonsALTER COLUMN City DROP DEFAULT 附2.7 AUTO INCREMENT]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Fragment懒加载]]></title>
      <url>%2F2017%2F03%2F14%2FAndroid%E5%BC%80%E5%8F%91%2FFragment%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[ViewPager结合Fragment使用时，由于ViewPager的特性，会预先加载当前显示页面左右两边的页面，也就是说默认会缓存3个页面，（也可以使用 mViewPager.setOffscreenPageLimit(3); 这个方法来改变这个设置。）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo加密文章示例]]></title>
      <url>%2F2017%2F03%2F02%2F%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%2FHexo%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0%E7%A4%BA%E4%BE%8B%2F</url>
      <content type="text"><![CDATA[本文使用Hexo加密]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo]]></title>
      <url>%2F2017%2F03%2F02%2F%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%2FHexo%E5%BB%BA%E7%AB%99%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[1. 前言 本文主要介绍如何使用Hexo+NexT搭建自己的博客 2. SEO优化Hexo NexT主题SEO优化 3. 页面简单加密访问3.1 找到文件themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig在&lt;meta&gt;标签之后添加如下js代码 12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 在文章的Front-matter定义password 123456789---layout: posttitle: Hexo加密文章示例date: 2017-03-02category: tags: keywords:password: 123456--- 4. 添加留言界面4.1 添加page在博客根目录下执行如下命令，会在source目录下面创建msg/index.md文件 1hexo new page msg 4.2 配置·多说·在msg/index.md文件底部添加如下html代码 1&lt;div class="ds-recent-visitors" data-num-items="28" data-avatar-size="42" id="ds-recent-visitors"&gt;&lt;/div&gt; 进入多说站点，打开设置-&gt;自定义CSS，在输入框内加入如下css代码 1234567891011121314151617#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123; width: 54px; height: 54px; /*設置圖像的長和寬，這裏要根據自己的評論框情況更改*/ border-radius: 27px; /*設置圖像圓角效果,在這裏我直接設置了超過width/2的像素，即為圓形了*/ -webkit-border-radius: 27px; /*圓角效果：兼容webkit瀏覽器*/ -moz-border-radius: 27px; box-shadow: inset 0 -1px 0 #3333sf; /*設置圖像陰影效果*/ -webkit-box-shadow: inset 0 -1px 0 #3333sf;&#125;#ds-recent-visitors .ds-avatar &#123; float: left&#125;/*隱藏多說底部版權*/#ds-thread #ds-reset .ds-powered-by &#123; display: none;&#125; 4.3 配置文字和图标配置页面，打开themes/next/_config.yml文件，进行如下配置，才能使留言的界面显示侧边栏中 1234567menu: home: / #about: /about archives: /archives tags: /tags categories: /categories guestbook: /guestbook 配置图标，打开themes/next/_config.yml文件，进行如下配置，可以自定义显示在侧边栏的留言的图标，图标的配置使用key-value的形式，下面代码中home``calendar等都是key，使用这个key可以从这个网站-FontAwesome获取图标，如果想更换图标，只需要去那个网站获取图标的名字去掉头部的icon作为key添加到下面代码中即可。 12345678910menu_icons: enable: true home: home about: user categories: th schedule: calendar tags: tags guestbook : comments archives: archive commonweal: heartbeat 打开themes/next/language/zh-CN.yml文件，进行如下配置，才能显示为 留言 字样 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 guestbook: 留言]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[快速接入微信微博QQ原生登录分享]]></title>
      <url>%2F2016%2F12%2F08%2FAndroid%E5%BC%80%E5%8F%91%2F%E5%8D%81%E5%88%86%E9%92%9F%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E5%BE%AE%E5%8D%9AQQ%E5%8E%9F%E7%94%9F%E7%99%BB%E5%BD%95%E5%88%86%E4%BA%AB%2F</url>
      <content type="text"><![CDATA[1. 前言第三方登录和分享，一般每个app都会接入这个功能，来简化用户注册登录的流程，现在也有很多集成的平台，比如umeng,shareSdk等等，极大的降低了了开发者接入的成本，不过也同样存在一些问题，相信大家也都遇到过。 所以我使用原生的SDK封装了一个Library，实现了登录和分享的相关功能，并尽可能的简化了调用API， 希望能简化三方接入的流程的同时实现高度的自定义，当然也有一些接入的时候遇到的坑，分享一下。 目前支持微信、微博、QQ，SDK已经集成在Lib里面，下载之后直接依赖module即可 GitHub,是在platform_test分支下的代码,要切到platform_test分支才能看到 开始 首先你应该去每个平台申请appId或者appKey,这个是免不了的，每个平台不一样这里统称AppId 1234567891011121314151617String qqAppId = "110x571x60";String wxAppId = "wx8xfa4edccxbb3e84";String wbAppId = "36x93x0615";// 初始化每个平台Platform.newInst(this);Platform.getInst().initWx(this, wxAppId);Platform.getInst().initQQ(this, qqAppId);Platform.getInst().initWb(this, wbAppId);// or 一次初始化三个平台Platform.getInst().init(this, qqAppId,wxAppId,wbAppId);// 获取各个平台的APImWxPlatform = Platform.getInst().wx();mWbPlatform = Platform.getInst().wb();mQqPlatform = Platform.getInst().qq(); 微信快速接入微信接入前准备 微信接入前需要准备一些工作，按照微信官方的文档来说，你需要在你的app的包下建立一个wxapi的包并创建WxEntryActivity.class，比如你的工程包名是com.test.package,那就是在com.test.package.wxapi包下面建立WxEntryActivity.class，并在AndroidManifest.xml,注册该Activity,它将作为微信分享的回调页。 12345&lt;!-- 微信专用Activity --&gt;&lt;activity android:name=".wxapi.WXEntryActivity" android:exported="true" android:label="@string/app_name" /&gt; 为了简化开发，我已经写好一个AbsWxEntryActivity,你可以采用最简单的方式直接继承这个Activity，如下，当然你可能需要所有的Activity都实现你自己写好的的基类，那可以拷贝AbsWXEntryActivity里面的内容到你创建的类中即可。 12345package com.march.reaper.wxapi;import com.march.lib.platform.wx.AbsWXEntryActivity;public class WXEntryActivity extends AbsWXEntryActivity &#123; // 啥都不用写&#125; 微信分享 在类库中已经写好常用的分享方法，目前支持文本|Bitmap|本地图片文件|GIF动图(emoji)|网络视频|网络音频|网页 说明一下几个需要注意的地方 视频音频之类的可以在聊天列表中之间点击播放，但是不能分享本地音视频资源，不然能分享成功，点击之后也是无效的 网络图片需要分享的话需要先进行下载之后再分享 实现分享回调监听,监测分享的结果 12345678910111213141516mWxPlatform.setWxShareListener(new OnWxShareListener() &#123; @Override public void onSuccess() &#123; toast("分享成功"); &#125; @Override public void onFailure(PlatformException e) &#123; toast("分享失败"); &#125; @Override public void onCancel() &#123; toast("分享取消"); &#125; &#125;); 分享类型。微信分享支持分享到好友，群，朋友圈，收藏,使用常量来表示 123WxPlatform.ZONE 朋友圈WxPlatform.CHAT 好友和群WxPlatform.FAVORITE 收藏 直接用代码罗列一下API 1234567891011121314// 分享文本mWxPlatform.shareText("测试", WxPlatform.CHAT);// 分享bitmap,网络图片请先下载mWxPlatform.shareImage(testBit, WxPlatform.CHAT);// 本地图片，本质还是bitmap，封装了一下mWxPlatform.shareImage(localImagePath, WxPlatform.CHAT);// 分享Gif或emoji表情mWxPlatform.shareGif(localGifPath, WxPlatform.CHAT);// 分享视频mWxPlatform.shareVideo(netVideoPath, "video title", "video desc", thumbBit, WxPlatform.CHAT);// 分享音乐mWxPlatform.shareMusic(netMusicPath, "music title", "music desc", thumbBit, WxPlatform.CHAT);// 分享网页mWxPlatform.shareWebPage(testWebUrl, "web title", "web desc", thumbBit, WxPlatform.CHAT); 微信登录 微信登录需要请求access_token,获取token,刷新token,token持久化存储等相关功能已经封装在Libs里面 登录功能需要secretKey，另外现在微信登录居然要开发者认证，¥300。。不过我还是测试过啦。。。 123456789101112mWxPlatform.login(mContext, secretKey, new OnWxLoginListener() &#123; @Override public void onSucceed(WxUserInfo info) &#123; // 获取到结果 mInfoTv.setText(info.toString()); &#125; @Override public void onException(PlatformException e) &#123; log(e.getMessage()); &#125; &#125;); QQ快速接入QQ接入前准备 接入QQ之前的准备工作,在AndroidMenifest.xml中注册相关Activity,在&lt;data android:scheme=&quot;tencent11x5x71460&quot; /&gt;要加入tencent(AppId), 注意 12345678910111213141516&lt;!-- QQ专用Activity --&gt;&lt;activity android:name="com.tencent.tauth.AuthActivity" android:launchMode="singleTask" android:noHistory="true"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.V &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;category android:name="android.intent.category.BROWSA &lt;data android:scheme="tencent11x5x71460" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity android:name="com.tencent.connect.common.AssistActivity" android:configChanges="orientation|keyboardHidden|screenSize" android:theme="@android:style/Theme.Translucent.NoTitleBar" /&gt; QQ分享 在onActivityResult()中接受数据进行处理 12345@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; mQqPlatform.onActivityResult(requestCode, resultCode, data); super.onActivityResult(requestCode, resultCode, data);&#125; 目前支持分享到群，好友，空间 12QQPlatform.ZONE qq空间QQPlatform.CHAT 好友和群 设置分享的监听事件 1234567891011121314151617mQqPlatform.setOnQQShareListener(new OnQQShareListener() &#123; @Override public void onSuccess() &#123; toast("分享成功"); &#125; @Override public void onFailure(PlatformException e) &#123; toast("分享失败 " + e.getQQError().errorDetail); &#125; @Override public void onCancel() &#123; toast("分享取消"); &#125; &#125;); 列举一下支持的分享类型 12345678// 分享本地图片mQqPlatform.shareLocalImage(mActivity, localImagePath, QQPlatform.CHAT);// 分享图文mQqPlatform.shareImageText(mActivity, "title", "summary", testWebUrl, localImagePath, QQPlatform.CHAT);// 分享app,会打开app在应用宝的下载地址mQqPlatform.shareApp(mActivity, "title", "summary", testWebUrl, localImagePath, QQPlatform.CHAT);// 分享音乐mQqPlatform.shareAudio(mActivity, "title", "summary", testWebUrl, localImagePath, netMusicPath, QQPlatform.CHAT); QQ登录 一行代码接入 123456789101112mQqPlatform.login(mActivity, new OnQQLoginListener() &#123; @Override public void onException(PlatformException e) &#123; log(e.getQQError().errorMessage + " " + e.getQQError().errorDetail); &#125; @Override public void onSucceed(QQUserInfo userInfo) &#123; log(userInfo); &#125; &#125;); 微博快速接入微博接入前准备 微博接入比较麻烦，需要配置的地方很多，坑也特别多。 需要注意的地方是有个回调的url,会在微博管理台那里配置，请使用默认的那个url 微博分享 1.首先在AndroidManifest.xml中配置你的发起分享的Activity，如下,不然没办法接收到成功或者失败的回调 123456789&lt;activity android:name=".TestPlatformActivity" android:configChanges="keyboardHidden|orientation" android:screenOrientation="portrait"&gt; &lt;intent-filter&gt; &lt;action android:name="com.sina.weibo.sdk.action.ACTION_SDK_REQ_ACTIVITY" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 2.设置监听 1234567891011121314151617mWbPlatform.setWbShareListener(new OnWbShareListener() &#123; @Override public void onSuccess() &#123; toast("分享成功"); &#125; @Override public void onFailure(PlatformException e) &#123; toast("分享失败"); e.getWbError().printStackTrace(); &#125; @Override public void onCancel() &#123; toast("分享取消"); &#125; &#125;); 3.微博分享需要发起分享的Activity实现IWeiboHandler.Response接口，这里要说一下为什么没有把这个监听拿到类库里面，因为必须是Activity实现这个监听，不然没办法获取到分享的结果，真的很坑，所以只能拿出来自己实现啦，不过处理的方法我已经写在类库里面只要调用一下就好了，代码如下 12345678public class TestPlatformActivity extends Activity implements IWeiboHandler.Response &#123; ... 此处省略若干代码 @Override public void onResponse(BaseResponse baseResponse) &#123; mWbPlatform.handleWbResponse(baseResponse); &#125; ... 此处省略若干代码&#125; 4.然后需要在onCreate()和onNewIntent()方法中实现如下代码接受数据 12345678910111213141516@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test_platform); // 在这里实现是在Activity被销毁时接受数据，这里的this参数接受的是类型是IWeiboHandler.Response mWbPlatform.onCreate(mActivity, savedInstanceState, this); ... 此处省略若干代码&#125;@Overrideprotected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); // Activity返回时被调用，这里的this参数接受的是类型是IWeiboHandler.Response mWbPlatform.onNewIntent(intent, this);&#125; 5.分享的API，这里分享有两种方式，一种是不需要登录的，也就是下面介绍的这几种方式，另外一种使用openApi来分享，需要用户授权，为什么要引入这种方式呢，因为微博分享图片大小有限制，不能大于32kb,就有点鸡肋啦，32kb的图片根本不够看。在下面的分享中很多字段分享到微博是看不到效果的，都是文字+网页链接，真的挺难看的，因为title,desc，bitmap这些字段都是显示在LinkCard上的，就是显示为卡片的样式，但是想能这样显示需要进行商业合作才可以,另外在textContent参数中的内容如果有网页链接，会自动隐藏替换为网页链接四个字是不会显示url的 12345678910// 分享文字mWbPlatform.shareText(mActivity, "test");// 分享网页mWbPlatform.shareWebpage(mActivity, "textContent", "title", "desc", bitmap, testWebUrl);// 分享音乐mWbPlatform.shareMusic(mActivity, "textContent", "title", "desc", bitmap, netMusicPath, netMusicPath, 10);// 分享视频mWbPlatform.shareVideo(mActivity, "textContent", "title", "desc", bitmap, netVideoPath, netVideoPath, 10);// 分享声音mWbPlatform.shareVoice(mActivity, "textContent", "title", "desc", bitmap, netMusicPath, netMusicPath, 10); 微博 openApi 分享 使用openApi分享需要先进行授权，也就是会弹起微博客户端授权界面点击登陆之后获得授权，当然，也已经封装好啦，只要调用分享的代码就可以啦。就直接贴代码啦 123456// 分享图片bitmapmWbPlatform.shareImage(mActivity, "text", bitmapThumb);// 分享网络图片，这里是高级接口需要在微博后台申请的mWbPlatform.shareNetImage(mActivity, "text", netImagePath);// 分享GIF，这个分享出来是会有预览效果的mWbPlatform.shareGif(mActivity, "text", localGifPath); 微博登录 微博登录授权需要在onActivityResult()接受授权的结果，，比起微信和QQ配置的地方太多啦，主要原因还是微信和QQ是有自己的Activity注册上啦，回头可以模仿微信和QQ的方式写个Activity接受数据，再返回给调用的Activity就不需要做如此多的配置啦。一行代码登录 123456789101112131415161718192021222324@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; mWbPlatform.onActivityResult(requestCode, resultCode, data); super.onActivityResult(requestCode, resultCode, data);&#125;mWbPlatform.login(mActivity, new OnWbLoginListener() &#123; @Override public void onSucceed(WbUserInfo info) &#123; log(info.toString()); &#125; @Override public void onCancel() &#123; toast("取消"); &#125; @Override public void onException(PlatformException e) &#123; e.getWbError().printStackTrace(); &#125; &#125;); 结束就这么多内容，这三个平台是目前接入最多的吧，提取这个Lib出来以后再做第三方登录分享就简单多啦，还有很多地方不足，API也不够简单，配置的地方太多，继续完善吧，加油]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[快速实现Fragment切换功能]]></title>
      <url>%2F2016%2F11%2F05%2FAndroid%E5%BC%80%E5%8F%91%2F%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0Fragment%E5%88%87%E6%8D%A2%E5%8A%9F%E8%83%BD%2F</url>
      <content type="text"><![CDATA[1. 前言 一个app首页通常是使用Activity + Fragment的形式展示，控制Fragment的显示和隐藏基本有两种实现方法:&emsp;&emsp;1. ViewPager , 比如微信 , 优势是手势操作更加方便，官方提供了FragmentPagerAdapter可以很方便帮助我们实现数据加载（Fragment要使用懒加载的方式，避免浪费资源），劣势就是当你的第一个Fragment中已经使用了ViewPager，两层套一起事件会冲突，而且操作也不友好啦。&emsp;&emsp;2. FragmentManager , 比如头条，针对使用ViewPager组合Fragment的问题，使用FragmentManager控制Fragment的显示和隐藏，不需要考虑懒加载的问题，不过不能支持滑动啦。&emsp;&emsp;3. 本文主要是封装FragmentManager切换页面的相关操作。 2. 最初的方案刚开始的方案是定义了一个Activity的基类MultiFragmentActivity，在基类中实现切换Fragment的逻辑，想要实现该功能的Activity继承基类就可以实现切换功能。MultiFragmentActivity.java源代码，这种实现方式使用起来要更加简单，但是有个问题，整个项目通常会实现同一个基类来完成类似或者相同的功能，当然我们可以将MultiFragmentActivity继承自项目的基类，然后再继承MultiFragmentActivity，但是这样就不能把这个功能提取出来。 少用继承，多用组合，继承造成的问题就是耦合性太高，不方便分离功能，所以决定使用组合的方法重新设计，定义帮助类FragmentHelper，并且使用一个接口与需要进行Fragment切换的Activity进行交流，Activity可以持有FragmentHelper来完成Fragment的切换，具体的切换逻辑由FragmentHelper来处理。 3. 定义接口首先定义FragmentOperator接口，借助该接口需要进行Fragment切换的Activity可以自定义一些操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061interface FragmentOperator &#123; /** * 获取放置fragment的控件id * * @return id */ int getFragmentContainerId(); /** * 构建fragment * * @param showItem 将要展示的fragment pos * @return fragment */ Fragment makeFragment(int showItem); /** * 进行转换之前做操作,实现该方法可以自定义fragment切换的动画效果等 * * @param transaction transaction */ void beginTransaction(FragmentTransaction transaction); /** * 切换成功之后会回调这个方法，同步选中之后的显示状态 * 比如改变按钮的颜色等操作 * * @param selectImage 被选中的item */ void syncSelectState(int showItem); /** * 当点击显示同一个，当两次切换到了同一个fragment，返回true时会进行此次切换 * * @param showItem 显示的item * @return 返回false表示忽略此次点击的切换 */ boolean whenShowSameFragment(int showItem); /** * 当点击显示的不是同一个，用于需要针对切换到某个fragment时的场景 * * @param showItem 显示的item * @return 返回false表示忽略此次点击的切换 */ boolean whenShowNotSameFragment(int showItem);&#125;// 上面的接口中不是所有的方法都是必须的，下面是一个简单的实现public static abstract class SimpleFragmentOperator implements FragmentOper @Override public boolean whenShowNotSameFragment(int showItem) &#123; return true; &#125; @Override public boolean whenShowSameFragment(int showItem) &#123; return false; &#125; @Override public void syncSelectState(int showItem) &#123; &#125; @Override public void beginTransaction(FragmentTransaction transaction) &#123; &#125;&#125; 4. 核心方法使用tag作为标记添加fragment,避免重复创建 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private static final String FRAGMENT_ATG = "FragmentHelper";private static final String ITEM_HIDE = "mHideItem";private static final String ITEM_SHOW = "mShowItem";private FragmentOperator operator;private Fragment mCurrentFragment;private FragmentManager mFragmentManager;private int mShowItem, mHideItem;private int mExactlyItem = 0; /** * 隐藏当前显示的fragment,显示将要显示的fragment * * @param hideItem 需要隐藏的fragment * @param showItem 需要显示的fragment * @param isOnCreate 是否是第一次从OnCreate中启动,点击都是false */private void performSelectItem(int hideItem, int showItem, boolean isOnCreate) &#123; // 获得将要显示页的tag String currentTag = getFragmentTag(hideItem); // 隐藏当前的的fragment FragmentTransaction transaction = mFragmentManager.beginTransaction(); operator.beginTransaction(transaction); // 第一次创建，一个都没有，不需要隐藏，直接显示 if (mFragmentManager.getFragments() == null) &#123; mShowItem = showItem; mExactlyItem = showItem; mCurrentFragment = operator.makeFragment(showItem); transaction.add(operator.getFragmentContainerId(), mCurrentFragment, getFragmentTag( .show(mCurrentFragment); &#125; else &#123; // 优化，如果被杀后再进来，全部的fragment都会被呈现显示状态，所以都隐藏一遍 if (isOnCreate &amp;&amp; mFragmentManager.getFragments() != null) &#123; for (Fragment fragment : mFragmentManager.getFragments()) &#123; transaction.hide(fragment); &#125; &#125; else &#123; // 正常按钮点击进入，隐藏上一个即可 Fragment lastFragment = mFragmentManager.findFragmentByTag(currentTag); if (lastFragment != null) &#123; transaction.hide(lastFragment); &#125; &#125; // 获得将要显示页的tag String toTag = getFragmentTag(showItem); // find要显示的Fragment mCurrentFragment = mFragmentManager.findFragmentByTag(toTag); if (mCurrentFragment != null) &#123; // 已经存在则显示 transaction.show(mCurrentFragment); &#125; else &#123; // 不存在则添加新的fragment mCurrentFragment = operator.makeFragment(showItem); if (mCurrentFragment != null) &#123; transaction.add(operator.getFragmentContainerId(), mCurrentFragment, toTag); &#125; &#125; &#125; // 同步状态 operator.syncSelectState(showItem); // 保存当前显示fragment的item mHideItem = hideItem; mShowItem = showItem; transaction.commitAllowingStateLoss();&#125; 5. 在Activty显示某个Fragment在Activity中使用时只需要调用showFragment方法即可 123456789101112131415161718/** * 显示某个fragment * * @param showItem 显示的item */public void showFragment(int showItem) &#123; if (showItem == mShowItem) &#123; if (operator.whenShowSameFragment(showItem)) &#123; performSelectItem(mExactlyItem, showItem, false); mExactlyItem = showItem; &#125; &#125; else &#123; if (operator.whenShowNotSameFragment(showItem)) &#123; performSelectItem(mExactlyItem, showItem, false); mExactlyItem = showItem; &#125; &#125;&#125; 6. 优化当Activity被回收时，记录上次的状态 123456789101112131415161718192021222324252627282930313233343536// 保存数据// FragmentHelperpublic void onCreate(Bundle save) &#123; if (save != null) &#123; mHideItem = save.getInt(ITEM_HIDE, 0); mShowItem = save.getInt(ITEM_SHOW, 0); performSelectItem(mHideItem, mShowItem, true); &#125;&#125;// 在Activity销毁时调用@Overrideprotected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); if (mFragmentHelper != null) &#123; mFragmentHelper.onSaveInstanceState(outState); &#125;&#125;// 重新加载// FragmentHelperpublic void onCreate(Bundle save) &#123; if (save != null) &#123; mHideItem = save.getInt(ITEM_HIDE, 0); mShowItem = save.getInt(ITEM_SHOW, 0); performSelectItem(mHideItem, mShowItem, true); &#125;&#125;// 在Activity创建时调用@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mFragmentHelper = new FragmentHelper(getSupportFragmentManager(), mSimpleOperator); mFragmentHelper.onCreate(savedInstanceState);&#125; 7. 使用123456789101112131415161718192021222324252627282930313233343536373839404142public class TestMultiFragmentActivity2 extends BaseActivity &#123; private FragmentHelper mFragmentHelper; private FragmentHelper.SimpleFragmentOperator mSimpleOperator; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mSimpleOperator = new FragmentHelper.SimpleFragmentOperator() &#123; @Override public int getFragmentContainerId() &#123; return 0; &#125; @Override public Fragment makeFragment(int showItem) &#123; return null; &#125; @Override public void syncSelectState(int showItem) &#123; &#125; &#125;; mFragmentHelper = new FragmentHelper(getSupportFragmentManager(), mSimpleOperator); // 只有销毁后回来才会调起切换操作否则没反应 mFragmentHelper.onCreate(savedInstanceState); &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); if (mFragmentHelper != null) &#123; mFragmentHelper.onSaveInstanceState(outState); &#125; &#125; @Override protected int getLayoutId() &#123; return 0; &#125;&#125; 8. 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206/** * CreateAt : 2016/11/5 * Describe : 实现Fragment切换 * * @author chendong */public class FragmentHelper &#123; private static final String FRAGMENT_ATG = "FragmentHelper"; private static final String ITEM_HIDE = "mHideItem"; private static final String ITEM_SHOW = "mShowItem"; private FragmentOperator operator; private Fragment mCurrentFragment; private FragmentManager mFragmentManager; private int mShowItem, mHideItem; private int mExactlyItem = 0; public void onCreate(Bundle save) &#123; if (save != null) &#123; mHideItem = save.getInt(ITEM_HIDE, 0); mShowItem = save.getInt(ITEM_SHOW, 0); performSelectItem(mHideItem, mShowItem, true); &#125; &#125; public void onSaveInstanceState(Bundle outState) &#123; outState.putInt(ITEM_HIDE, mHideItem); outState.putInt(ITEM_SHOW, mShowItem); &#125; public FragmentHelper(FragmentManager mFragmentManager, FragmentOperator operator) &#123; this.mFragmentManager = mFragmentManager; this.mFragmentManager = mFragmentManager; this.operator = operator; &#125; /** * 显示某个fragment * * @param showItem 显示的item */ public void showFragment(int showItem) &#123; if (showItem == mShowItem) &#123; if (operator.whenShowSameFragment(showItem)) &#123; performSelectItem(mExactlyItem, showItem, false); mExactlyItem = showItem; &#125; &#125; else &#123; if (operator.whenShowNotSameFragment(showItem)) &#123; performSelectItem(mExactlyItem, showItem, false); mExactlyItem = showItem; &#125; &#125; &#125; /** * 获取当前处于活动状态的fragment' * * @return fragment */ public Fragment getCurrentFragment() &#123; return mCurrentFragment; &#125; /** * 隐藏当前显示的fragment,显示将要显示的fragment * * @param hideItem 需要隐藏的fragment * @param showItem 需要显示的fragment * @param isOnCreate 是否是第一次从OnCreate中启动,点击都是false */ private void performSelectItem(int hideItem, int showItem, boolean isOnCreate) &#123; // 获得将要显示页的tag String currentTag = getFragmentTag(hideItem); // 隐藏当前的的fragment FragmentTransaction transaction = mFragmentManager.beginTransaction(); operator.beginTransaction(transaction); // 第一次创建，一个都没有，不需要隐藏，直接显示 if (mFragmentManager.getFragments() == null) &#123; mShowItem = showItem; mExactlyItem = showItem; mCurrentFragment = operator.makeFragment(showItem); transaction.add(operator.getFragmentContainerId(), mCurrentFragment, getFragmentTag(showItem)) .show(mCurrentFragment); &#125; else &#123; // 优化，如果被杀后再进来，全部的fragment都会被呈现显示状态，所以都隐藏一遍 if (isOnCreate &amp;&amp; mFragmentManager.getFragments() != null) &#123; for (Fragment fragment : mFragmentManager.getFragments()) &#123; transaction.hide(fragment); &#125; &#125; else &#123; // 正常按钮点击进入，隐藏上一个即可 Fragment lastFragment = mFragmentManager.findFragmentByTag(currentTag); if (lastFragment != null) &#123; transaction.hide(lastFragment); &#125; &#125; // 获得将要显示页的tag String toTag = getFragmentTag(showItem); // find要显示的Fragment mCurrentFragment = mFragmentManager.findFragmentByTag(toTag); if (mCurrentFragment != null) &#123; // 已经存在则显示 transaction.show(mCurrentFragment); &#125; else &#123; // 不存在则添加新的fragment mCurrentFragment = operator.makeFragment(showItem); if (mCurrentFragment != null) &#123; transaction.add(operator.getFragmentContainerId(), mCurrentFragment, toTag); &#125; &#125; &#125; // 同步状态 operator.syncSelectState(showItem); // 保存当前显示fragment的item mHideItem = hideItem; mShowItem = showItem; transaction.commitAllowingStateLoss(); &#125; private String getFragmentTag(int item) &#123; return FRAGMENT_ATG + item; &#125; interface FragmentOperator &#123; /** * 获取放置fragment的控件id * * @return id */ int getFragmentContainerId(); /** * 构建fragment * * @param showItem 将要展示的fragment pos * @return fragment */ Fragment makeFragment(int showItem); /** * 进行转换之前做操作,实现该方法可以自定义fragment切换的动画效果等 * * @param transaction transaction */ void beginTransaction(FragmentTransaction transaction); /** * 切换成功之后会回调这个方法，同步选中之后的显示状态 * 比如改变按钮的颜色等操作 * * @param showItem 被选中的item */ void syncSelectState(int showItem); /** * 当点击显示同一个，当两次切换到了同一个fragment，返回true时会进行此次切换 * * @param showItem 显示的item * @return 返回false表示忽略此次点击的切换 */ boolean whenShowSameFragment(int showItem); /** * 当点击显示的不是同一个，用于需要针对切换到某个fragment时的场景 * * @param showItem 显示的item * @return 返回false表示忽略此次点击的切换 */ boolean whenShowNotSameFragment(int showItem); &#125; // 上面的接口中不是所有的方法都是必须的，下面是一个简单的实现 public static abstract class SimpleFragmentOperator implements FragmentOperator &#123; @Override public boolean whenShowNotSameFragment(int showItem) &#123; return true; &#125; @Override public boolean whenShowSameFragment(int showItem) &#123; return false; &#125; @Override public void syncSelectState(int showItem) &#123; &#125; @Override public void beginTransaction(FragmentTransaction transaction) &#123; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[高仿QQ微信相册]]></title>
      <url>%2F2016%2F11%2F02%2FAndroid%E5%BC%80%E5%8F%91%2F%E9%AB%98%E4%BB%BFQQ%E5%BE%AE%E4%BF%A1%E7%9B%B8%E5%86%8C%2F</url>
      <content type="text"><![CDATA[1. 前言 结合微信和QQ相册的一些特点实现系统相册的选择，这篇博客主介绍了开发过程中遇到的点，记录一下。 ContentProvider中数据的获取微信的浮动相册照片时间显示微信的dialog选择相册QQ的滑动选中照片QQ的图片角标数字显示及更新界面的相关优化 2. 演示视频和源代码仿QQ微信相册选择效果视频演示 GitHub源代码 3. 推荐阅读仿QQ相册RecyclerView滑动选中 仿QQ相册RecyclerView滑动选中进阶 RecyclerView快速适配Adapter 4. 数据获取4.1 定义照片的数据结构从ContentProvider中获取结构化数据,实现Comparable和Parcelable接口，用于数据传输和比较。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class ImageInfo implements Comparable&lt;ImageInfo&gt;, Parcelable &#123; // 设置id为自增长的组件 private Integer id; // 文件地址 private String path; // 照片名字 private String name; // 秒数 private String date; @Override public int hashCode() &#123; return 1; &#125; @Override public boolean equals(Object o) &#123; return super.equals(o) &amp;&amp; path.equals(((ImageInfo) o).getPath()); &#125; @Override public int compareTo(@NonNull ImageInfo another) &#123; long a = Long.parseLong(date); long b = Long.parseLong(another.getDate()); if (b &gt; a) &#123; return 1; &#125; else if (b &lt; a) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeValue(this.id); dest.writeString(this.path); dest.writeString(this.name); dest.writeString(this.date); &#125; public ImageInfo() &#123; &#125; protected ImageInfo(Parcel in) &#123; this.id = (Integer) in.readValue(Integer.class.getClassLoader()); this.path = in.readString(); this.name = in.readString(); this.date = in.readString(); &#125; public static final Creator&lt;ImageInfo&gt; CREATOR = new Creator&lt;ImageInfo&gt;() &#123; @Override public ImageInfo createFromParcel(Parcel source) &#123; return new ImageInfo(source); &#125; @Override public ImageInfo[] newArray(int size) &#123; return new ImageInfo[size]; &#125; &#125;;&#125; 4.2 获取数据使用ContentProvider获取手机相册中的数据，并按照时间排序 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 获取全部照片信息 * * @param context 上下文 * @return 照片信息列表 */ public static List&lt;ImageInfo&gt; getImagesByMediaStore(Context context) &#123; List&lt;ImageInfo&gt; mImageInfoList = new ArrayList&lt;&gt;(); Cursor imageCursor; try &#123; final String[] projection = &#123;MediaStore.Images.Media.DATA, MediaStore.Images.Media._ID, MediaStore.Images.Media.DATE_MODIFIED&#125;; final String sortOrder = MediaStore.Images.Media._ID; imageCursor = MediaStore.Images.Media.query(context.getContentResolver(), MediaStore.Images.Media.EXTERNAL_CONTENT_URI, projection, null, null, sortOrder); if (imageCursor != null &amp;&amp; imageCursor.getCount() &gt; 0) &#123; while (imageCursor.moveToNext()) &#123; ImageInfo imageInfo = new ImageInfo(); // 返回data在第几列，并获取地址 int dataColumnIndex = imageCursor.getColumnIndex(MediaStore.Images.Media.DATA); String path = imageCursor.getString(dataColumnIndex); File file = new File(path); // 该路径下的文件存在则添加到集合中 if (file.exists()) &#123; // 添加路径到对象中 imageInfo.setPath(path); // 插入修改时间 int modifiedColumnIndex = imageCursor.getColumnIndex(MediaStore.Images.Media.DATE_MODIFIED); String modifiedDate = imageCursor.getString(modifiedColumnIndex); // 添加修改时间到对象中 imageInfo.setDate(modifiedDate); // 添加名字 mImageInfoList.add(imageInfo); &#125; &#125; imageCursor.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 按降序排 Collections.sort(mImageInfoList); return mImageInfoList; &#125; 4.3 数据整理按照照片数据的目录结构整理成map，同目录的照片放在一起 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 /** * 目录 + 目录下的照片列表 * * @param imageInfoList 全部的照片信息 * @return (目录 照片信息列表) */ public static Map&lt;String, List&lt;ImageInfo&gt;&gt; formatImages4EachDir(List&lt;ImageInfo&gt; imageInfoList) &#123; Map&lt;String, List&lt;ImageInfo&gt;&gt; map = new ArrayMap&lt;&gt;(); map.clear(); List&lt;ImageInfo&gt; imageInfoAll = new ArrayList&lt;&gt;(); imageInfoAll.addAll(imageInfoList); map.put(ALL_IMAGE_KEY, imageInfoAll); for (ImageInfo imageInfo : imageInfoList) &#123; if (imageInfo != null &amp;&amp; imageInfo.getPath() != null) &#123; File file = new File(imageInfo.getPath()); if (file.exists()) &#123; if (file.getParentFile() != null) &#123; if (map.containsKey(file.getParentFile().getName())) &#123; // 如果key已经存在 map.get(file.getParentFile().getName()).add(imageInfo); &#125; else &#123; // 如果key不存在 List&lt;ImageInfo&gt; tempImageInfoList = new ArrayList&lt;&gt;(); tempImageInfoList.add(imageInfo); map.put(file.getParentFile().getName(), tempImageInfoList); &#125; &#125; &#125; &#125; &#125; return map; &#125;``` ## 5. 在上方显示当前照片时间### 5.1 获取需要显示的时间数据需求是在界面的上方动画显示当前RecyclerView最顶部的一张照片的时间首先获取当前第一张照片的时间，使用`RecyclerView$OnChildAttachStateChangeListener`和`GridLayoutManager$findFirstVisibleItemPosition()`来获取第一个位置的数据。```javamImageRv.addOnChildAttachStateChangeListener(new RecyclerView.OnChildAttachStateChangeListener() &#123; @Override public void onChildViewAttachedToWindow(View view) &#123; // 获取第一个位置 int firstVisibleItemPosition = mLayoutManager.findFirstVisibleItemPosition(); if (firstVisibleItemPosition &lt; 0) return; String date = mCurrentImages.get(firstVisibleItemPosition).getDate(); mDateTv.setText(simpleDateFormat.format(new Date(Long.parseLong(date) * 1000))); &#125; @Override public void onChildViewDetachedFromWindow(View view) &#123; &#125; &#125;); 5.2 根据滑动状态显示隐藏时间动画显示和隐藏时间，监听RecyclerView的滑动，当RecyclerView滑动时显示，当RecyclerView停止时隐藏。 123456789101112131415161718mAlphaAnimator = ObjectAnimator .ofFloat(mDateTv, "alpha", 1.0f, 0f) .setDuration(1500); mImageRv.addOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; super.onScrollStateChanged(recyclerView, newState); if (newState == RecyclerView.SCROLL_STATE_IDLE) &#123; if (!mAlphaAnimator.isRunning()) mAlphaAnimator.start(); &#125; else &#123; if (mAlphaAnimator.isRunning()) mAlphaAnimator.cancel(); mDateTv.setAlpha(1); &#125; &#125; &#125;); 6. 实现QQ滑动选中我自定义了滑动选中的控件，相关原理和使用在另一篇博客中单独介绍仿QQ相册RecyclerView滑动选中进阶 7. QQ角标数字显示及优化显示该张图片在被选中的图片中是第几张 1tv.setText(String.valueOf(mSelectImages.indexOf(data) + 1)); 滑动选中的监听事件 123456mSlidingSelectLy.setOnSlidingSelectListener(new SlidingSelectLayout.OnSlidingSelectListener&lt;ImageInfo&gt;() &#123; @Override public void onSlidingSelect(int pos, View parentView, ImageInfo data) &#123; notifyCheckOrNotCheck((RvViewHolder) mImageRv.findViewHolderForAdapterPosition(pos), data); &#125; &#125;); 重点，在更新角标显示的时候，最优化的方法是调用adapter.notifyItemChanged(int pos),但是调用此方法，会导致图片重新加载会闪烁一下，观察了一下QQ，没有这种情况,想到的方法是拿到ViewHolder之后从Holder中拿到角标控件，将它的状态改变(如果当前是被选中的改为不选中，如果当前是不选中的改为选中)，避免重新加载图片。 1234567891011121314151617181920212223242526272829/** * 修改选中和不选中的状态 * * @param holder */ private void notifyCheckOrNotCheck(RvViewHolder holder, ImageInfo imageInfo) &#123; TextView tv = (TextView) holder.getView(R.id.tv_select_image); View coverView = holder.getView(R.id.cover_select_image); // 是否选中 if (tv.isSelected()) &#123; // 选中改为不选中 mSelectImages.remove(imageInfo); tv.setSelected(false); coverView.setVisibility(View.GONE); tv.setText(""); &#125; else &#123; // 不选中改为选中 if (mSelectImageMaxNum != NO_LIMIT &amp;&amp; mSelectImages.size() &gt;= mSelectImageMaxNum) &#123; Toaster.get().show(mContext, "最多只能选择" + mSelectImageMaxNum + "张"); return; &#125; mSelectImages.add(imageInfo); tv.setSelected(true); coverView.setVisibility(View.VISIBLE); tv.setText(String.valueOf(mSelectImages.indexOf(imageInfo) + 1)); &#125; mEnsureTv.setText("完成 " + mSelectImages.size() + "/" + mSelectImageMaxNum); changeNumberDisplayByHolder(); &#125; 经过上面的操作，可以达到不重新加载照片的需求。新需求，当修改其中一张照片的选中状态时，他的角标和其他所有被选中图片的角标都会改变，因为中间出现了数字的改变其他数字也要改变，那就不可避免的要调用notifyDataSetChanged(),之前所做的工作就全部浪费了。想到的解决方案是拿到第一个显示和最后一个显示的位置，然后拿到所有的ViewHolder，更新这些正在桌面上显示的Holder的角标。 12345678910111213141516171819202122232425// 更新其他的item更新数字显示 private void changeNumberDisplayByHolder() &#123; int findSelectCount = 0; ImageInfo temp; TextView tv; RvViewHolder holder; int firstVisibleItemPosition = mLayoutManager.findFirstVisibleItemPosition(); int lastVisibleItemPosition = mLayoutManager.findLastVisibleItemPosition(); for (int i = firstVisibleItemPosition; i &lt;= lastVisibleItemPosition; i++) &#123; //尽量提前推出，只对第一屏有效 if (findSelectCount &gt;= mSelectImages.size()) &#123; break; &#125; holder = (RvViewHolder) mImageRv.findViewHolderForAdapterPosition(i); tv = (TextView) holder.getView(R.id.tv_select_image); if (tv.isSelected()) &#123; // 如果这个是被选中的，那么更新显示 temp = (ImageInfo) tv.getTag(R.id.data_image_info); if (temp != null &amp;&amp; mSelectImages.contains(temp)) &#123; tv.setText(String.valueOf(mSelectImages.indexOf(temp) + 1)); findSelectCount++; &#125; &#125; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[EditText使用详解]]></title>
      <url>%2F2016%2F10%2F31%2FAndroid%E5%BC%80%E5%8F%91%2FEditText%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[1. 前言 EditText是TextView的子类，用于进行文字输入等操作，是开发中特别常用的一个控件了，本文主要用来记录一些比较特殊的用法。 如： 更改EditText的背景 设置监听事件 给EditText设置具有带图片的Hint 2. 监听事件2.1 监听焦点变化123456etInput.setOnFocusChangeListener(new OnFocusChangeListener() &#123; @Override public void onFocusChange(View v, boolean hasFocus) &#123; // hasFocus 当前是否获得焦点 &#125;&#125;); 2.2 文本输入监听事件1234567891011121314etInput.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; // 文本输入之前回调 &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; // 输入过程中会频繁回调 &#125; @Override public void afterTextChanged(Editable s) &#123; // 输入结束回调 &#125;&#125;); 3. 自定义EditText背景如下图所示，当离开当前EditText时，检查输入是否有问题，输入错误会显示红色 3.1 定义背景drawable文件其他形态的背景也相对简单，只有一条线的这种背景drawable写起来还是需要研究一下的，直接上代码啦,主要是用了一个selector -&gt; layer-list -&gt; shape,在select属性改变时，改变线条的颜色。原本是一个矩形，然后将另外三个边偏移一下，只留下底边，达到线条显示的效果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_selected="true"&gt; &lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item&gt; &lt;shape android:shape="rectangle"&gt; &lt;solid android:color="@android:color/transparent" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left="-2dip" android:right="-2dip" android:top="-2dip"&gt; &lt;shape&gt; &lt;solid android:color="@android:color/transparent" /&gt; &lt;stroke android:width="1dip" android:color="@color/red" android:dashGap="0dp" android:dashWidth="0dip" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt; &lt;item&gt; &lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item&gt; &lt;shape android:shape="rectangle"&gt; &lt;solid android:color="@android:color/transparent" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left="-2dip" android:right="-2dip" android:top="-2dip"&gt; &lt;shape&gt; &lt;solid android:color="@android:color/transparent" /&gt; &lt;stroke android:width="1dip" android:color="@color/colorPrimary" android:dashGap="0dp" android:dashWidth="0dip" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt;&lt;/selector&gt; 3.2 焦点改变时改变背景123456789101112etInput.setOnFocusChangeListener(new OnFocusChangeListener() &#123; @Override public void onFocusChange(View v, boolean hasFocus) &#123; String trim = etInput.getText().toString().trim(); // 没有焦点&amp;&amp;有文字 if (!hasFocus &amp;&amp; trim.length() &gt; 0) &#123; etInput.setSelected(true); &#125; else &#123; etInput.setSelected(false); &#125; &#125; &#125;); 4. 带图片的Hint如下图所示，实现带有图片的hint，使用 SpannableString实现 ，但是开始的效果不是很理想，图片不能很好的居中，使用重写ImageSpan的方法解决了这个问题 4.1 图片垂直居中的span1234567891011121314151617181920212223242526272829303132333435class VerticalCenterImageSpan extends ImageSpan &#123; VerticalCenterImageSpan(Drawable drawable) &#123; super(drawable); &#125; public int getSize(Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fontMetricsInt) &#123; Drawable drawable = getDrawable(); Rect rect = drawable.getBounds(); if (fontMetricsInt != null) &#123; Paint.FontMetricsInt fmPaint = paint.getFontMetricsInt(); int fontHeight = fmPaint.bottom - fmPaint.top;// 计算文字的高度 int drHeight = rect.bottom - rect.top;// 计算图片的高度 int top = drHeight / 2 - fontHeight / 4; int bottom = drHeight / 2 + fontHeight / 4; fontMetricsInt.ascent = -bottom; fontMetricsInt.top = -bottom; fontMetricsInt.bottom = top; fontMetricsInt.descent = top; &#125; return rect.right; &#125; @Override public void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom, Paint paint) &#123; Drawable drawable = getDrawable(); canvas.save(); int transY; transY = ((bottom - top) - drawable.getBounds().bottom) / 2 + top; canvas.translate(x, transY); drawable.draw(canvas); canvas.restore(); &#125; &#125; 4.2 设置hint123456789// 设置图文hint private void initEditText(EditText editText) &#123; SpannableString msp = new SpannableString("图片 写点什么吧..."); Drawable drawable = ContextCompat.getDrawable(getContext(), R.drawable.icon_hint_edit); drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight()); // 这里从start = 0开始，end = 2结束，图片取代了两个字的位置，上面的字符串中国年的图片两个字会被替代 msp.setSpan(new VerticalCenterImageSpan(drawable), 0, 2, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); editText.setHint(msp); &#125; 5 修改键盘的回车键在xml配置 12android:imeOptions="actionSearch"android:inputType="text" 或在java代码中配置 12editText.setImeOptions(EditorInfo.IME_ACTION_SEARCH);editText.setInputType(EditorInfo.TYPE_CLASS_TEXT); 实现监听，进行相关操作 12345678910editText.setOnEditorActionListener(new TextView.OnEditorActionListener() &#123; public boolean onEditorAction(TextView v, int actionId, KeyEvent event) &#123; if (actionId == EditorInfo.IME_ACTION_SEND || (event != null &amp;&amp; event.getKeyCode() == KeyEvent.KEYCODE_ENTER)) &#123; //do something; return true; &#125; return false; &#125;&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端与服务器token机制]]></title>
      <url>%2F2016%2F09%2F28%2FAndroid%E5%BC%80%E5%8F%91%2FToken%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[仿QQ相册RecyclerView滑动选中]]></title>
      <url>%2F2016%2F09%2F06%2FAndroid%E5%BC%80%E5%8F%91%2F%E4%BB%BFQQ%E7%9B%B8%E5%86%8CRecyclerView%E6%BB%91%E5%8A%A8%E9%80%89%E4%B8%AD%2F</url>
      <content type="text"><![CDATA[1. 前言 显示相册在app中是一个比较常见的操作，大致的操作就是通过ContentProvider获取多媒体资源进行展示，我综合了一下QQ 的和微信的显示效果，实现了一下,仿微信QQ显示手机相册，在QQ的相册选择时是支持滑动选中的，即手指碰到哪个就选中哪张照片，正好公司的项目中用到了这个功能，在网上找了找没有很好的解决方案，所以通过自定义控件处理事件，这篇文章主要介绍这个功能的实现。 自定义控件SlidingSelectLayout的源代码点击这里获取 2 效果演示普通模式演示视频 九宫格模式演示视频 3. 使用3.1 xml中使用12345678910&lt;com.march.slidingselect.SlidingSelectLayout android:id="@+id/scl" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recyclerview" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; &lt;/com.march.slidingselect.SlidingSelectLayout&gt; 3.2 java代码中配置在Adapter的onBindViewHolder方法中将pos和data与view进行绑定，之所以这样做是为了可以在手指划过Item时将对应的数据和位置通过监听发送回来。 123456789private SlidingSelectLayout mScl;mScl = getView(R.id.scl);class MyAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;&#123; @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; mScl.markView(holder.itemView,position,demos.get(position)); &#125;&#125; 3.3 监听回调使用范型获得手指触摸到的位置和当前位置对应的数据进行更新adapter 1234567mScl.setOnSlidingSelectListener(new SlidingSelectLayout.OnSlidingSelectListener&lt;Demo&gt;() &#123; @Override public void onSlidingSelect(int pos, View parentView, Demo data) &#123; demos.get(pos).isChanged = !demos.get(pos).isChanged; adapter.notifyItemChanged(pos); &#125; &#125;); 4. 大体思路自定义控件将会作为RecyclerView的父控件，这样使他可以优先于RecyclerView捕捉事件 当手指竖向滑动时，父控件不作处理，RecyclerView处理事件，进行滑动。当手指横向滑动达到阈值时自定义父控件会截断事件自己进行进行处理。 根据手指的滑动MotionEvent获取x,y坐标，使用RecycelrView的findViewUnder(float x,float y) 的方法，可以直接获取制定位置的View，再使用tag从view中拿到之前使用mScl.markView()方法绑定的pos和data数据 使用该方法就不会因为动态计算距离而局限于RecyclerView的布局，九宫格模式下仍然可以很好的支持。 5. 内部处理对外封闭在处理事件获取手指滑动的位置时，需要使用RecyclerView的LayoutManager等，为了尽量对外简化使用的流程，在控件内部使用遍历子控件的方式来获取RecyclerView和GridLayoutManager的列数等参数，初始化一些值。 5.1 获取RecyclerView1234567891011121314151617181920212223242526/** * 获取RecyclerView */private void ensureTarget() &#123; if (mTargetRv != null) return; View findView = searchInViewGroup(this); if (findView == null) &#123; Logger.e(TAG, "can not find RecyclerView"); &#125; else &#123; mTargetRv = (RecyclerView) findView; &#125;&#125;private View searchInViewGroup(ViewGroup viewGroup) &#123; View rstView = null; for (int i = 0; i &lt; viewGroup.getChildCount(); i++) &#123; View childAt = viewGroup.getChildAt(i); if (childAt instanceof RecyclerView) &#123; rstView = childAt; &#125; else if (childAt instanceof ViewGroup) &#123; rstView = searchInViewGroup((ViewGroup) childAt); &#125; &#125; return rstView;&#125; 5.2 初始化参数处理LayoutManager，初始化xTouchSlop，这个值是滑动多大距离触发水平滑动，根据GridLayoutManager的列数来动态设置。 12345678910111213141516private void ensureLayoutManager() &#123; if (mTargetRv == null || itemSpanCount != INVALID_PARAM) return; RecyclerView.LayoutManager lm = mTargetRv.getLayoutManager(); if (lm == null) return; if (lm instanceof GridLayoutManager) &#123; GridLayoutManager glm = (GridLayoutManager) lm; itemSpanCount = glm.getSpanCount(); &#125; else &#123; Logger.e(TAG,"暂时不支持其他布局类型，请使用GridLayoutManager"); itemSpanCount = 4; &#125; int size = (int) (getResources().getDisplayMetrics().widthPixels / (itemSpanCount * 1.0f)); xTouchSlop = yTouchSlop = size * TOUCH_SLOP_RATE;&#125; 6. 拦截事件12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 如果RecyclerView没有获取到，不进行事件的拦截private boolean isReadyToIntercept() &#123; return mTargetRv != null &amp;&amp; mTargetRv.getAdapter() != null &amp;&amp; itemSpanCount != INVALID_PARAM;&#125;@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; if (!isEnabled()) return super.onInterceptTouchEvent(ev); // 不支持多点触摸 int pointerCount = ev.getPointerCount(); if (pointerCount &gt; 1) &#123; return super.onInterceptTouchEvent(ev); &#125; // 获取RecyclerView ensureTarget(); // 初始化参数 ensureLayoutManager(); if (!isReadyToIntercept()) return super.onInterceptTouchEvent(ev); int action = MotionEventCompat.getActionMasked(ev); switch (action) &#123; case MotionEvent.ACTION_DOWN: // init mInitialDownX = ev.getX(); mInitialDownY = ev.getY(); break; case MotionEvent.ACTION_UP: // stop isBeingSlide = false; break; case MotionEvent.ACTION_MOVE: // handle float xDiff = Math.abs(ev.getX() - mInitialDownX); float yDiff = Math.abs(ev.getY() - mInitialDownY); if (yDiff &lt; yTouchSlop &amp;&amp; xDiff &gt; xTouchSlop) &#123; isBeingSlide = true; &#125; break; &#125; return isBeingSlide;&#125; 7. 触摸事件7.1 处理Touch事件123456789101112131415161718@Overridepublic boolean onTouchEvent(MotionEvent ev) &#123; int action = MotionEventCompat.getActionMasked(ev); switch (action) &#123; case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_UP: // re init 手指抬起时重置 isBeingSlide = false; preViewPos = INVALID_PARAM; break; case MotionEvent.ACTION_MOVE: // 滑动过程中，触发监听事件 publishSlidingCheck(ev); break; &#125; return isBeingSlide;&#125; 7.2 获取数据123456789101112131415// 从View中使用getTag(int key)获取tag，也就是之前在onBindViewHolder中设置的数据// 从Tag中获取posprivate int getPos(View parentView) &#123; int pos = INVALID_PARAM; Object tag = parentView.getTag(tagPosKey); if (tag != null) pos = (int) tag; return pos; &#125; // 从tag中获取dataprivate Object getData(View parentView) &#123; return parentView.getTag(tagDataKey);&#125; 7.3 触发监听使用监听向外发布事件,将获取的pos和data通过监听发布 12345678910111213141516171819202122232425/** * 发布结果 * * @param event 事件 */private void publishSlidingCheck(MotionEvent event) &#123; float x = generateX(event.getX()); float y = generateY(event.getY()); View childViewUnder = mTargetRv.findChildViewUnder(x, y); // fast stop if (onSlidingSelectListener == null || childViewUnder == null) return; int pos = getPos(childViewUnder); Object data = getData(childViewUnder); // fast stop 当前触摸的点与上一次触摸的点相同 || 没有pos || 没有数据 if (preViewPos == pos || pos == INVALID_PARAM || data == null) return; try &#123; // 这里使用范型强制转换 onSlidingSelectListener.onSlidingSelect(pos, childViewUnder, data); preViewPos = pos; &#125; catch (ClassCastException e) &#123; Log.e("SlidingSelect", "ClassCastException:填写的范型有误，无法转换"); &#125;&#125; 8 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251package com.march.dev.widget;import android.content.Context;import android.support.v4.view.MotionEventCompat;import android.support.v7.widget.GridLayoutManager;import android.support.v7.widget.RecyclerView;import android.util.AttributeSet;import android.util.Log;import android.view.MotionEvent;import android.view.View;import android.view.ViewGroup;import android.widget.FrameLayout;import com.march.dev.R;import com.march.dev.helper.Logger;/** * Project : CommonLib * Package : com.march.lib.view * CreateAt : 2016/9/12 * Describe : 滑动选中 * * @author chendong */public class SlidingSelectLayout extends FrameLayout &#123; public static final String TAG = SlidingSelectLayout.class.getSimpleName(); private static final float TOUCH_SLOP_RATE = 0.15f;// 初始化值 private static final int INVALID_PARAM = -1; public SlidingSelectLayout(Context context) &#123; this(context, null); &#125; public SlidingSelectLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); setTagKey(R.id.sliding_pos, R.id.sliding_data); itemSpanCount = INVALID_PARAM; preViewPos = INVALID_PARAM; &#125; private RecyclerView mTargetRv;// 内部的rv private int offsetTop; private float xTouchSlop;// 横轴滑动阈值，超过阈值表示触发横轴滑动 private float yTouchSlop;// 纵轴滑动阈值，超过阈值表示触发纵轴滑动 private int itemSpanCount;// 横向的item数量 private float mInitialDownX;// down 事件初始值 private float mInitialDownY;// down 事件初始值 private boolean isBeingSlide;// 是否正在滑动 private int tagPosKey; private int tagDataKey; private int preViewPos; private OnSlidingSelectListener onSlidingSelectListener;// 滑动选中监听 @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; if (!isEnabled()) return super.onInterceptTouchEvent(ev); // 不支持多点触摸 int pointerCount = ev.getPointerCount(); if (pointerCount &gt; 1) &#123; return super.onInterceptTouchEvent(ev); &#125; // 获取RecyclerView ensureTarget(); // 初始化参数 ensureLayoutManager(); if (!isReadyToIntercept()) return super.onInterceptTouchEvent(ev); int action = MotionEventCompat.getActionMasked(ev); switch (action) &#123; case MotionEvent.ACTION_DOWN: // init mInitialDownX = ev.getX(); mInitialDownY = ev.getY(); break; case MotionEvent.ACTION_UP: // stop isBeingSlide = false; break; case MotionEvent.ACTION_MOVE: // handle float xDiff = Math.abs(ev.getX() - mInitialDownX); float yDiff = Math.abs(ev.getY() - mInitialDownY); if (yDiff &lt; yTouchSlop &amp;&amp; xDiff &gt; xTouchSlop) &#123; isBeingSlide = true; &#125; break; &#125; return isBeingSlide; &#125; private float generateX(float x) &#123; return x; &#125; private float generateY(float y) &#123; return y - offsetTop; &#125; private void setTargetRv(RecyclerView mTargetRv) &#123; this.mTargetRv = mTargetRv; &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; int action = MotionEventCompat.getActionMasked(ev); switch (action) &#123; case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_UP: // re init 手指抬起时重置 isBeingSlide = false; preViewPos = INVALID_PARAM; break; case MotionEvent.ACTION_MOVE: // 滑动过程中，触发监听事件 publishSlidingCheck(ev); break; &#125; return isBeingSlide; &#125; /** * 初始化参数 */ private void ensureLayoutManager() &#123; if (mTargetRv == null || itemSpanCount != INVALID_PARAM) return; RecyclerView.LayoutManager lm = mTargetRv.getLayoutManager(); if (lm == null) return; if (lm instanceof GridLayoutManager) &#123; GridLayoutManager glm = (GridLayoutManager) lm; itemSpanCount = glm.getSpanCount(); &#125; else &#123; Logger.e(TAG, "暂时不支持其他布局类型，请使用GridLayoutManager"); itemSpanCount = 4; &#125; int size = (int) (getResources().getDisplayMetrics().widthPixels / (itemSpanCount * 1.0f)); xTouchSlop = yTouchSlop = size * TOUCH_SLOP_RATE; &#125; /** * 发布结果 * * @param event 事件 */ private void publishSlidingCheck(MotionEvent event) &#123; float x = generateX(event.getX()); float y = generateY(event.getY()); View childViewUnder = mTargetRv.findChildViewUnder(x, y); // fast stop if (onSlidingSelectListener == null || childViewUnder == null) return; int pos = getPos(childViewUnder); Object data = getData(childViewUnder); // fast stop 当前触摸的点与上一次触摸的点相同 || 没有pos || 没有数据 if (preViewPos == pos || pos == INVALID_PARAM || data == null) return; try &#123; // 这里使用范型强制转换 onSlidingSelectListener.onSlidingSelect(pos, childViewUnder, data); preViewPos = pos; &#125; catch (ClassCastException e) &#123; Log.e("SlidingSelect", "ClassCastException:填写的范型有误，无法转换"); &#125; &#125; private void setTagKey(int tagPosKey, int tagDataKey) &#123; this.tagPosKey = tagPosKey; this.tagDataKey = tagDataKey; &#125; /** * 设置pos和data作为View的tag * @param parentView * @param pos * @param data */ public void markView(View parentView, int pos, Object data) &#123; parentView.setTag(tagPosKey, pos); parentView.setTag(tagDataKey, data); &#125; private int getPos(View parentView) &#123; int pos = INVALID_PARAM; Object tag = parentView.getTag(tagPosKey); if (tag != null) pos = (int) tag; return pos; &#125; private Object getData(View parentView) &#123; return parentView.getTag(tagDataKey); &#125; /** * 是否可以开始拦截处理事件，当recyclerView数据完全ok之后开始 * * @return 是否可以开始拦截处理事件 */ private boolean isReadyToIntercept() &#123; return mTargetRv != null &amp;&amp; mTargetRv.getAdapter() != null &amp;&amp; itemSpanCount != INVALID_PARAM; &#125; /** * 获取RecyclerView */ private void ensureTarget() &#123; if (mTargetRv != null) return; View findView = searchInViewGroup(this); if (findView == null) &#123; Logger.e(TAG, "can not find RecyclerView"); &#125; else &#123; mTargetRv = (RecyclerView) findView; &#125; &#125; private View searchInViewGroup(ViewGroup viewGroup) &#123; View rstView = null; for (int i = 0; i &lt; viewGroup.getChildCount(); i++) &#123; View childAt = viewGroup.getChildAt(i); if (childAt instanceof RecyclerView) &#123; rstView = childAt; &#125; else if (childAt instanceof ViewGroup) &#123; rstView = searchInViewGroup((ViewGroup) childAt); &#125; &#125; return rstView; &#125; public void setOffsetTop(int offsetTop) &#123; this.offsetTop = offsetTop; &#125; public &lt;D&gt; void setOnSlidingSelectListener(OnSlidingSelectListener&lt;D&gt; onSlidingCheckListener) &#123; this.onSlidingSelectListener = onSlidingCheckListener; &#125; public interface OnSlidingSelectListener&lt;D&gt; &#123; void onSlidingSelect(int pos, View parentView, D data); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NestedScrolling交互]]></title>
      <url>%2F2016%2F08%2F25%2FAndroid%E5%BC%80%E5%8F%91%2FNestedScrolling%E6%9C%BA%E5%88%B6_%E4%BA%A4%E4%BA%92%2F</url>
      <content type="text"><![CDATA[前言交互 触发时机 NestedScrollChild NestedScrollParent Down startNestScroll onStartNestScroll onNestScrollAccept Move dispatchNestPreScroll onNestPreScroll dispatchNestScroll onNestScroll Up stopNest]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android事件交互]]></title>
      <url>%2F2016%2F08%2F25%2FAndroid%E5%BC%80%E5%8F%91%2FAndroid%E4%BA%8B%E4%BB%B6%E4%BA%A4%E4%BA%92%2F</url>
      <content type="text"><![CDATA[前言 Android事件交互,当用户手指触碰屏幕时会触发onTouchEvent(MotionEven event)方法。 推荐阅读简书－MotionEvent详解 常用事件1234567MotionEvent.ACTION_DOWN: 0MotionEvent.ACTION_UP: 1MotionEvent.ACTION_MOVE: 2MotionEvent.ACTION_CANCEL: 3MotionEvent.ACTION_OUTSIDE: 4MotionEvent.ACTION_POINTER_DOWN: 5MotionEvent.ACTION_POINTER_UP: 6 获取事件 event.getAction()和event.getActionMasked()和MotionEventCompat.getActionMasked(event)都可以获取事件类型。带有Mask标志的方法是针对多点触控的情况拿到的掩码。多点触控时，获取Action会返回每个触摸点的事件，其中使用pointerIndex区分每个触摸点。 为了能表示每个pointerIndex对应的事件，以及更方便转化，每个获取的action实际上是pointerIndex和event拼接成的16进制表示，比如第二个点的Move事件，返回的值是0x0100,01表示pointerIndex,00表示Down事件，所以返回的action的值为256. 单点触摸时只有一个pointerIndex = 0,所以获取的到的action实际上是0x0000(Down事件)，0x0001(UP事件)。。。所以结果和事件的值是一样的。 当多点触摸时，第一个点的Down事件0x0000,第二个点的Down事件0x0100,此时简单的getAction()方法并不能获取正确的事件值。 getActionMasked()方法是将getAction()的值与ACTION_MASK做‘与’运算，例如当有一个事件是0x0102,获取掩码时可以过滤掉pointerIndex的值获取event的值，event.getActionMasked()原理大致相同。 描述 值 getAction()十六进制表示 0x0101 ACTION_MASK十六进制表示 0x00ff getAction()二进制表示 000001 000001 ACTION_MASK二进制表示 000000 011111 getActionMasked()二进制表示 000000 000001 getActionMasked()十六进制表示 0x0001(Move事件) 1234public static final int ACTION_MASK = 0xff;public static int getActionMasked(MotionEvent event) &#123; return event.getAction() &amp; ACTION_MASK;&#125; MotionEventCompat.getActionMasked()是对版本兼容的方法。推荐使用这个类进行相关操作达到兼容版本的目的。 Pointer pointer , pointerIndex , event , action , poiterId pointer代表一个触摸点 pointerIndex是pointer在MotionEvent中的索引 event代表事件，比如0(Down),1(UP)… action是pointerIndex和event拼接的十六进制形式 pointerId是一个pointer的唯一标示，他在整个事件流中是不会改变的，但是pointerIndex的值会改变，比如，先后放置三个指头在屏幕上会接收到0x0000(第一个指头Down事件),0x0105(第二个指头Pointer_Down事件),0x0205(第三个指头Pointer_Down事件),抬起第二个指头时会触发0x0106(Pointer_Up),再抬起第三个指头也会触发0x0106(Pointer_Up),也就是说抬起第二个指头之后第三个指头的index由02变成了01,所以index只是MotionEvnet中每个事件的下标，与事件不能形成标志性的关系。 MotionEventCompat MotionEventCompat是一个针对事件处理提供的辅助类，内部做了版本兼容。 getActionIndex(MotionEvent event)获取该事件的索引，有点类似于MotionEventCompat.getActionMasked(),都使用‘与’运算，只不过一个取的是高位的pointerIndex,后者取得是低位的event事件。 1234public static int getActionIndex(MotionEvent event) &#123; return (event.getAction() &amp; ACTION_POINTER_INDEX_MASK) &gt;&gt; ACTION_POINTER_INDEX_SHIFT; &#125; getPointerId(MotionEvent event, int pointerIndex)在一个MotionEvent中根据触摸点pointerIndex的值获取pointerId 123public static int getPointerId(MotionEvent event, int pointerIndex) &#123; return IMPL.getPointerId(event, pointerIndex);&#125; findPointerIndex(MotionEvent event, int pointerId)在一个MotionEvent中根据pointerId获取pointerIndex 123public static int findPointerIndex(MotionEvent event, int pointerId) &#123; return IMPL.findPointerIndex(event, pointerId);&#125; 从一个MotionEvent中根据pointerIndex获取对应触摸点的XY坐标 123456public static float getX(MotionEvent event, int pointerIndex) &#123; return IMPL.getX(event, pointerIndex);&#125;public static float getY(MotionEvent event, int pointerIndex) &#123; return IMPL.getY(event, pointerIndex);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[分析SwipeRefreshLayout实现自定义刷新]]></title>
      <url>%2F2016%2F08%2F25%2FAndroid%E5%BC%80%E5%8F%91%2FSwipeRefreshLayout%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[前言 分析SwipeRefreshLayout的源代码来深入的理解一下关于刷新的事件处理和NestedScrolling机制的使用。Android5.0之后官方推出了SwipeRefreshLayout来实现下拉刷新，当然还有很多其他控件，因为像下拉刷新，抽屉效果，tabLayout效果几乎是每个App都需要的，在之前的版本中Android没有定义这些控件，因此GitHub上也涌现了大量的自定控件的库，大家可以很方便的引用这些库实现效果，比如很火的pull-to-refresh以及后来的ultra-pull-to-refresh。Android在推出SwipeRefreshLayout之后并没有在国内得到很好的使用，大家还是在用自己的刷新和开源库来实现。可能是因为： SwipeRefreshLayout的效果跟以前的刷新效果有些出入，大家接受了以前的效果对新的效果不太满意。 SwipeRefreshLayout自定义度不强，每个App都想有自己的特色，自然不愿意采用大众的做法。 这篇文章的目的就是，理解SwipeRefreshLayout 的实现，基于SwipeRefreshLayout实现类似传统的刷新效果并支持自定义。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NestedScrollingParent分析]]></title>
      <url>%2F2016%2F08%2F22%2FAndroid%E5%BC%80%E5%8F%91%2FNestedScrolling%E6%9C%BA%E5%88%B6_NestedScrollingParent%2F</url>
      <content type="text"><![CDATA[前言 对NestedScrollingParent接口进行分析，主要是文档的翻译和一些理解，以及每个方法触发的时机。 NestedScrollingParent接口 This interface should be implemented by {@link android.view.ViewGroup ViewGroup} subclassesthat wish to support scrolling operations delegated by a nested child view. 翻译：这个接口被ViewGroup的子类实现来支持处理nest子视图的滑动操作。 Classes implementing this interface should create a final instance of a {@link NestedScrollingParentHelper} as a field and delegate any View or ViewGroup methodsto the NestedScrollingParentHelper methods of the same signature. 翻译：实现这个接口的类应该创建一个final类型的NestedScrollingParentHelper实例作为一个属性，来代理NestedScrollingParent中与NestedScrollingParentHelper具有相同方法名字的操作。 Views invoking nested scrolling functionality should always do so from the relevant {@link ViewCompat}, {@link ViewGroupCompat} or {@link ViewParentCompat} compatibility shim static methods. This ensures interoperability with nested scrolling views on Android 5.0 Lollipop and newer. 翻译：View调用嵌套滑动的相关功能时应该从相关的ViewCompat，ViewGroupCompat，ViewParentCompat调用兼容的静态方法，这保证了在5.0或者更新版本中与嵌套滑动的互用性。 onStartNestedScroll方法1public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes); 参数和返回值 12345678//ViewParent包涵的直接的子View@param child Direct child of this ViewParent containing target //启动嵌套滑动操作的View@param target View that initiated the nested scroll //flag垂直滑动还是水平滑动@param nestedScrollAxes Flags consisting of &#123;@link ViewCompat#SCROLL_AXIS_HORIZONTAL&#125;, &#123;@link ViewCompat#SCROLL_AXIS_VERTICAL&#125; or both //如果返回true代表父View接受消耗这个滑动操作。@return true if this ViewParent accepts the nested scroll operation React to a descendant view initiating a nestable scroll operation, claiming the nested scroll operation if appropriate. 翻译：对一个派生View的嵌套滑动操作作出反应，如果需要的话将会拦截（消耗）这个滑动操作。 This method will be called in response to a descendant view invoking ink ViewCompat#startNestedScroll(View, int)}. Each parent up the view hierarchy will be given an opportunity to respond and claim the nested scrolling operation by returning true. 翻译：这个方法将会被作为派生View调用ViewCompat.startNestedScroll(View, int)时的回复响应，每个上层的父视图如果这个方法返回true,都将有机会响应和拦截（消耗）这个嵌套滑动操作. onNestedScrollAccepted方法1public void onNestedScrollAccepted(View child, View target, int nestedScrollAxes); React to the successful claiming of a nested scroll operation. 翻译：对嵌套滑动操作的成功声明作出响应， This method will be called after {@link #onStartNestedScroll(View, View, int) onStartNestedScroll} returns true. It offers an opportunity for the view and its superclasses to perform initial configuration for the nested scroll. Implementations of this method should always call their superclass’s implementation of this method if one is present. 翻译：这个方法将会在 onStartNestedScroll方法返回true时被调用。这个方法提供给View和他的父类一个对嵌套滑动操作进行初始化配置的机会。如果父类对该方法有操作，实现此方法应该调用父类的实现。 onStopNestedScroll方法1public void onStopNestedScroll(View target); 参数和返回值 12//触发嵌套滑动的View@param target View that initiated the nested scroll React to a nested scroll operation ending. 翻译：对嵌套滑动结束做出响应 Perform cleanup after a nested scrolling operation.This method will be called when a nested scroll stops, for example when a nested touch scroll ends with a {@link MotionEvent#ACTION_UP} or {@link MotionEvent#ACTION_CANCEL} event. Implementations of this method should always call their superclass’s implementation of this method if one is present. 翻译：确认在嵌套滑动操作结束之后的清理操作，比如一些参数的重新初始化，这个方法将会在嵌套滑动操作结束后调用，比如嵌套滑动操作因为ACTION_UP，ACTION_CANCEL事件被终止。如果父类对该方法有操作，实现此方法应该调用父类的实现。 onNestedScroll方法1public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed); 参数和返回值 12345678910// 控制嵌套滑动的子View@param target The descendent view controlling the nested scroll// 子View水平滑动消耗的距离@param dxConsumed Horizontal scroll distance in pixels already consumed by target// 子View垂直滑动消耗的距离@param dyConsumed Vertical scroll distance in pixels already consumed by target// 子View水平滑动没有消耗的距离@param dxUnconsumed Horizontal scroll distance in pixels not consumed by target// 子View水平滑动没有消耗的距离@param dyUnconsumed Vertical scroll distance in pixels not consumed by target React to a nested scroll in progress. 翻译：对滑动过程作出响应 This method will be called when the ViewParent’s current nested scrolling child view dispatches a nested scroll event. To receive calls to this method the ViewParent must have previously returned true for a call to {@link #onStartNestedScroll(View, View, int)}. 翻译：这个方法将会在ViewParent中当前正在嵌套滑动的子View分发嵌套滑动事件时被调用。为了能够接受到调用这个方法，ViewParent必须事先在onStartNestedScroll返回true。 Both the consumed and unconsumed portions of the scroll distance are reported to the ViewParent. An implementation may choose to use the consumed portion to match or chase scroll position of multiple child elements, for example. The unconsumed portion may be used to allow continuous dragging of multiple scrolling or draggable elements, such as scrolling a list within a vertical drawer where the drawer begins dragging once the edge of inner scrolling content is reached. 翻译：消耗部分和没有消耗部分的嵌套滑动的距离都被上报给ViewParent。一个实现可以选择使用消耗的部分来匹配或追逐多个子元素的滚动位置，例如。未使用的部分可以用来允许连续滚动或拖动拖动多元素，如在一个垂直的抽屉内滚动一个列表，抽屉开始拖动滚动达到内容的边缘。 onNestedPreScroll方法1public void onNestedPreScroll(View target, int dx, int dy, int[] consumed); 参数和返回值 12345678// 发起嵌套滑动的子View@param target View that initiated the nested scroll// 水平滑动的距离@param dx Horizontal scroll distance in pixels// 垂直滑动的距离@param dy Vertical scroll distance in pixels// 输出,水平滑动和垂直滑动被父View消耗的距离@param consumed Output. The horizontal and vertical scroll distance consumed by this parent React to a nested scroll in progress before the target view consumes a portion of the scroll. 滑动过程中在发起嵌套滑动的子View消耗滑动距离之前作出反应 When working with nested scrolling often the parent view may want an opportunity to consume the scroll before the nested scrolling child does. An example of this is a drawer that contains a scrollable list. The user will want to be able to scroll the list fully into view before the list itself begins scrolling. 在进行嵌套滑动时，通常父View希望获得机会在子View之前消耗滑动距离。例如，抽屉里面包含一个可以滑动的list,用户将希望能够在列表本身开始滚动之前将列表完全滚动到视图中。 onNestedPreScroll is called when a nested scrolling child invokes {@link View#dispatchNestedPreScroll(int, int, int[], int[])}. The implementation should report how any pixels of the scroll reported by dx, dy were consumed in the consumed array. Index 0 corresponds to dx and index 1 corresponds to dy. This parameter will never be null. Initial values for consumed[0] and consumed[1] will always be 0. onNestedPreScroll 方法在子View调用dispatchNestedPreScroll方法时被调用。这个方法的实现应该报告对dx和dy进行了多少消耗。consumed[0]代表消耗的dx,consumed[1]代表消耗的dy,这个参数不会为空，consumed[0]和consumed[1]初始值为0。 onNestedFling方法1public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed); 参数和返回值 12345678910// 发起嵌套滑动的子View@param target View that initiated the nested scroll// 横向滑动的速度@param velocityX Horizontal velocity in pixels per second// 竖向滑动的速度@param velocityY Vertical velocity in pixels per second// 如果是true表示这个子View消耗了这个滑动@param consumed true if the child consumed the fling, false otherwise// 返回true表示，父View消耗滑动或其他情况@return true if this parent consumed or otherwise reacted to the fling Request a fling from a nested scroll. 需要嵌套滑动发生fling事件 This method signifies that a nested scrolling child has detected suitable conditions for a fling. Generally this means that a touch scroll has ended with a {@link VelocityTracker velocity} in the direction of scrolling that meets or exceeds the {@link ViewConfiguration#getScaledMinimumFlingVelocity() minimum fling velocity} along a scrollable axis. 这个方法意味着嵌套滑动的子View监测到一个适合fling的情况。通常意味着触摸事件在一个可滑动的轴上在一个方向上以一定速度结束，这个速度超过了ViewConfiguration#getScaledMinimumFlingVelocity()的值。 If a nested scrolling child view would normally fling but it is at the edge of its own content, it can use this method to delegate the fling to its nested scrolling parent instead. The parent may optionally consume the fling or observe a child fling. 如果一个子View在嵌套滑动但是到达了他的内容边缘，它可以使用这个方法将处理fling事件代理给父View,父View可以选择性的消耗fling事件或者观察子View的fling事件。 onNestedPreFling方法1public boolean onNestedPreFling(View target, float velocityX, float velocityY); 参数和返回值 12345678// 触发嵌套滑动的子View@param target View that initiated the nested scroll// 水平方向滑动速度@param velocityX Horizontal velocity in pixels per second// 垂直方向滑动速度@param velocityY Vertical velocity in pixels per second// 如果父View要处理这个fling事件返回true@return true if this parent consumed the fling ahead of the target view React to a nested fling before the target view consumes it. 在子View对嵌套fling事件消耗之前作出响应 This method siginfies that a nested scrolling child has detected a fling with the given velocity along each axis. Generally this means that a touch scroll has ended with a {@link VelocityTracker velocity} in the direction of scrolling that meets or exceeds the {@link ViewConfiguration#getScaledMinimumFlingVelocity() minimum fling velocity} along a scrollable axis. 这个方法意味着嵌套滑动的子View在每个轴上给定的速度上发生了fling事件，通常意味着触摸事件在一个可滑动的轴上在一个方向上以一定速度结束，这个速度超过了ViewConfiguration#getScaledMinimumFlingVelocity()的值。 If a nested scrolling parent is consuming motion as part of a {@link #onNestedPreScroll(View, int, int, int[]) pre-scroll}, it may be appropriate for it to also consume the pre-fling to complete that same motion. By returning true from this method, the parent indicates that the child should not fling its own internal content as well. 如果父View在onNestedPreScroll方法中消耗了嵌套滑动，那么他可能同样也想在fling事件中进行消耗操作，来完成处理嵌套滑动的请求。这个方法返回true表明子View应该只在它自己的区域内滑动。 getNestedScrollAxes()方法1public int getNestedScrollAxes(); 参数和返回值 12345// 表明滑动轴方向的flag@return Flags indicating the current axes of nested scrolling@see ViewCompat#SCROLL_AXIS_HORIZONTAL@see ViewCompat#SCROLL_AXIS_VERTICAL@see ViewCompat#SCROLL_AXIS_NONE A NestedScrollingParent returning something other than {@link ViewCompat#SCROLL_AXIS_NONE}］is currently acting as a nested scrolling parent for one or more descendant views in the hierarchy. 如果没有返回ViewCompat#SCROLL_AXIS_NONE，表明有子View在进行嵌套滑动。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 6.0权限动态申请]]></title>
      <url>%2F2016%2F08%2F16%2FAndroid%E5%BC%80%E5%8F%91%2FAndroidM%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7%2F</url>
      <content type="text"><![CDATA[minSdkVersion minSdkVersion指的是你的应用可以兼容到的最低版本，比如你只使用了2.X的API，那minSdkVersion就可以尽量小，以适配更多机型，小于minSdkVersion的机型将无法安装。 maxSdkVersion maxSdkVersion指的是你的应用可以支持到的最高版本，高于这个版本的机型将不能安装应用，但是这个不需要我们自己去写，Android系统默认向下兼容的。 targetSdkVersion targetSdkVersion如果设置了此属性，那么在程序执行时，如果目标设备的API版本正好等于此数值，他会告诉Android平台：此程序在此版本已经经过充分测，没有问题。不必为此程序开启兼容性检查判断的工作了。 介绍 由于Android M对隐私权限必须动态申请，当你的targetSdkVersion&gt;=23时就需要进行权限申请了，否则将获得不了权限。不过当targetSdkVersion&lt;23时，由于Android版本向下兼容性，你的应用将运行在&lt;23的环境中，不会出现问题。 Git上已经有很多开源库供大家使用了，确实方便简单，PermissionGen这个库好评率还是蛮高的，使用注解简化了很多操作，网上很多博客都推荐它，不过，我觉得不能遇到啥问题就引个别人的库进来， 一方面如果库的定制性不高，自定义起来也是麻烦，另一方面，像这种比较简单的问题，还是自己写比较好，可以了解一下是如何实现的，对自己的学习也有好处。别人封装的再好也不是自己的，以后只能说我会使用XX,XXX…类库.那就尴尬了。扯远了～ Android权限 Android M之后将权限分为了两类，Normal和Dangerous Permission,Dangerous Permission大都是跟用户隐私相关的权限，如下表，更详细见Android文档－Permissions Permission Group Permissions CALENDAR READ _ CALENDAR WRITE _ CALENDAR CAMERA CAMERA CONTACTS READ _ CONTACTS WRITE _ CONTACTS GET _ ACCOUNTS LOCATION ACCESS FINE LOCATION ACCESS COARSE LOCATION MICROPHONE RECORD _ AUDIO PHONE READ PHONE STATE CALL _ PHONE READ CALL LOG WRITE CALL LOG ADD _ VOICEMAIL USE _ SIP PROCESS OUTGOING CALLS SENSORS BODY _ SENSORS SMS SEND _ SMS RECEIVE _ SMS READ _ SMS RECEIVE WAP PUSH RECEIVE _ MMS STORAGE READ EXTERNAL STORAGE WRITE EXTERNAL STORAGE 思路和API 涉及到的核心方法context.requestPermissions(String[] permissions,int reqCode);该方法必须在Android M以上可以使用。大体的思路就是： 当前手机版本是不是大于Android M ？ 是否有私有权限需要申请？ 该权限是不是已经同意了 弹个dialog告诉用户我们将要申请哪些权限，现在市面上app大都是这么做的 开始申请 处理申请结果 PermissionHelper 为了方便操作，我将部分核心方法抽象出来了，调用checkPermission()申请权限，返回值会告诉你是不是需要申请，调用onRequestPermissionsResult()会格式化处理返回的数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * com.march.baselib.helper * CommonLib * Created by chendong on 16/8/17. * Copyright © 2016年 chendong. All rights reserved. * Desc : */public class PermissionHelper &#123; public static final int REQ_PERMISSION_CODE = 0x12; /** * 动态申请权限 * @param context 上下文 * @param permissions 需要申请的权限 * @return 是不是需要申请 */ public static boolean checkPermission(Activity context, String[] permissions) &#123; //6.0以上 if (AppHelper.isOverMarshmallow()) &#123; //没有权限需要申请时 if (permissions == null || permissions.length &lt;= 0) return true; //检查权限是不是已经授予 List&lt;String&gt; noOkPermissions = new ArrayList&lt;&gt;(); for (String permission : permissions) &#123; if (context.checkSelfPermission(permission) == PackageManager.PERMISSION_DENIED) &#123; noOkPermissions.add(permission); &#125; &#125; //该权限已经授予，不再申请 if (noOkPermissions.size() &lt;= 0) return true; //6.0以上需要申请权限 context.requestPermissions(noOkPermissions.toArray(new String[noOkPermissions.size()]), REQ_PERMISSION_CODE); return false; &#125; //6.0以下下不需要申请 return true; &#125; /** * 处理权限申请的结果，返回结构化的数据 * @param requestCode 请求码 * @param permissions 被请求的权限 * @param grantResults 请求结果 * @param listener 监听 */ public static void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults, OnPermissionHandleOverListener listener) &#123; if (requestCode != REQ_PERMISSION_CODE) return; Map&lt;String, Integer&gt; result = new HashMap&lt;&gt;(); boolean isHavePermissionNotOk = false; for (int i = 0; i &lt; Math.min(permissions.length, grantResults.length); i++) &#123; result.put(permissions[i], grantResults[i]); //有权限没有同意 if (grantResults[i] == PackageManager.PERMISSION_DENIED) &#123; isHavePermissionNotOk = true; &#125; &#125; //如果权限全部同意，继续执行 if (listener != null) listener.onHandleOver(!isHavePermissionNotOk, result); &#125; public interface OnPermissionHandleOverListener &#123; void onHandleOver(boolean isOkExactly, Map&lt;String, Integer&gt; result); &#125;&#125; BaseActivity 一般权限监测是在Activity进行，在基类中监测要简单方便 1234567891011121314151617181920212223242526272829303132333435@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mSaveBundle = savedInstanceState; mActivity = this; mContext = getApplicationContext(); createViewShow(); //如果不需要监测，会立刻执行invokeCommonMethod()开始Activity操作，如果需要就会发起申请 if (PermissionHelper.checkPermission(mActivity, getPermission2Check())) invokeCommonMethod(mSaveBundle); &#125; //抽象方法，由子类来决定哪些权限需要申请protected abstract String[] getPermission2Check();//子类实现决定处理结果protected boolean handlePermissionResult(Map&lt;String, Integer&gt; resultNotOk) &#123; return true;&#125;//处理返回结果@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); PermissionHelper.onRequestPermissionsResult(requestCode, permissions, grantResults, new PermissionHelper.OnPermissionHandleOverListener() &#123; @Override public void onHandleOver(boolean isOkExactly, Map&lt;String, Integer&gt; result) &#123; //权限ok或者子类要求直接执行 if (isOkExactly || handlePermissionResult(result)) invokeCommonMethod(mSaveBundle); &#125; &#125;); &#125; 子类12345678910111213141516//哪些权限需要申请@TargetApi(Build.VERSION_CODES.JELLY_BEAN)@Overrideprotected String[] getPermission2Check() &#123; return new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;;&#125;//如果权限没有获得如何处理@Overrideprotected boolean handlePermissionResult(Map&lt;String, Integer&gt; resultNoOk) &#123; if (resultNoOk.get(Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_DENIED) &#123; Toaster.get().show("您没有允许读取存储卡，不能继续操作"); return false; &#125; return true;&#125; 以上]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python实现单例]]></title>
      <url>%2F2016%2F08%2F11%2F%E5%AD%A6%E4%B9%A0%2Fpython%E5%8D%95%E4%BE%8B%2F</url>
      <content type="text"><![CDATA[单例装饰器 在网上查到很多方式，选择一种比较pythonic的方式 123456789def singleton(cls, *args, **kwargs): instances = &#123;&#125; def _singleton(): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return _singleton 使用12345678@singletonclass HttpHelper: def __init__(self): pass name = 'http helper' ...... ....]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python Json相关]]></title>
      <url>%2F2016%2F08%2F11%2F%E5%AD%A6%E4%B9%A0%2Fpython%E4%BD%BF%E7%94%A8json%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[开始12345678910111213141516171819202122232425# -*-coding:utf-8-*-import jsonfrom httptst.Singleton import singleton@singletonclass JsonHelper(object): name = 'json helper' def convert_to_builtin_type(obj): print 'default(', repr(obj), ')' dict = &#123;&#125; dict.update(obj.__dict__) return dict # obj 转 json def getJson(self, obj): data = json.dumps(obj, sort_keys=True, default=self.convert_to_builtin_type) return data # json str 转dict def parse(self, jsonStr): jsonDict = json.loads(jsonStr) return jsonDict]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python普通方法、静态方法、类方法]]></title>
      <url>%2F2016%2F08%2F11%2F%E5%AD%A6%E4%B9%A0%2Fpython%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E7%B1%BB%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[开始123456789101112131415161718192021222324# -*-coding:utf-8-*-# 普通方法,类方法,静态方法的区别__metaclass__ = typeclass Tst: name = 'tst' data = 'this is data' # 普通方法 def normalMethod(self, name): print self.data, name # 类方法,可以访问类属性 @classmethod def classMethod(cls, name): print cls.data, name # 静态方法,不可以访问类属性 @staticmethod def staticMethod(name): print name 测试 三种方法都可以通过实例来调用，但是静态方法和类方法无法访问实例属性，所以更改了tst.data仅对普通方法起了作用 12345678910tst = Tst()tst.data = 'this is new'tst.normalMethod('name')tst.staticMethod('name')tst.classMethod('name')#结果this is new namenamethis is data name 区别 普通方法不能通过类名调用，但是静态方法和类方法是可以的 12345678# error普通方法必须通过实例调用# Tst.normalMethod(&apos;name&apos;)Tst.classMethod(&apos;name&apos;)Tst.staticMethod(&apos;name&apos;)#结果this is data namename 总结 普通方法,可以通过self访问实例属性 1def normalMethod(self,data) 类方法,可以通过cls访问类属性 12@classmethoddef classMethod(cls,data) 静态方法,不可以访问,通过传值的方式 12@staticmethoddef staticMethod(data)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[QuickRvAdapter快速适配器]]></title>
      <url>%2F2016%2F08%2F05%2FAndroid%E5%BC%80%E5%8F%91%2FAdapter%E5%B0%81%E8%A3%85-RecyclerView2%2F</url>
      <content type="text"><![CDATA[RecyclerView Adapter 为RecyclerView提供更简单的适配器实现方式，不断更新完善中。 Demo视频演示 GitHub地址 博客 使用 BaseViewHolder 的使用 通用适配器 单类型数据适配 多类型数据适配 使用 ISectionRule 配置数据 使用 HashMap 配置数据 九宫格模式适配 监听事件 三种事件 实现需要的事件 SectionRvAdapter 事件 数据更新 内置更新方法 分页更新方法 SectionRvAdapter 追加更新 Module 添加 Header 和 Footer 预加载更多 其他 adapterId 区分 Sample 使用 类库还在开发中，暂时没有发布到Jcenter,所以需要在yourProject.gradle文件中添加如下代码进行依赖 12345allprojects &#123; repositories &#123; maven &#123; url &apos;https://dl.bintray.com/chendongmarch/maven&apos; &#125; &#125;&#125; 在yourApp.gradle文件中添加依赖 1compile &apos;com.march.lib-adapter:lib-adapter:1.0.0&apos; BaseViewHolder 的使用 通用ViewHolder，内部使用SparseArray实现View的缓存。 12345678910111213//BaseViewHolder//获取控件public &lt;T extends View&gt; T getView(int resId)public &lt;T extends View&gt; T getView(String resId)//设置可见public RvViewHolder setVisibility(int resId, int v)//文字public RvViewHolder setText(int resId, String txt)//图片public RvViewHolder setImg(int resId, int imgResId)//监听public RvViewHolder setClickLis(int resId, View.OnClickListener listener) 通用适配器单类型数据适配 SimpleRvAdapter 12345678//一个简单的实现,实体类不需要再去实现RvQuickInterface接口SimpleRvAdapter simpleAdapter =new SimpleRvAdapter&lt;Demo&gt;(self, demos, R.layout.rvquick_item_a) &#123; @Override public void onBindView(RvViewHolder holder, Demo data, int pos) &#123; holder.setText(R.id.item_a_tv, data.title); &#125; &#125;; 多类型数据适配 TypeRvAdapter 多类型数据适配时需要接受ITypeAdapterModel(接口)类型的的数据，因此进行多类型数据适配时，你的Model需要实现ITypeAdapterModel告知Adapter数据的type addType(int type,int res)方法用来给每种类型的数据添加不同的布局文件，达到多类型适配的目的。 12345678910111213141516171819// Demo类必须实现 ITypeAdapterModel 接口TypeRvAdapter&lt;Demo&gt; typeAdapter =new TypeRvAdapter&lt;Demo&gt;(context, data) &#123; @Override public void onBindView(RvViewHolder holder, Demo data, int pos, int type) &#123; //根据类型绑定数据 switch (type) &#123; case Demo.CODE_DETAIL: holder.setText(R.id.item_quickadapter_type_title, data.getmDemoTitle()).setText(R.id.item_quickadapter_desc, data.getmDescStr()); break; case Demo.JUST_TEST: holder.setText(R.id.item_quickadapter_title, data.getmDemoTitle()); break; &#125; &#125; &#125;;typeAdapter.addType(Demo.CODE_DETAIL, R.layout.item_layout_a) .addType(Demo.JUST_TEST, R.layout.item_layout_b); 九宫格模式适配 SectionRvAdapter 每个Header下面由多个item。类似微信九宫格照片展示,SectionRvAdapter实际上是多类型适配(TypeRvAdapter)的一种特殊形式，内置了SectionHeader类型的数据，用来更简单的实现九宫格模式的数据适配，因为多类型数据适配的特点他都可以使用，也就是说你可以定义多种类型的数据展示。 作为ItemHeader的数据类型需要继承AbsSectionHeader(抽象类) 123class ItemHeader extends AbsSectionHeader &#123; String itemHeaderTitle;&#125; 作为每个Section内容的数据类型，如果他是单类型的不需要做其他操作，如果有多种类型的内容需要实现ITypeAdapterModel，详细参照多类型数据适配多类型数据适配 1234class Content &#123; int contentIndex String contentTitle;&#125; 使用 ISectionRule 配置数据 ISectionRule接口,进行九宫格模式适配使用 ISectionRule 配置数据时，需要添加ISectionRule,这是一种规则，adapter会根据你提供的规则自动生成Header 提供了两种构造方法 123456// 直接配置 item header 和 content 的 layout 资源public SectionRvAdapter(Context context,List&lt;ID&gt; originDatas, int headerLayoutId, int contentLayoutId)// 只添加 header 的 layout 资源，content的资源可以使用addType方法添加 public SectionRvAdapter(Context context, List&lt;ID&gt; originDatas, int headerLayoutId) 123456789101112131415161718192021222324252627282930313233// ItemHeader表示header的数据类型，Content表示内部数据的数据类型// 初始化，添加header 和 content的布局文件adapter = new SectionRvAdapter&lt;ItemHeader, Content&gt;( this, contents, R.layout.item_header_header, R.layout.item_header_content) &#123; @Override protected void onBindItemHeader(BaseViewHolder holder, ItemHeader data, int pos, int type) &#123; holder.setText(R.id.info1, data.getItemHeaderTitle()); &#125; @Override protected void onBindContent(BaseViewHolder holder, Content data, int pos, int type) &#123; holder.setText(R.id.tv, String.valueOf(data.contentIndex)); &#125; &#125;; // 添加ISectionRule adapter.addItemHeaderRule(new ISectionRule&lt;ItemHeader, Content&gt;() &#123; @Override public ItemHeader buildItemHeader(int currentPos, Content preData, Content currentData, Content nextData) &#123; // 生成header数据 return new ItemHeader("create new header " + currentData.contentIndex); &#125; @Override public boolean isNeedItemHeader(int currentPos, Content preData, Content currentData, Content nextData) &#123; // 什么时候创建header(当是第一个数据或者index是7的倍数时，插入一个header) return currentPos == 0 || currentData.contentIndex % 7 == 1; &#125; &#125;);mRv.setAdapter(adapter); 使用 HashMap 配置数据 一个 ItemHeader 下有多个 Content，类似Map&lt;ItemHeader,Content&gt;的数据结构,可以选择在外面构造好数据来进行数据适配 HashMap是无序的，为了保证数据的有序性，使用LinkedHashMap 同样的也提供了两种构造方法 123456789// 直接配置 item header 和 content 的 layout 资源public SectionRvAdapter(Context context, LinkedHashMap&lt;IH, List&lt;ID&gt;&gt; originDatas, int headerLayoutId, int contentLayoutId)// 只添加 header 的 layout 资源，content的资源可以使用addType方法添加 public SectionRvAdapter(Context context, LinkedHashMap&lt;IH, List&lt;ID&gt;&gt; originDatas, int headerLayoutId) 1234567891011121314final LinkedHashMap&lt;ItemHeader, List&lt;Content&gt;&gt; map = new LinkedHashMap&lt;&gt;();adapter = new SectionRvAdapter&lt;ItemHeader, Content&gt;(this, map, R.layout.item_header_header, R.layout.item_header_content) &#123; @Override protected void onBindItemHeader(BaseViewHolder holder, ItemHeader data, int pos, int type) &#123; holder.setText(R.id.info1, data.getItemHeaderTitle()); &#125; @Override protected void onBindContent(BaseViewHolder holder, Content data, int pos, int type) &#123; TextView tv = (TextView) holder.getView(R.id.tv); &#125; &#125;; 监听事件支持单击、双击和长按事件 三种事件12345678public interface OnItemListener&lt;D&gt; &#123; // 单击事件 void onClick(int pos, BaseViewHolder holder, D data); // 长按事件 void onLongPress(int pos, BaseViewHolder holder, D data); // 双击事件 void onDoubleClick(int pos, BaseViewHolder holder, D data);&#125; 实现需要的事件抽象类的实现，可以选择性的实现需要的方法 12345678910111213141516171819202122232425262728293031323334public abstract class SimpleItemListener&lt;D&gt; implements OnItemListener&lt;D&gt; &#123; @Override public void onClick(int pos, BaseViewHolder holder, D data) &#123; &#125; @Override public void onLongPress(int pos, BaseViewHolder holder, D data) &#123; &#125; @Override public void onDoubleClick(int pos, BaseViewHolder holder, D data) &#123; &#125;&#125; adapter.setItemListener(new SimpleItemListener &lt;GuideData&gt;() &#123; @Override public void onClick(int pos, BaseViewHolder holder, GuideData data) &#123; Toast.makeText(mContext, "单击事件", Toast.LENGTH_SHORT).show(); &#125; @Override public void onLongPress(int pos, BaseViewHolder holder, GuideData data) &#123; Toast.makeText(mContext, "长按事件", Toast.LENGTH_SHORT).show(); &#125; @Override public void onDoubleClick(int pos, BaseViewHolder holder, GuideData data) &#123; Toast.makeText(mContext,"双击事件", Toast.LENGTH_SHORT).show(); &#125; &#125;); SectionRvAdapter 事件123456789101112adapter.setItemListener(new SimpleItemListener&lt;ItemModel&gt;() &#123; @Override public void onClick(int pos, BaseViewHolder holder, ItemModel data) &#123; // 当是Content数据类型 if (data.getRvType() == AbsAdapter.TYPE_ITEM_DEFAULT) &#123; Content content = (Content) data.get(); Toast.makeText(SectionAdapterTest.this, content.contentTitle, Toast.LENGTH_SHORT).show(); &#125;else&#123; // 当是ItemHeader数据类型 &#125; &#125; &#125;); 数据更新为了简化数据更新的方法，内置了数据更新的部分方法 内置更新方法1234// 插入一条数据public void insert(int pos, D data) // 更新数据，isUpdate为false时只会添加数据不会更新显示public void notifyDataSetChanged(List&lt;D&gt; data, boolean isUpdate) 分页更新方法12// 简化分页加载的更新，调用该方法实现增量更新，不会全部刷新，isAllData为true时表示data是全部数据，为false时表示是追加的数据public void appendTailRangeData(List&lt;D&gt; data, boolean isAllData) SectionRvAdapter 追加更新// SectionRvAdapter比较特别，需要使用单独的更新方法123456// 使用SectionRule配置数据时，使用此方法更新public void updateDataAndItemHeader(List&lt;ID&gt; data)// 使用Map配置数据时，使用此方法更新public void updateDataAndItemHeader(Map&lt;IH, List&lt;ID&gt;&gt; map)// 分页加载更新数据时调用，仅支持使用SectionRule配置数据public void appendSectionTailRangeData(List&lt;ID&gt; data) Module使用Module配置附加功能，目前有HFModule(添加Header和Footer)、LoadMoreModule(预加载更多) 添加 Header 和 Footer HFModule 123456789101112131415161718192021222324// 生成和添加moduleHFModule hfModule = new HFModule(mContext, R.layout.header_footer_headerly, R.layout.header_footer_footerly, mRv);adapter.addHFModule(hfModule);// 更改Header 和 Footer的数据,类似数据的配置,你可以在实现的方法里绑定数据和监听事件adapter = new SimpleRvAdapter&lt;HFModel&gt;(mContext, hfModels, R.layout.header_footer_item) &#123; @Override public void onBindHeader(BaseViewHolder header) &#123; super.onBindHeader(header); &#125; @Override public void onBindFooter(BaseViewHolder footer) &#123; super.onBindFooter(footer); &#125; &#125;;// 当只想添加Header或Footer时，使用常亮HFModule.NO_RES表示没有资源HFModule hfModule = new HFModule(mContext,HFModule.NO_RES, HFModule.NO_RES, mRv); // 隐藏Header 和 Footerpublic void setFooterEnable(boolean footerEnable)public void setHeaderEnable(boolean headerEnable) 预加载更多 LoadMoreModule new LoadMoreModule(int preLoadNum, OnLoadMoreListener lis),preLoadNum表示提前几个Item进行预加载，preLoadNum越大预加载的越提前加载数据完成之后需要调用mLoadMoreModule.finishLoad();结束本次加载，保证下次加载可以生效 123456789101112131415161718// 触发之后1500秒后加载数据LoadMoreModule loadMoreM = new LoadMoreModule(4, new OnLoadMoreListener() &#123; @Override public void onLoadMore(final LoadMoreModule mLoadMoreModule) &#123; new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; List&lt;LoadMoreModel&gt; tempData = new ArrayList&lt;LoadMoreModel&gt;(); for (int i = 0; i &lt; 9; i++) &#123; tempData.add(new LoadMoreModel("new is " + i)); &#125; adapter.appendTailRangeData(tempData, false); mLoadMoreModule.finishLoad(); &#125; &#125;, 1500); &#125; &#125;); adapter.addLoadMoreModule(loadMoreM); 其他adapterId 区分为了区分不同的适配器，生成了adapterId,用来检测当前RecyclerView使用的是不是这个adapter 1public boolean isThisAdapter(RecyclerView rv) Sample123456789101112131415161718192021222324252627282930313233343536373839404142434445//内部类实现quickAdapter = new TypeRvAdapter&lt;Demo&gt;(self, demos) &#123; @Override public void onBindView(RvViewHolder holder, Demo data, int pos, int type) &#123; // 给控件绑定数据,必须实现 &#125; @Override public void onBindHeader(RvViewHolder header) &#123; //给Header绑定数据和事件,不需要可以不实现 &#125; @Override public void onBindFooter(RvViewHolder footer) &#123; //给footer绑定数据和事件,不需要可以不实现 &#125; &#125;;//继承实现public class MyAdapter extends TypeRvAdapter&lt;Demo&gt; &#123; public MyAdapter(Context context, List&lt;Demo&gt; data) &#123; super(context, data); &#125; @Override public void onBindView(RvViewHolder holder, Demo data, int pos, int type) &#123; // 给控件绑定数据,必须实现 &#125; @Override public void onBindHeader(RvViewHolder header) &#123; //给Header绑定数据和事件,不需要可以不实现 &#125; @Override public void onBindFooter(RvViewHolder footer) &#123; //给footer绑定数据和事件,不需要可以不实现 &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android添加快捷方式]]></title>
      <url>%2F2016%2F07%2F29%2FAndroid%E5%BC%80%E5%8F%91%2FAndroid%E6%B7%BB%E5%8A%A0%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[权限12&lt;uses-permission android:name="com.android.launcher.permission.INSTALL_SHORTCUT"/&gt;&lt;uses-permission android:name="com.android.launcher.permission.UNINSTALL_SHORTCUT"/&gt; 配置 快捷方式要打开一个界面，需要一个Intent配置这些信息 1234567891011121314/*** 获取Intent** @param thisActivity 当前activity* @param goActivity 点击打开的activity* @return 创建的Intent*/private static Intent getShortCutIntent(Activity thisActivity, Class goActivity) &#123; // 使用MAIN，可以避免部分手机(比如华为、HTC部分机型)删除应用时无法删除快捷方式的问题 Intent intent = new Intent(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGORY_DEFAULT); intent.setClass(thisActivity, goActivity); return intent;&#125; Action1234// Action 添加Shortcutpublic static final String ACTION_ADD_SHORTCUT = "com.android.launcher.action.INSTALL_SHORTCUT";// Action 移除Shortcutpublic static final String ACTION_REMOVE_SHORTCUT = "com.android.launcher.action.UNINSTALL_SHORTCUT"; 添加快捷方式123456789101112131415161718192021222324252627282930/*** 添加快捷方式** @param activity context* @param name name* @param goActivity 要启动的界面* @param allowRepeat 是否允许重复,建议false* @param iconBitmap 快捷方式图标*/public static void addShortcut(Activity activity, Class goActivity, String name,boolean allowRepeat, Bitmap iconBitmap) &#123; Intent addShortcutIntent = new Intent(ACTION_ADD_SHORTCUT); // 是否允许重复创建 addShortcutIntent.putExtra("duplicate", allowRepeat); // 快捷方式的标题 addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_NAME, name); // 快捷方式的图标 addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_ICON, iconBitmap); // 快捷方式的动作 Intent shortCutIntent = getShortCutIntent(activity, goActivity); addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortCutIntent); activity.sendBroadcast(addShortcutIntent);&#125;public static void addShortcut(Activity activity, Class goActivity, String name, boolean allowRepeat, int res) &#123; BitmapFactory.Options options = new BitmapFactory.Options(); Bitmap bitmap = BitmapFactory.decodeResource(activity.getResources(), res); addShortcut(activity, goActivity, name, allowRepeat, bitmap);&#125; 移除快捷方式12345678910111213141516/** * 移除快捷方式 * * @param activity context * @param goActivity 要启动的Activity * @param name name */public static void removeShortcut(Activity activity, Class goActivity, String name) &#123; Intent intent = new Intent(ACTION_REMOVE_SHORTCUT); intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, name); //intent.addCategory(Intent.CATEGORY_LAUNCHER); intent.putExtra("duplicate", false); Intent shortCutIntent = getShortCutIntent(activity, goActivity); intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortCutIntent); activity.sendBroadcast(intent);&#125; 附全部代码，亲测可用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * com.march.libs.helper * CdLibsTest * Created by chendong on 16/7/29. * Copyright © 2016年 chendong. All rights reserved. * Desc : */public class ShortCutHelper &#123; // Action 添加Shortcut public static final String ACTION_ADD_SHORTCUT = "com.android.launcher.action.INSTALL_SHORTCUT"; // Action 移除Shortcut public static final String ACTION_REMOVE_SHORTCUT = "com.android.launcher.action.UNINSTALL_SHORTCUT"; /** * 获取Intent * * @param thisActivity 当前activity * @param goActivity 点击打开的activity * @return 创建的Intent */ private static Intent getShortCutIntent(Activity thisActivity, Class goActivity) &#123; // 使用MAIN，可以避免部分手机(比如华为、HTC部分机型)删除应用时无法删除快捷方式的问题 Intent intent = new Intent(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGORY_DEFAULT); intent.setClass(thisActivity, goActivity); return intent; &#125; /** * 添加快捷方式 * * @param activity context * @param name name * @param goActivity 要启动的界面 * @param allowRepeat 是否允许重复 * @param iconBitmap 快捷方式图标 */ public static void addShortcut(Activity activity, Class goActivity, String name, boolean allowRepeat, Bitmap iconBitmap) &#123; Intent addShortcutIntent = new Intent(ACTION_ADD_SHORTCUT); // 是否允许重复创建 addShortcutIntent.putExtra("duplicate", allowRepeat); // 快捷方式的标题 addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_NAME, name); // 快捷方式的图标 addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_ICON, iconBitmap); // 快捷方式的动作 Intent shortCutIntent = getShortCutIntent(activity, goActivity); addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortCutIntent); activity.sendBroadcast(addShortcutIntent); &#125; public static void addShortcut(Activity activity, Class goActivity, String name, boolean allowRepeat, int res) &#123; BitmapFactory.Options options = new BitmapFactory.Options(); Bitmap bitmap = BitmapFactory.decodeResource(activity.getResources(), res); addShortcut(activity, goActivity, name, allowRepeat, bitmap); &#125; /** * 移除快捷方式 * * @param activity context * @param goActivity 要启动的Activity * @param name name */ public static void removeShortcut(Activity activity, Class goActivity, String name) &#123; Intent intent = new Intent(ACTION_REMOVE_SHORTCUT); intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, name); //intent.addCategory(Intent.CATEGORY_LAUNCHER); intent.putExtra("duplicate", false); Intent shortCutIntent = getShortCutIntent(activity, goActivity); intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortCutIntent); activity.sendBroadcast(intent); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[首页加载优化]]></title>
      <url>%2F2016%2F07%2F28%2F%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB%2F%20%E9%A6%96%E9%A1%B5%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[多线程下载对比 Activity进行数据下载耗时263526(4.6min) Service进行数据下载耗时275278(4.7min) Service线程池数据下载耗时(3条线线程) 1230号线程耗时995821号线程耗时1029422号线程耗时106173（1.7min） 多线程总结 现在的网络请求框架okhttp内部有4个线程，支持最多64个并发，单机最大5个并发请求,现在的操作是一次请求完再发起下一次请求。 12maxRequests = 64: 最大并发请求数为64maxRequestsPerHost = 5: 每个主机最大请求数为5 解决方案服务器 单页数据增加，现在是50 压缩传输（GZIP）单次传输更多数据 客户端 多线程下载，每个线程负责自己的页数(跟林杰讨论说现在一个客户端最多一条连接？) 下载和存储异步,不存储的话,时间会缩短很多（时间对比5min vs 12.5min）,现在是请求一次数据就存一次,全部请求完存完才显示UI 数据库操作耗时，但更换数据库成本太高,现在用的库不知道是不是最快的（应该还好,调研过，不是最快的也是前二）但是插入数据耗费了很多时间,这个主要是对比我新建的工程（不进行存储操作）耗时5min左右和宝宝拍拍工程12.5min左右除了数据库插入耗时也有可能是别的UI绘制和请求占用了网速和CPU. 现在是单条数据插入，使用批量插入更快，有待优化。（这个之前就了解了，没来得及改） 现在 ‘首次数据拉取’ 和 ‘增量更新’ 的逻辑分的不是很清楚，首次拉取时做了多余的操作，分开之后首次拉取就可以批量插入了，参考4 UI 不要让用户感觉到一直阻碍在首页，如果服务器可以发有序数据，拉取2页照片，获得最后时间戳，拉取时间戳之前的视频，展示这些数据供用户浏览（用户应该是比较关心新数据的），禁掉所有不能做的操作。将真正的下载任务发布到后台进行，数据完全到达时，再刷新首页，就不用一直卡在那里。如果是这样的话，请求和存储异步不异步差别就不大了，都是要请求完存完再操作。 流程图基本流程 分离首次数据拉取和数据更新 请求和存储异步]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[带有泛型的类如何继承]]></title>
      <url>%2F2016%2F07%2F20%2F%E5%AD%A6%E4%B9%A0%2FJava_%E5%B8%A6%E6%9C%89%E8%8C%83%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%A6%82%E4%BD%95%E7%BB%A7%E6%89%BF%2F</url>
      <content type="text"><![CDATA[继承父类的范型12345678910111213141516171819202122232425262728293031public class GenericityTst &#123; public class Temp &#123; &#125; //具有泛型的ClassA public class ClassA&lt;T&gt;&#123; T t; &#125; //继承泛型 public class ClassB&lt;T&gt; extends ClassA&lt;T&gt;&#123; T t; &#125; //缩小泛型的范围，是准许的，但是不允许扩大泛型的范围 public class ClassC&lt;T extends Temp&gt; extends ClassA&lt;T&gt;&#123; T t; &#125; //具有泛型的类ClassD,泛型具有父类约束 public class ClassD&lt;T extends Temp&gt; &#123; T t; &#125; //继承ClassD,声明泛型时至少具有父类同样的约束 public class ClassE&lt;T extends Temp&gt; extends ClassD&lt;T&gt;&#123; T t; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在AS中使用lambda表达式]]></title>
      <url>%2F2016%2F07%2F16%2F%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%2FAS%E4%BD%BF%E7%94%A8Lambda%2F</url>
      <content type="text"><![CDATA[前言 Lambda表达式从Java8开始支持，简化了书写，同时理解上难度也加大了，不过熟悉了就会好很多啦。但是AS默认不支持Lambda的，需要配置一下 根目录下gradle文件配置 在project / build.gradle中配置 123456789buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.1.3&apos; classpath &apos;me.tatarka:gradle-retrolambda:3.2.5&apos; &#125;&#125; app下gradle文件配置 在project / app / build.gradle顶部配置插件 12apply plugin: &apos;me.tatarka.retrolambda&apos;... 在android{…}中配置12345678910111213android &#123; ...... // 注释冲突 packagingOptions &#123; exclude &apos;META-INF/services/javax.annotation.processing.Processor&apos; &#125; // 使用Java1.8 compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125; ......&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ORM框架－GreenDao]]></title>
      <url>%2F2016%2F07%2F12%2FAndroid%E5%BC%80%E5%8F%91%2FAndroid-ORM%E6%A1%86%E6%9E%B6GreenDao%2F</url>
      <content type="text"><![CDATA[GreenDao官网官网 -&gt; http://greendao-orm.com GitHubGitHub -&gt; https://github.com/greenrobot/greenDAO 性能对比 介绍 GreenDao采用的是用java代码直接生成Bean（实体）和Dao（Data Access Object数据访问对象）的方式，都不用自己写实体了，也是一大好处，不过这也造成了理解上的难度，我刚开始用的时候就有点蒙。 首先创建一个Java的Library,一定是Java的，命名为daogenerator（可以起别的名字，为了后面叙述方便）。在app下面和’java’目录同级创建’java-gen’目录，将会用来放置生成的Bean和Dao。Dao也就是数据访问对象，实体类只能描述一个对象的属性和行为，想与数据库交流就需要Dao对象，它包含对应的数据库字段和增删改查方法。 生成文件 在daogenerator库里创建’ExampleDaoGenerator.java’文件,包含main方法，构建schema，生成目录和文件 123456789101112131415161718192021public static void main(String[] args) throws Exception&#123; operate();&#125;private static void operate() throws Exception &#123; // Schema对象，可以用来生成实体和dao // 两个参数分别代表：数据库版本号与自动生成bean代码的包路径。 Schema schema = new Schema(2, "com.march.bean"); // 默认的dao目录 schema.setDefaultJavaPackageDao("com.march.dao"); // 模式（Schema）同时也拥有两个默认的 flags，分别用来标示 entity 是否是 activie 以及是否使用 keep sections。 // 可以激活预热实体，使读写更迅速 schema.enableActiveEntitiesByDefault(); // 这个是为了你可以在自动生成的实体类中添加自己的custom代码 schema.enableKeepSectionsByDefault(); // 一旦你拥有了一个 Schema 对象后，你便可以使用它添加实体（Entities）了。这里只是一个假的方法表示一下，生成实体在下一节 generateBean(schema); // 最后我们将使用 DAOGenerator 类的 generateAll() 方法自动生成代码，此处你需要根据自己的情况更改输出目录（既之前创建的 java-gen)。 // 其实，输出目录的路径可以在 build.gradle 中设置，有兴趣的朋友可以自行搜索，这里就不再详解。 new DaoGenerator().generateAll(schema, "/Users/march/AndroidPro/Reaper/app/src/main/java-gen");&#125; 如何生成实体12345678910111213private static void addNote(Schema schema) &#123; // 一个实体（类）就关联到数据库中的一张表，此处表名为「Note」（既类名） Entity note = schema.addEntity("Note"); // greenDAO 会自动根据实体类的属性值来创建表字段，并赋予默认值 // 接下来你便可以设置表中的字段,又很多链式编程的方法，结合数据库的create table操作可以设置相关的字段及约束 note.addIdProperty().autoincrement(); note.addBooleanProperty("isYes").primaryKey().unique(); note.addStringProperty("text").notNull(); // 与在 Java 中使用驼峰命名法不同，默认数据库中的命名是使用大写和下划线来分割单词的。 // For example, a property called “creationDate” will become a database column “CREATION_DATE”. note.addStringProperty("comment"); note.addDateProperty("date");&#125; 自定义生成的代码 当重新执行java代码时会覆盖生成新的文件，如果你修改了生成的类，就会被重新覆盖，解决这个问题，设置note.setHasKeepSections(true);会在文件中生成一些注释，在注释中间的代码将不会被覆盖，也可以设置继承，实现等。。。这样就不需要每次都修改代码了 1234567891011121314151617181920// KEEP INCLUDES - put your custom includes hereimport com.march.quickrvlibs.inter.RvQuickInterface;// KEEP INCLUDES END// KEEP FIELDS - put your custom fields herepublic static final int TYPE_SHU = 0;public static final int TYPE_HENG = 1;// KEEP FIELDS END// KEEP METHODS - put your custom methods here@Overridepublic int getRvType() &#123; if (height &gt; width) return 0; else return 1;&#125;// KEEP METHODS END 12345678//设置支持自定义代码（或schema.enableKeepSectionsByDefault();）note.setHasKeepSections(true);//设置实现的接口note.implementsInterface("RvQuickInterface", "java.io.Serializable");//设置继承的父类note.setSuperclass("Album");//你也可以重新给表命名note.setTableName("NODE"); 初始化数据库123456789101112131415private DaoSession mDaoSession;public void setupDatabase(Context context) &#123; // 通过 DaoMaster 的内部类 DevOpenHelper，你可以得到一个便利的 SQLiteOpenHelper 对象。 // 可能你已经注意到了，你并不需要去编写「CREATE TABLE」这样的 SQL 语句，因为 greenDAO 已经帮你做了。 // 注意：默认的 DaoMaster.DevOpenHelper 会在数据库升级时，删除所有的表，意味着这将导致数据的丢失。 // 所以，在正式的项目中，你还应该做一层封装，来实现数据库的安全升级。 DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(context, "notes-db", null); SQLiteDatabase db = helper.getWritableDatabase(); // 注意：该数据库连接属于 DaoMaster，所以多个 Session 指的是相同的数据库连接。 DaoMaster daoMaster = new DaoMaster(db); mDaoSession = daoMaster.newSession(); // 在 QueryBuilder 类中内置两个 Flag 用于方便输出执行的 SQL 语句与传递参数的值 QueryBuilder.LOG_SQL = true; QueryBuilder.LOG_VALUES = true;&#125; 获取Dao123public WholeAlbumItemDao getWholeAlbumItemDao() &#123; return mDaoSession.getWholeAlbumItemDao();&#125; 增12345678910//这两个方法提供简单的插入和不存在则插入存在则更新的操作DaoHelper.get().getAlbumDetailDao().insert();DaoHelper.get().getAlbumDetailDao().insertOrReplace();//这两个方法是上面两个方法的加强版，支持iterable类型多个对象的插入和更新，同时是基于事务的。DaoHelper.get().getAlbumDetailDao().insertInTx();DaoHelper.get().getAlbumDetailDao().insertOrReplaceInTx();//官方解释:Insert an entity into the table associated with a concrete DAO &lt;b&gt;without&lt;/b&gt; setting key property.//Warning: This may be faster, but the entity should not be used anymore. The entity also won't be attached to identity scope.//大概意思就是小心点用，虽然速度快，但是插进去可能就拿不出来了DaoHelper.get().getAlbumDetailDao().insertWithoutSettingPk() 删1234567891011//与insert方法大同小异DaoHelper.get().getAlbumDetailDao().delete();DaoHelper.get().getAlbumDetailDao().deleteInTx();//根据主键删除元素DaoHelper.get().getAlbumDetailDao().deleteByKey();DaoHelper.get().getAlbumDetailDao().deleteByKeyInTx();//删除全部DaoHelper.get().getAlbumDetailDao().deleteAll();//也是删除，具体的区别还没弄明白DaoHelper.get().getAlbumDetailDao().detach()DaoHelper.get().getAlbumDetailDao().detachAll(); 改12DaoHelper.get().getAlbumDetailDao().update();DaoHelper.get().getAlbumDetailDao().updateInTx(); 查 关于Query的操作相对复杂， 下面只是比较基本的，更多的使用方法可以参照Query文档 12345678910111213141516171819// 获取querybuilderQueryBuilder&lt;RecommendAlbumItem&gt; queryBuilder = DaoHelper.get().getRecommendAlbumItemDao().queryBuilder();// 查询条件，大于小于，and,orqueryBuilder.where( RecommendAlbumItemDao.Properties.Album_type.eq(""), queryBuilder.or(RecommendAlbumItemDao.Properties.Album_cover.gt(""), queryBuilder.and(RecommendAlbumItemDao.Properties.Album_cover.ge("") ,RecommendAlbumItemDao.Properties.Album_cover.eq(""))));// offset limmit queryBuilder.offset(10).limit(10);//排序queryBuilder.orderAsc();queryBuilder.orderCustom(null,null);queryBuilder.orderDesc();queryBuilder.build();//查询数量queryBuilder.count();//返回listqueryBuilder.list();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac安装Mongdb]]></title>
      <url>%2F2016%2F05%2F18%2F%E5%AD%A6%E4%B9%A0%2F%E5%AE%89%E8%A3%85Mongo%2F</url>
      <content type="text"><![CDATA[NoSQL&amp;MongoDB NoSQL(NoSQL = Not Only SQL )，意即”不仅仅是SQL”。 MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。 在高负载的情况下，添加更多的节点，可以保证服务器性能。MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 安装MongoDb 这里用到了brew管理工具，brew的安装1$ brew install mongodb 配置环境变量 Mac下打开配置文件 123$ open .bash_profile # 写入以下路径export PATH=/usr/local/Cellar/mongodb/3.0.7/bin:$PATH 配置自启动12$ ln -sfv /usr/local/opt/mongodb/*.plist ~/Library/LaunchAgents $ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mongodb.plist 根据配置启动mongodb 使用该命令将会使用mongod.conf文件的相关配置来启动mongodb 文件的路径在 /usr/local/etc/mongod.conf（Mac） 从配置文件可以看到数据库的路径以及log的路径等。 1234567891011$ mongod --config /usr/local/etc/mongod.conf# 文件内容systemLog: destination: file path: /usr/local/var/log/mongodb/mongo.log logAppend: truestorage: dbPath: /usr/local/var/mongodbnet: bindIp: 127.0.0.1 直接启动 直接启动快捷简单，数据将会存储在/data/db下,其中/data路径与/usr路径是同级的。 123456数据会存放在/data/db 目录下，需要首先创建目录$ mkdir -p /data/db $ chown `id -u` /data/db 启动$ mongod]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python Django服务器搭建初体验]]></title>
      <url>%2F2016%2F05%2F14%2F%E5%AD%A6%E4%B9%A0%2Fpython%E6%A1%86%E6%9E%B6Django1%2F</url>
      <content type="text"><![CDATA[前言 安装的部分工具，我是在Mac下使用，其他的平台自己搜索一下如何安装。现在默认你已经安装了Python环境，我的是Python2.7 安装pip包管理器 pip包管理器是python下安装模块的工具 1234567$ curl -O https://raw.github.com/pypa/pip/master/contrib/get-pip.py$ [sudo] python get-pip.py# 安装包$ pip install django# 卸载包$ pip uninstall django 安装ipython ipython是一个增强式的python交互式操作命令工具，有自动提示和补全的功能 1$ pip install ipython 安装django1$ pip install django 简单尝试12345678910111213141516171819# 创建一个项目$ django -admin startproject mysite# 开启服务$ python manage.py runserver# 出现如下字样May 14, 2016 - 00:00:21Django version 1.9.6, using settings 'mysite.settings'Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C.Not Found: /[14/May/2016 00:00:32] "GET / HTTP/1.1" 200 1767Not Found: /favicon.ico[14/May/2016 00:00:32] "GET /favicon.ico HTTP/1.1" 404 1936# 打开浏览器输入`http://127.0.0.1:8000/`就可以看到It worked字样，一个简单的web服务就好了# 你可以使用`python manage.py`查看更多的命令 各个文件的简单介绍12345678910$ cd mysite/$ lsmanage.py mysite# manage.py是一个管理工具，使用它可以管理服务器，比如开启服务等# mysite是你的工程目录$ cd mysite/__init__.py settings.py urls.py wsgi.py__init__.pyc settings.pyc urls.pyc wsgi.pyc# settings.py 是一些配置信息# urls.py 是url的映射，他表示不同的url会映射到不同的网页 建立app django是使用app的形式来配置模块，你可以建立新的模块 12345678910111213$ python manage.py startapp blog# 可以发现在mysite目录下有了blog和mysite两个文件夹# 在mysite/mysite/settings.py中配置这个app模块# Application definitionINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'blog'] 构建一个简单的网页123456789101112131415161718192021222324252627$ cd blog/$ ls_init__.py admin.pyc models.py views.py__init__.pyc apps.py models.pyc views.pycadmin.py migrations tests.py# blog目录下的文件，我们现在只使用views.py，他是用来构建输出html 页面的一个类#（1）打开views.py 定义一个简单的html页面from django.shortcuts import renderfrom django.http import HttpResponse# Create your views here.def hello(request): return HttpResponse('&lt;html&gt;hello world&lt;/html&gt;') # (2) 打开mysite/mysite/urls.py 配置url映射from django.conf.urls import urlfrom django.contrib import adminurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'hello','blog.views.hello')]# (3) 启动服务,在浏览器输入http://127.0.0.1:8000/hello,可以获得返回的网页$ python manage.py runserver]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node.js基础1]]></title>
      <url>%2F2016%2F05%2F14%2F%E5%AD%A6%E4%B9%A0%2FNodeJs%E5%9F%BA%E7%A1%801%2F</url>
      <content type="text"><![CDATA[基本工具的配置检测xcode是否安装12$ xcode-select -p/Applications/Xcode.app/Contents/Developer 检测python和ruby版本12$ python -v$ ruby -v 安装homebrew1$ /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装node.js1$ brew install node 第一个web应用创建连接12345678910111213141516//新建一个文件，为server.js,内容如下const http = require('http');const hostname = '127.0.0.1';const port = 3000;const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello World\n');&#125;);server.listen(port, hostname, () =&gt; &#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;); 启动服务 到相应目录下运行命令,打开浏览器输入http://127.0.0.1:3000/可以看到服务已经起来了，使用ctrl+c停止服务 1$ node server.js]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift基础2]]></title>
      <url>%2F2016%2F05%2F11%2F%E5%AD%A6%E4%B9%A0%2FSwift%E5%9F%BA%E7%A1%802%2F</url>
      <content type="text"><![CDATA[可选型的概念 数据类型＋？将会构成一种新的类型，可选型，String?为字符串可选型，，在swift中，空的概念略有不同，java中，如果一个对象变量，没有指向，为null；一个int类型的变量如果没有初始化，值为0，null和0 意为没有，在swift中，空是一种完全独立的数据类型，nil的位置和Int，String的地位是一样的，他不是对象或者数据的一种特殊状态，而是一种新的对象。这也就意味着代码中(1)的部分是编译错误的，会提示，nil类型是不能和String类型进行的比较的，该设计的目的是为了使swift更具安全性，因为任何对象都不能设置为nil,就如同String类型的数据不能设置为int类型的数据，他们是完全不同的对象，可以避免潜在空指针的发生。 123456789101112131415161718192021222324//(1)var str = "abc"if(str == nil)&#123;&#125;//String? 为String可选型，他意味着这种类型，可以为nil,还是那句话，可选型和nil不是一个类型的特殊状态，他是一种新的类型。//2var optionalStr:String? = "hello"optionalStr = "world"print(optionalStr == nil) var greet = "hey"if let name = optionalStr&#123; greet = "hello \(name)";&#125;print(greet) if(optionalStr != nil)&#123; print("optional str is not nil")&#125; where与模式匹配1234567891011121314151617181920212223242526272829303132333435//switch中使用where语句let point = (3,3)switch point &#123; case let(x,y) where x == y: print("x == y") case let(x,y) where x == -y: print("x == -y") default: print("rst is \(point.0) , \(point.1)")&#125;//switch中使用运算符 let age = 19switch age&#123; case 10 ... 19: print("teenager") default: print("not teenager")&#125; //if中使用模式 if case 10...19 = age where age &gt; 18&#123; print("teenager and in colldge")&#125; //if中使用模式和where语句let vector = (4,0)if case (let x,0) = vector where x &gt; 2 &amp;&amp; x &lt; 5&#123; print("it is vector")&#125; //if中使用模式＋where+运算符 for case let i in 1 ... 100 where i % 3==0&#123; print("i is \(i)")&#125; guard关键字12345678910111213//guard else 防止数据错误，也可以认为是需要满足的一种先决条件//例如下面money&gt;price,capacity &gt; volume是必须满足的条件，简化语法，防止错误func buy(money:Int,price:Int,capacity:Int,volume:Int) -&gt; Bool&#123; guard money &gt; price else &#123; print("not money") return false &#125; guard capacity &gt; volume else&#123; print("not volume") return false &#125; return true&#125; String类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//字符串var originStr = "this is str"originStr = "this is new str"//定义一个空字符串let emptyStr = ""//判空操作print(emptyStr.isEmpty)//合并字符串var rstStr = originStr + emptyStr//使用+=,此时rstStr必须是变量rstStr += originStr//字符串插值rstStr = "this is new str and insert \(100)"//转义字符 \//遍历字符串for c in originStr.characters&#123; print(c)&#125; //Characterlet cc:Character = "!"originStr.append(cc) //字符串长度，基于unicode码，也就是说不管是3个汉字或者3个字母，它的count都是3let englishLetter = "abc"let chinseLetter = "慕课网"let emojiLetter = "😢😢😢"let unicodeLetter = "\u&#123;1f60e&#125;\u&#123;0301&#125;"print(englishLetter.characters.count)print(chinseLetter.characters.count)print(emojiLetter.characters.count)print("enlish is \(englishLetter) chinse is \(chinseLetter) emoji is \(emojiLetter) unicode is \(unicodeLetter)") //索引访问字符串，需要使用String.Index类来访问//[startIndex,endIndex)let startIndex = originStr.startIndexlet endIndex = originStr.endIndexprint("index is \(startIndex) and content is \(originStr[startIndex])")//向后n个startIndex.advancedBy(6)//前面一个位置endIndex.predecessor()//后面一个位置startIndex.successor() //String的一些API//Range&lt;Index&gt;类型let range = startIndex.advancedBy(3) ..&lt; endIndexoriginStr.replaceRange(range, with: "!!!")originStr.appendContentsOf("xxx")originStr.insert("z", atIndex: originStr.endIndex) originStr.removeAtIndex(originStr.endIndex.predecessor()) originStr.removeRange(originStr.endIndex.advancedBy(-2)..&lt;originStr.endIndex) print("upper \(originStr.uppercaseString) low \(originStr.lowercaseString) First up \(originStr.capitalizedString)")originStr.containsString("")originStr.hasSuffix("")originStr.hasPrefix("") //NSString let s2 = NSString(format: "one third is %.2f",1.0/3.0)print("转换 \(s2 as String)") let nsStr:NSString = "one third is 0.33"nsStr.substringFromIndex(4)nsStr.substringFromIndex(3)nsStr.substringWithRange(NSMakeRange(4, 5)) let s6 = " --- Hello --- " as NSString//去掉空格和－print(s6.stringByTrimmingCharactersInSet(NSCharacterSet(charactersInString:" -"))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Webview和原生应用交互]]></title>
      <url>%2F2016%2F04%2F26%2FAndroid%E5%BC%80%E5%8F%91%2FAndroid%E4%B8%8EWebView%E4%BA%A4%E4%BA%92%2F</url>
      <content type="text"><![CDATA[定义关联的对象12345678910111213141516public class Bridge2Js &#123; private Activity activity; public Bridge2Js(Activity activity)&#123; this.activity = activity; &#125; //4.2之后需要加注解否则报错 @JavascriptInterface public void startPage(int pageSign, String json)&#123; activity.... &#125; @JavaInterface public void clickOnAndroid()&#123; &#125;&#125; 设置关联类123WebSettings mWebSettings = mProgressWebView.getSettings();//允许js交互mProgressWebView.addJavascriptInterface(new Bridge2Js(this), "bridge"); 在JS代码中调用Android代码12345678910111213141516171819//button&lt;input type="button" value="click me" onclick="window.bridge.startPage(0,'asd')"/&gt;//标准html&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;script language="javascript"&gt; /在Android代码中可以调用下面js函数/ function wave() &#123; alert("1"); document.getElementById("droid").src="android_waving.png"; alert("2"); &#125; &lt;/script&gt; &lt;body&gt; &lt;!-- 在这里调用Andriod函数 --&gt; &lt;a onClick="window.bridge.clickOnAndroid()"&gt;Click me!&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 在Android中调用JS代码1webview.loadUrl("javascript:wave()");]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[防止app闪白屏或闪黑屏]]></title>
      <url>%2F2016%2F04%2F18%2FAndroid%E5%BC%80%E5%8F%91%2FAndriod%E5%90%AF%E5%8A%A8%E5%8E%BB%E6%8E%89%E7%99%BD%E5%B1%8F%E6%88%96%E9%BB%91%E5%B1%8F%2F</url>
      <content type="text"><![CDATA[前言 App启动时需要加载应用进程，就算你的软件在Appliation中什么也没做仍旧会有延时，会显示白屏或者黑屏，很难看 透明Theme 使用透明Theme解决，原理就是虽然程序启动了，但是没有显示出来，你看到的还是桌面，目前主流的产品都是用的这种方式，比如QQ，微信。缺点就是等待的时间长，造成程序启动慢的感觉。 1234&lt;style name="Theme.AppStartUseTransparent" parent="Theme.AppCompat.NoActionBar"&gt; &lt;item name="android:windowIsTranslucent"&gt;true&lt;/item&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt;&lt;/style&gt; 图片Theme 使用图片Theme解决，原理就是设置一张背景图，在你的程序没有加载完成的时候会显示这张背景图，你也可以用shape自定义或者使用图片，优点就是启动很快，显示的效果取决于你的图片。 1234&lt;style name="Theme.AppStartUseDrawable" parent="Theme.AppCompat.NoActionBar"&gt; &lt;item name="android:windowBackground"&gt;@drawable/shape_maincolor&lt;/item&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt;&lt;/style&gt; 在manifest.xml使用 我是AppCompat的风格，你可以对parent＝“”做适当修改。 123456789 &lt;activity android:name=".activity.LoadingActivity" android:theme="@style/Theme.AppStartUseTransparent"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RecyclerView添加Header和Footer的基本原理]]></title>
      <url>%2F2016%2F04%2F11%2FAndroid%E5%BC%80%E5%8F%91%2FRecyclerView%E6%B7%BB%E5%8A%A0Header%E5%92%8CFooter%2F</url>
      <content type="text"><![CDATA[GitHub GitHub 介绍 采用的基本原理就是Header和Footer作为RecyclerView的一个Item，只是显示的方式特别一点，ListView实际也是这么做的所以添加了Header之后，数据的位置会错乱。 由于使用不同的LayoutManager时显示效果也不一样， 所以针对不同的LayoutManager需要做不同的操作。 分析一下，LinearLayoutManager比较简单，只需要将Header和Footer作为一项就可以了，GridLayoutManager和StaggeredGridLayoutManager在这个基础上还需要将Header和Footer所在的Item充满他所在的这一行。 变量和方法123456789101112131415161718//Header和Footer,以及对应的Typeprivate View mHeaderView;private View mFooterView;private int TYPE_HEADER = -1;private int TYPE_FOOTER = -2;//一些辅助的方法public int getHeaderCount() &#123; return isHasHeader() ? 1 : 0;&#125;private boolean isHasHeader() &#123; return mHeaderView != null;&#125;private boolean isHasFooter() &#123; return mFooterView != null;&#125; 根据是否有Header和Footer获取数据Size123456789101112//根据是否有Header和Footer返回不同的Size@Overridepublic int getItemCount() &#123; int pos = datas.size(); if (isHasHeader()) pos++; if (isHasFooter()) pos++; return pos;&#125; 根据是否有Header和Footer获取Type12345678910111213141516171819202122//获取item的type，基本逻辑是如果有header又是位于第一个的则返回HeaderType,如果pos超出了data的size，又是最后一个，则返回FooterType@Overridepublic int getItemViewType(int position) &#123; //如果没有header没有footer直接返回 if (!isHasHeader() &amp;&amp; !isHasFooter()) return datas.get(position).getRvType(); //有header且位置0 if (isHasHeader() &amp;&amp; position == 0) return TYPE_HEADER; //pos超出 if (isHasFooter() &amp;&amp; position == getItemCount() - 1) return TYPE_FOOTER; //如果有header,下标减一个 if (isHasHeader()) return datas.get(position - 1).getRvType(); else //没有header 按照原来的 return datas.get(position).getRvType();&#125; 根据是否有Header和Footer创建Holder123456789101112//根据返回的不同的type使用HeaderView和FooterView初始化Holder,至此已经可以对LinearLayoutManager添加Header和Footer@Overridepublic RvViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; RvViewHolder holder; if (isHasFooter() &amp;&amp; viewType == TYPE_FOOTER) &#123; holder = new RvFooterHolder(mFooterView); &#125; else if (isHasHeader() &amp;&amp; viewType == TYPE_HEADER) &#123; holder = new RvHeaderHolder(mHeaderView); &#125; else &#123; holder = new RvViewHolder(getInflateView(Res4Type.get(viewType).getResId(), return holder;&#125; LinearLayoutManager 由于LinearLayoutManager是连续排列的，所以只需要创建不同的holder就可以实现header+footer GridLayoutManager 首先如何知道是否是GridLayoutManager,重写onAttachedToRecyclerView方法获取Manager,调用gridLayoutManager.setSpanSizeLookup（）方法，设置他跨越的宽度。 12345678910111213141516171819202122@Overridepublic void onAttachedToRecyclerView(RecyclerView recyclerView) &#123; super.onAttachedToRecyclerView(recyclerView); Log.e("chendong","onAttachedToRecyclerView"); RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager(); if (layoutManager instanceof GridLayoutManager) &#123; final GridLayoutManager gridLayoutManager = (GridLayoutManager) layoutManager; gridLayoutManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() &#123; @Override public int getSpanSize(int position) &#123; return getItemViewType(position) == TYPE_HEADER || getItemViewType(position) == TYPE_FOOTER ? gridLayoutManager.getSpanCount() : 1; &#125; &#125;); return; &#125; //判断是不是StaggeredGridLayoutManager if(layoutManager instanceof StaggeredGridLayoutManager)&#123; isStaggeredGridLayoutManager = true; &#125;&#125; StaggeredGridLayoutManager 主要使用StaggeredGridLayoutManager.LayoutParams的 layoutParams.setFullSpan(true);方法设置 123456789101112131415161718192021222324252627282930@Overridepublic RvViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; RvViewHolder holder; if (isHasFooter() &amp;&amp; viewType == TYPE_FOOTER) &#123; holder = new RvFooterHolder(mFooterView); &#125; else if (isHasHeader() &amp;&amp; viewType == TYPE_HEADER) &#123; holder = new RvHeaderHolder(mHeaderView); &#125; else &#123; holder = new RvViewHolder(getInflateView(Res4Type.get(viewType).getResId(), parent)); if (clickListener != null) &#123; holder.setOnItemClickListener(clickListener); &#125; if (longClickListenter != null) &#123; holder.setOnItemLongClickListener(longClickListenter); &#125; &#125; //关键代码 if (isStaggeredGridLayoutManager &amp;&amp; (holder instanceof RvHeaderHolder || holder instanceof RvFooterHolder)) &#123; Log.e("chendong","瀑布流设置满行"); StaggeredGridLayoutManager.LayoutParams layoutParams = new StaggeredGridLayoutManager.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); layoutParams.setFullSpan(true); holder.getParentView().setLayoutParams(layoutParams); &#125; bindListener4View(holder, viewType); return holder;&#125; QuickAdapter 最后贴一下整个QuickAdapter的源代码，涉及相关具体的类可以去这里查看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317package com.march.quickrvlibs;import android.content.Context;import android.support.v7.widget.GridLayoutManager;import android.support.v7.widget.RecyclerView;import android.support.v7.widget.StaggeredGridLayoutManager;import android.util.Log;import android.util.SparseArray;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import com.march.quickrvlibs.inter.OnRecyclerItemClickListener;import com.march.quickrvlibs.inter.OnRecyclerItemLongClickListener;import com.march.quickrvlibs.inter.RvQuickInterface;import java.util.Collections;import java.util.List;/** * Created by 陈栋 on 15/12/28. * 功能: */public abstract class RvQuickAdapter&lt;D extends RvQuickInterface&gt; extends RecyclerView.Adapter&lt;RvViewHolder&gt; &#123; protected List&lt;D&gt; datas; protected LayoutInflater mLayoutInflater; protected Context context; protected SparseArray&lt;RvAdapterConfig&gt; Res4Type; private OnRecyclerItemClickListener&lt;RvViewHolder&gt; clickListener; private OnRecyclerItemLongClickListener&lt;RvViewHolder&gt; longClickListenter; private View mHeaderView; private View mFooterView; private int TYPE_HEADER = -1; private int TYPE_FOOTER = -2; private int adapterId;//使用此标志来判断当前adapter的类型 private boolean isStaggeredGridLayoutManager = false; public int getAdapterId() &#123; return adapterId; &#125; /** * 设置adapterId标示 * @param adapterId adapter标示 */ public void setAdapterId(int adapterId) &#123; this.adapterId = adapterId; &#125; /** * 使用标记判断,是否是该adaper * @param adapter adapter * @return boolean */ public boolean isThisAdapter(RvQuickAdapter adapter) &#123; if (adapter == null) &#123; return false; &#125; else if (adapter.getAdapterId() == adapterId) &#123; return true; &#125; return false; &#125; /** * 多类型适配,需要调用addType()方法配置参数 * * @param context context * @param datas 数据源 */ public RvQuickAdapter(Context context, List&lt;D&gt; datas) &#123; this.datas = datas; this.mLayoutInflater = LayoutInflater.from(context); this.context = context; &#125; public RvQuickAdapter(Context context, D[] ds) &#123; Collections.addAll(datas, ds); this.mLayoutInflater = LayoutInflater.from(context); this.context = context; &#125; /** * 单类型适配 * * @param context context * @param datas 数据源 * @param res layout资源 */ public RvQuickAdapter(Context context, List&lt;D&gt; datas, int res) &#123; this.datas = datas; this.mLayoutInflater = LayoutInflater.from(context); this.context = context; this.Res4Type = new SparseArray&lt;&gt;(); Res4Type.put(0, new RvAdapterConfig(0, res)); &#125; public RvQuickAdapter(Context context, D[] ds, int res) &#123; Collections.addAll(datas, ds); this.mLayoutInflater = LayoutInflater.from(context); this.context = context; this.Res4Type = new SparseArray&lt;&gt;(); Res4Type.put(0, new RvAdapterConfig(0, res)); &#125; public void setClickListener(OnRecyclerItemClickListener&lt;RvViewHolder&gt; listener) &#123; if (listener != null) &#123; this.clickListener = listener; &#125; &#125; public void setLongClickListener(OnRecyclerItemLongClickListener&lt;RvViewHolder&gt; longClickListenter) &#123; if (longClickListenter != null) &#123; this.longClickListenter = longClickListenter; &#125; &#125; public void addHeader(View mHeaderView) &#123; this.mHeaderView = mHeaderView; &#125; public void addFooter(View mFooterView) &#123; this.mFooterView = mFooterView; &#125; public void addHeader(int mHeaderViewRes) &#123; this.mHeaderView = getInflateView(mHeaderViewRes, null); &#125; public void addFooter(int mFooterViewRes) &#123; this.mFooterView = getInflateView(mFooterViewRes, null); &#125; public View getInflateView(int resId, ViewGroup parent) &#123; return mLayoutInflater.inflate(resId, parent, false); &#125; @Override public RvViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; RvViewHolder holder; if (isHasFooter() &amp;&amp; viewType == TYPE_FOOTER) &#123; holder = new RvFooterHolder(mFooterView); &#125; else if (isHasHeader() &amp;&amp; viewType == TYPE_HEADER) &#123; holder = new RvHeaderHolder(mHeaderView); &#125; else &#123; holder = new RvViewHolder(getInflateView(Res4Type.get(viewType).getResId(), parent)); if (clickListener != null) &#123; holder.setOnItemClickListener(clickListener); &#125; if (longClickListenter != null) &#123; holder.setOnItemLongClickListener(longClickListenter); &#125; &#125; if (isStaggeredGridLayoutManager &amp;&amp; (holder instanceof RvHeaderHolder || holder instanceof RvFooterHolder)) &#123; Log.e("chendong","瀑布流设置满行"); StaggeredGridLayoutManager.LayoutParams layoutParams = new StaggeredGridLayoutManager.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); layoutParams.setFullSpan(true); holder.getParentView().setLayoutParams(layoutParams); &#125; bindListener4View(holder, viewType); return holder; &#125; @Override public void onBindViewHolder(RvViewHolder holder, int position) &#123; if (isHasFooter() &amp;&amp; position == getItemCount() - 1) &#123; bindLisAndData4Footer((RvFooterHolder) holder); &#125; else if (isHasHeader() &amp;&amp; position == 0) &#123; bindLisAndData4Header((RvHeaderHolder) holder); &#125; else &#123; int pos = judgePos(position); bindData4View(holder, datas.get(pos), pos, datas.get(pos).getRvType()); &#125; &#125; @Override public int getItemViewType(int position) &#123; //如果没有header没有footer直接返回 if (!isHasHeader() &amp;&amp; !isHasFooter()) return datas.get(position).getRvType(); //有header且位置0 if (isHasHeader() &amp;&amp; position == 0) return TYPE_HEADER; //pos超出 if (isHasFooter() &amp;&amp; position == getItemCount() - 1) return TYPE_FOOTER; //如果有header,下标减一个 if (isHasHeader()) return datas.get(position - 1).getRvType(); else //没有header 按照原来的 return datas.get(position).getRvType(); &#125; private int judgePos(int pos) &#123; if (isHasHeader()) &#123; return pos - 1; &#125; else &#123; return pos; &#125; &#125; @Override public void onAttachedToRecyclerView(RecyclerView recyclerView) &#123; super.onAttachedToRecyclerView(recyclerView); Log.e("chendong","onAttachedToRecyclerView"); RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager(); if (layoutManager instanceof GridLayoutManager) &#123; final GridLayoutManager gridLayoutManager = (GridLayoutManager) layoutManager; gridLayoutManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() &#123; @Override public int getSpanSize(int position) &#123; return getItemViewType(position) == TYPE_HEADER || getItemViewType(position) == TYPE_FOOTER ? gridLayoutManager.getSpanCount() : 1; &#125; &#125;); return; &#125; if(layoutManager instanceof StaggeredGridLayoutManager)&#123; isStaggeredGridLayoutManager = true; &#125; &#125; /** * 绑定数据 * * @param holder ViewHolder数据持有者 * @param data 数据集 * @param pos 数据集中的位置 * @param type type */ public abstract void bindData4View(RvViewHolder holder, D data, int pos, int type); /** * 绑定监听器 * * @param holder ViewHolder数据持有者 * @param type type */ public void bindListener4View(RvViewHolder holder, int type) &#123; &#125; /** * 绑定header的数据 和 监听 * * @param holder header holder */ public void bindLisAndData4Header(RvHeaderHolder holder) &#123; &#125; /** * 绑定footer的数据和监听 * * @param holder footer holder */ public void bindLisAndData4Footer(RvFooterHolder holder) &#123; &#125; @Override public int getItemCount() &#123; int pos = datas.size(); if (isHasHeader()) pos++; if (isHasFooter()) pos++; return pos; &#125; public int getHeaderCount() &#123; return isHasHeader() ? 1 : 0; &#125; public int getDataPos(int pos) &#123; return pos - getHeaderCount(); &#125; private boolean isHasHeader() &#123; return mHeaderView != null; &#125; private boolean isHasFooter() &#123; return mFooterView != null; &#125; /** * @param type 数据的类型(如果有n种类型,那么type的值需要是0 ~ n-1) * @param resId 该类型对应的资源文件的id * @return QuickTypeAdapter */ public RvQuickAdapter&lt;D&gt; addType(int type, int resId) &#123; if (this.Res4Type == null) this.Res4Type = new SparseArray&lt;&gt;(); this.Res4Type.put(type, new RvAdapterConfig(type, resId)); return this; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[汉字转换拼音]]></title>
      <url>%2F2016%2F03%2F28%2F%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%2F%E6%B1%89%E5%AD%97%E8%BD%AC%E6%8D%A2%E6%8B%BC%E9%9F%B3%2F</url>
      <content type="text"><![CDATA[为什么要用？进行汉字的字符串拼配,比较,排序的时候使用汉字很不方便,转换成拼音就可以进行首字母匹配搜索等工作了。 Api调用12345PinyinHelper.get().getPinYin("你好"));PinyinHelper.get().getPinYin("你bSfb");PinyinHelper.get().getPinYin("JHHihubbb"); 核心方法123456789101112131415161718192021//核心方法 /** * 唯一公开的方法 * * @param input 输入的文字 * @return 返回的汉字将会转化为大写英文, 如果是英文将会原样返回 */ public String getPinYin(String input) &#123; ArrayList&lt;Token&gt; tokens = get(input); StringBuilder sb = new StringBuilder(); if (tokens != null &amp;&amp; tokens.size() &gt; 0) &#123; for (Token token : tokens) &#123; if (Token.PINYIN == token.type) &#123; sb.append(token.target); &#125; else &#123; sb.append(token.source); &#125; &#125; &#125; return sb.toString(); &#125; 附源码一份123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532package com.march.libs.helper;/** * CdLibsTest com.march.libs.helper * Created by 陈栋 on 16/3/28. * 功能: */import android.text.TextUtils;import android.util.Log;import java.text.Collator;import java.util.ArrayList;import java.util.Locale;public class PinyinHelper &#123; private static final String TAG = "HanziToPinyin"; private static final boolean DEBUG = false; private static final char[] UNIHANS = &#123; '\u963f', '\u54ce', '\u5b89', '\u80ae', '\u51f9', '\u516b', '\u6300', '\u6273', '\u90a6', '\u52f9', '\u9642', '\u5954', '\u4f3b', '\u5c44', '\u8fb9', '\u706c', '\u618b', '\u6c43', '\u51ab', '\u7676', '\u5cec', '\u5693', '\u5072', '\u53c2', '\u4ed3', '\u64a1', '\u518a', '\u5d7e', '\u66fd', '\u66fe', '\u5c64', '\u53c9', '\u8286', '\u8fbf', '\u4f25', '\u6284', '\u8f66', '\u62bb', '\u6c88', '\u6c89', '\u9637', '\u5403', '\u5145', '\u62bd', '\u51fa', '\u6b3b', '\u63e3', '\u5ddb', '\u5205', '\u5439', '\u65fe', '\u9034', '\u5472', '\u5306', '\u51d1', '\u7c97', '\u6c46', '\u5d14', '\u90a8', '\u6413', '\u5491', '\u5446', '\u4e39', '\u5f53', '\u5200', '\u561a', '\u6265', '\u706f', '\u6c10', '\u55f2', '\u7538', '\u5201', '\u7239', '\u4e01', '\u4e1f', '\u4e1c', '\u543a', '\u53be', '\u8011', '\u8968', '\u5428', '\u591a', '\u59b8', '\u8bf6', '\u5940', '\u97a5', '\u513f', '\u53d1', '\u5e06', '\u531a', '\u98de', '\u5206', '\u4e30', '\u8985', '\u4ecf', '\u7d11', '\u4f15', '\u65ee', '\u4f85', '\u7518', '\u5188', '\u768b', '\u6208', '\u7ed9', '\u6839', '\u522f', '\u5de5', '\u52fe', '\u4f30', '\u74dc', '\u4e56', '\u5173', '\u5149', '\u5f52', '\u4e28', '\u5459', '\u54c8', '\u548d', '\u4f44', '\u592f', '\u8320', '\u8bc3', '\u9ed2', '\u62eb', '\u4ea8', '\u5677', '\u53ff', '\u9f41', '\u4e6f', '\u82b1', '\u6000', '\u72bf', '\u5ddf', '\u7070', '\u660f', '\u5419', '\u4e0c', '\u52a0', '\u620b', '\u6c5f', '\u827d', '\u9636', '\u5dfe', '\u5755', '\u5182', '\u4e29', '\u51e5', '\u59e2', '\u5658', '\u519b', '\u5494', '\u5f00', '\u520a', '\u5ffc', '\u5c3b', '\u533c', '\u808e', '\u52a5', '\u7a7a', '\u62a0', '\u625d', '\u5938', '\u84af', '\u5bbd', '\u5321', '\u4e8f', '\u5764', '\u6269', '\u5783', '\u6765', '\u5170', '\u5577', '\u635e', '\u808b', '\u52d2', '\u5d1a', '\u5215', '\u4fe9', '\u5941', '\u826f', '\u64a9', '\u5217', '\u62ce', '\u5222', '\u6e9c', '\u56d6', '\u9f99', '\u779c', '\u565c', '\u5a08', '\u7567', '\u62a1', '\u7f57', '\u5463', '\u5988', '\u57cb', '\u5ada', '\u7264', '\u732b', '\u4e48', '\u5445', '\u95e8', '\u753f', '\u54aa', '\u5b80', '\u55b5', '\u4e5c', '\u6c11', '\u540d', '\u8c2c', '\u6478', '\u54de', '\u6bea', '\u55ef', '\u62cf', '\u8149', '\u56e1', '\u56d4', '\u5b6c', '\u7592', '\u5a1e', '\u6041', '\u80fd', '\u59ae', '\u62c8', '\u5b22', '\u9e1f', '\u634f', '\u56dc', '\u5b81', '\u599e', '\u519c', '\u7fba', '\u5974', '\u597b', '\u759f', '\u9ec1', '\u90cd', '\u5594', '\u8bb4', '\u5991', '\u62cd', '\u7705', '\u4e53', '\u629b', '\u5478', '\u55b7', '\u5309', '\u4e15', '\u56e8', '\u527d', '\u6c15', '\u59d8', '\u4e52', '\u948b', '\u5256', '\u4ec6', '\u4e03', '\u6390', '\u5343', '\u545b', '\u6084', '\u767f', '\u4eb2', '\u72c5', '\u828e', '\u4e18', '\u533a', '\u5cd1', '\u7f3a', '\u590b', '\u5465', '\u7a63', '\u5a06', '\u60f9', '\u4eba', '\u6254', '\u65e5', '\u8338', '\u53b9', '\u909a', '\u633c', '\u5827', '\u5a51', '\u77a4', '\u637c', '\u4ee8', '\u6be2', '\u4e09', '\u6852', '\u63bb', '\u95aa', '\u68ee', '\u50e7', '\u6740', '\u7b5b', '\u5c71', '\u4f24', '\u5f30', '\u5962', '\u7533', '\u8398', '\u6552', '\u5347', '\u5c38', '\u53ce', '\u4e66', '\u5237', '\u8870', '\u95e9', '\u53cc', '\u8c01', '\u542e', '\u8bf4', '\u53b6', '\u5fea', '\u635c', '\u82cf', '\u72fb', '\u590a', '\u5b59', '\u5506', '\u4ed6', '\u56fc', '\u574d', '\u6c64', '\u5932', '\u5fd1', '\u71a5', '\u5254', '\u5929', '\u65eb', '\u5e16', '\u5385', '\u56f2', '\u5077', '\u51f8', '\u6e4d', '\u63a8', '\u541e', '\u4e47', '\u7a75', '\u6b6a', '\u5f2f', '\u5c23', '\u5371', '\u6637', '\u7fc1', '\u631d', '\u4e4c', '\u5915', '\u8672', '\u4eda', '\u4e61', '\u7071', '\u4e9b', '\u5fc3', '\u661f', '\u51f6', '\u4f11', '\u5401', '\u5405', '\u524a', '\u5743', '\u4e2b', '\u6079', '\u592e', '\u5e7a', '\u503b', '\u4e00', '\u56d9', '\u5e94', '\u54df', '\u4f63', '\u4f18', '\u625c', '\u56e6', '\u66f0', '\u6655', '\u7b60', '\u7b7c', '\u5e00', '\u707d', '\u5142', '\u5328', '\u50ae', '\u5219', '\u8d3c', '\u600e', '\u5897', '\u624e', '\u635a', '\u6cbe', '\u5f20', '\u957f', '\u9577', '\u4f4b', '\u8707', '\u8d1e', '\u4e89', '\u4e4b', '\u5cd9', '\u5ea2', '\u4e2d', '\u5dde', '\u6731', '\u6293', '\u62fd', '\u4e13', '\u5986', '\u96b9', '\u5b92', '\u5353', '\u4e72', '\u5b97', '\u90b9', '\u79df', '\u94bb', '\u539c', '\u5c0a', '\u6628', '\u5159', '\u9fc3', '\u9fc4',&#125;; private static final byte[][] PINYINS = &#123; &#123;65, 0, 0, 0, 0, 0&#125;, &#123;65, 73, 0, 0, 0, 0&#125;, &#123;65, 78, 0, 0, 0, 0&#125;, &#123;65, 78, 71, 0, 0, 0&#125;, &#123;65, 79, 0, 0, 0, 0&#125;, &#123;66, 65, 0, 0, 0, 0&#125;, &#123;66, 65, 73, 0, 0, 0&#125;, &#123;66, 65, 78, 0, 0, 0&#125;, &#123;66, 65, 78, 71, 0, 0&#125;, &#123;66, 65, 79, 0, 0, 0&#125;, &#123;66, 69, 73, 0, 0, 0&#125;, &#123;66, 69, 78, 0, 0, 0&#125;, &#123;66, 69, 78, 71, 0, 0&#125;, &#123;66, 73, 0, 0, 0, 0&#125;, &#123;66, 73, 65, 78, 0, 0&#125;, &#123;66, 73, 65, 79, 0, 0&#125;, &#123;66, 73, 69, 0, 0, 0&#125;, &#123;66, 73, 78, 0, 0, 0&#125;, &#123;66, 73, 78, 71, 0, 0&#125;, &#123;66, 79, 0, 0, 0, 0&#125;, &#123;66, 85, 0, 0, 0, 0&#125;, &#123;67, 65, 0, 0, 0, 0&#125;, &#123;67, 65, 73, 0, 0, 0&#125;, &#123;67, 65, 78, 0, 0, 0&#125;, &#123;67, 65, 78, 71, 0, 0&#125;, &#123;67, 65, 79, 0, 0, 0&#125;, &#123;67, 69, 0, 0, 0, 0&#125;, &#123;67, 69, 78, 0, 0, 0&#125;, &#123;67, 69, 78, 71, 0, 0&#125;, &#123;90, 69, 78, 71, 0, 0&#125;, &#123;67, 69, 78, 71, 0, 0&#125;, &#123;67, 72, 65, 0, 0, 0&#125;, &#123;67, 72, 65, 73, 0, 0&#125;, &#123;67, 72, 65, 78, 0, 0&#125;, &#123;67, 72, 65, 78, 71, 0&#125;, &#123;67, 72, 65, 79, 0, 0&#125;, &#123;67, 72, 69, 0, 0, 0&#125;, &#123;67, 72, 69, 78, 0, 0&#125;, &#123;83, 72, 69, 78, 0, 0&#125;, &#123;67, 72, 69, 78, 0, 0&#125;, &#123;67, 72, 69, 78, 71, 0&#125;, &#123;67, 72, 73, 0, 0, 0&#125;, &#123;67, 72, 79, 78, 71, 0&#125;, &#123;67, 72, 79, 85, 0, 0&#125;, &#123;67, 72, 85, 0, 0, 0&#125;, &#123;67, 72, 85, 65, 0, 0&#125;, &#123;67, 72, 85, 65, 73, 0&#125;, &#123;67, 72, 85, 65, 78, 0&#125;, &#123;67, 72, 85, 65, 78, 71&#125;, &#123;67, 72, 85, 73, 0, 0&#125;, &#123;67, 72, 85, 78, 0, 0&#125;, &#123;67, 72, 85, 79, 0, 0&#125;, &#123;67, 73, 0, 0, 0, 0&#125;, &#123;67, 79, 78, 71, 0, 0&#125;, &#123;67, 79, 85, 0, 0, 0&#125;, &#123;67, 85, 0, 0, 0, 0&#125;, &#123;67, 85, 65, 78, 0, 0&#125;, &#123;67, 85, 73, 0, 0, 0&#125;, &#123;67, 85, 78, 0, 0, 0&#125;, &#123;67, 85, 79, 0, 0, 0&#125;, &#123;68, 65, 0, 0, 0, 0&#125;, &#123;68, 65, 73, 0, 0, 0&#125;, &#123;68, 65, 78, 0, 0, 0&#125;, &#123;68, 65, 78, 71, 0, 0&#125;, &#123;68, 65, 79, 0, 0, 0&#125;, &#123;68, 69, 0, 0, 0, 0&#125;, &#123;68, 69, 78, 0, 0, 0&#125;, &#123;68, 69, 78, 71, 0, 0&#125;, &#123;68, 73, 0, 0, 0, 0&#125;, &#123;68, 73, 65, 0, 0, 0&#125;, &#123;68, 73, 65, 78, 0, 0&#125;, &#123;68, 73, 65, 79, 0, 0&#125;, &#123;68, 73, 69, 0, 0, 0&#125;, &#123;68, 73, 78, 71, 0, 0&#125;, &#123;68, 73, 85, 0, 0, 0&#125;, &#123;68, 79, 78, 71, 0, 0&#125;, &#123;68, 79, 85, 0, 0, 0&#125;, &#123;68, 85, 0, 0, 0, 0&#125;, &#123;68, 85, 65, 78, 0, 0&#125;, &#123;68, 85, 73, 0, 0, 0&#125;, &#123;68, 85, 78, 0, 0, 0&#125;, &#123;68, 85, 79, 0, 0, 0&#125;, &#123;69, 0, 0, 0, 0, 0&#125;, &#123;69, 73, 0, 0, 0, 0&#125;, &#123;69, 78, 0, 0, 0, 0&#125;, &#123;69, 78, 71, 0, 0, 0&#125;, &#123;69, 82, 0, 0, 0, 0&#125;, &#123;70, 65, 0, 0, 0, 0&#125;, &#123;70, 65, 78, 0, 0, 0&#125;, &#123;70, 65, 78, 71, 0, 0&#125;, &#123;70, 69, 73, 0, 0, 0&#125;, &#123;70, 69, 78, 0, 0, 0&#125;, &#123;70, 69, 78, 71, 0, 0&#125;, &#123;70, 73, 65, 79, 0, 0&#125;, &#123;70, 79, 0, 0, 0, 0&#125;, &#123;70, 79, 85, 0, 0, 0&#125;, &#123;70, 85, 0, 0, 0, 0&#125;, &#123;71, 65, 0, 0, 0, 0&#125;, &#123;71, 65, 73, 0, 0, 0&#125;, &#123;71, 65, 78, 0, 0, 0&#125;, &#123;71, 65, 78, 71, 0, 0&#125;, &#123;71, 65, 79, 0, 0, 0&#125;, &#123;71, 69, 0, 0, 0, 0&#125;, &#123;71, 69, 73, 0, 0, 0&#125;, &#123;71, 69, 78, 0, 0, 0&#125;, &#123;71, 69, 78, 71, 0, 0&#125;, &#123;71, 79, 78, 71, 0, 0&#125;, &#123;71, 79, 85, 0, 0, 0&#125;, &#123;71, 85, 0, 0, 0, 0&#125;, &#123;71, 85, 65, 0, 0, 0&#125;, &#123;71, 85, 65, 73, 0, 0&#125;, &#123;71, 85, 65, 78, 0, 0&#125;, &#123;71, 85, 65, 78, 71, 0&#125;, &#123;71, 85, 73, 0, 0, 0&#125;, &#123;71, 85, 78, 0, 0, 0&#125;, &#123;71, 85, 79, 0, 0, 0&#125;, &#123;72, 65, 0, 0, 0, 0&#125;, &#123;72, 65, 73, 0, 0, 0&#125;, &#123;72, 65, 78, 0, 0, 0&#125;, &#123;72, 65, 78, 71, 0, 0&#125;, &#123;72, 65, 79, 0, 0, 0&#125;, &#123;72, 69, 0, 0, 0, 0&#125;, &#123;72, 69, 73, 0, 0, 0&#125;, &#123;72, 69, 78, 0, 0, 0&#125;, &#123;72, 69, 78, 71, 0, 0&#125;, &#123;72, 77, 0, 0, 0, 0&#125;, &#123;72, 79, 78, 71, 0, 0&#125;, &#123;72, 79, 85, 0, 0, 0&#125;, &#123;72, 85, 0, 0, 0, 0&#125;, &#123;72, 85, 65, 0, 0, 0&#125;, &#123;72, 85, 65, 73, 0, 0&#125;, &#123;72, 85, 65, 78, 0, 0&#125;, &#123;72, 85, 65, 78, 71, 0&#125;, &#123;72, 85, 73, 0, 0, 0&#125;, &#123;72, 85, 78, 0, 0, 0&#125;, &#123;72, 85, 79, 0, 0, 0&#125;, &#123;74, 73, 0, 0, 0, 0&#125;, &#123;74, 73, 65, 0, 0, 0&#125;, &#123;74, 73, 65, 78, 0, 0&#125;, &#123;74, 73, 65, 78, 71, 0&#125;, &#123;74, 73, 65, 79, 0, 0&#125;, &#123;74, 73, 69, 0, 0, 0&#125;, &#123;74, 73, 78, 0, 0, 0&#125;, &#123;74, 73, 78, 71, 0, 0&#125;, &#123;74, 73, 79, 78, 71, 0&#125;, &#123;74, 73, 85, 0, 0, 0&#125;, &#123;74, 85, 0, 0, 0, 0&#125;, &#123;74, 85, 65, 78, 0, 0&#125;, &#123;74, 85, 69, 0, 0, 0&#125;, &#123;74, 85, 78, 0, 0, 0&#125;, &#123;75, 65, 0, 0, 0, 0&#125;, &#123;75, 65, 73, 0, 0, 0&#125;, &#123;75, 65, 78, 0, 0, 0&#125;, &#123;75, 65, 78, 71, 0, 0&#125;, &#123;75, 65, 79, 0, 0, 0&#125;, &#123;75, 69, 0, 0, 0, 0&#125;, &#123;75, 69, 78, 0, 0, 0&#125;, &#123;75, 69, 78, 71, 0, 0&#125;, &#123;75, 79, 78, 71, 0, 0&#125;, &#123;75, 79, 85, 0, 0, 0&#125;, &#123;75, 85, 0, 0, 0, 0&#125;, &#123;75, 85, 65, 0, 0, 0&#125;, &#123;75, 85, 65, 73, 0, 0&#125;, &#123;75, 85, 65, 78, 0, 0&#125;, &#123;75, 85, 65, 78, 71, 0&#125;, &#123;75, 85, 73, 0, 0, 0&#125;, &#123;75, 85, 78, 0, 0, 0&#125;, &#123;75, 85, 79, 0, 0, 0&#125;, &#123;76, 65, 0, 0, 0, 0&#125;, &#123;76, 65, 73, 0, 0, 0&#125;, &#123;76, 65, 78, 0, 0, 0&#125;, &#123;76, 65, 78, 71, 0, 0&#125;, &#123;76, 65, 79, 0, 0, 0&#125;, &#123;76, 69, 0, 0, 0, 0&#125;, &#123;76, 69, 73, 0, 0, 0&#125;, &#123;76, 69, 78, 71, 0, 0&#125;, &#123;76, 73, 0, 0, 0, 0&#125;, &#123;76, 73, 65, 0, 0, 0&#125;, &#123;76, 73, 65, 78, 0, 0&#125;, &#123;76, 73, 65, 78, 71, 0&#125;, &#123;76, 73, 65, 79, 0, 0&#125;, &#123;76, 73, 69, 0, 0, 0&#125;, &#123;76, 73, 78, 0, 0, 0&#125;, &#123;76, 73, 78, 71, 0, 0&#125;, &#123;76, 73, 85, 0, 0, 0&#125;, &#123;76, 79, 0, 0, 0, 0&#125;, &#123;76, 79, 78, 71, 0, 0&#125;, &#123;76, 79, 85, 0, 0, 0&#125;, &#123;76, 85, 0, 0, 0, 0&#125;, &#123;76, 85, 65, 78, 0, 0&#125;, &#123;76, 85, 69, 0, 0, 0&#125;, &#123;76, 85, 78, 0, 0, 0&#125;, &#123;76, 85, 79, 0, 0, 0&#125;, &#123;77, 0, 0, 0, 0, 0&#125;, &#123;77, 65, 0, 0, 0, 0&#125;, &#123;77, 65, 73, 0, 0, 0&#125;, &#123;77, 65, 78, 0, 0, 0&#125;, &#123;77, 65, 78, 71, 0, 0&#125;, &#123;77, 65, 79, 0, 0, 0&#125;, &#123;77, 69, 0, 0, 0, 0&#125;, &#123;77, 69, 73, 0, 0, 0&#125;, &#123;77, 69, 78, 0, 0, 0&#125;, &#123;77, 69, 78, 71, 0, 0&#125;, &#123;77, 73, 0, 0, 0, 0&#125;, &#123;77, 73, 65, 78, 0, 0&#125;, &#123;77, 73, 65, 79, 0, 0&#125;, &#123;77, 73, 69, 0, 0, 0&#125;, &#123;77, 73, 78, 0, 0, 0&#125;, &#123;77, 73, 78, 71, 0, 0&#125;, &#123;77, 73, 85, 0, 0, 0&#125;, &#123;77, 79, 0, 0, 0, 0&#125;, &#123;77, 79, 85, 0, 0, 0&#125;, &#123;77, 85, 0, 0, 0, 0&#125;, &#123;78, 0, 0, 0, 0, 0&#125;, &#123;78, 65, 0, 0, 0, 0&#125;, &#123;78, 65, 73, 0, 0, 0&#125;, &#123;78, 65, 78, 0, 0, 0&#125;, &#123;78, 65, 78, 71, 0, 0&#125;, &#123;78, 65, 79, 0, 0, 0&#125;, &#123;78, 69, 0, 0, 0, 0&#125;, &#123;78, 69, 73, 0, 0, 0&#125;, &#123;78, 69, 78, 0, 0, 0&#125;, &#123;78, 69, 78, 71, 0, 0&#125;, &#123;78, 73, 0, 0, 0, 0&#125;, &#123;78, 73, 65, 78, 0, 0&#125;, &#123;78, 73, 65, 78, 71, 0&#125;, &#123;78, 73, 65, 79, 0, 0&#125;, &#123;78, 73, 69, 0, 0, 0&#125;, &#123;78, 73, 78, 0, 0, 0&#125;, &#123;78, 73, 78, 71, 0, 0&#125;, &#123;78, 73, 85, 0, 0, 0&#125;, &#123;78, 79, 78, 71, 0, 0&#125;, &#123;78, 79, 85, 0, 0, 0&#125;, &#123;78, 85, 0, 0, 0, 0&#125;, &#123;78, 85, 65, 78, 0, 0&#125;, &#123;78, 85, 69, 0, 0, 0&#125;, &#123;78, 85, 78, 0, 0, 0&#125;, &#123;78, 85, 79, 0, 0, 0&#125;, &#123;79, 0, 0, 0, 0, 0&#125;, &#123;79, 85, 0, 0, 0, 0&#125;, &#123;80, 65, 0, 0, 0, 0&#125;, &#123;80, 65, 73, 0, 0, 0&#125;, &#123;80, 65, 78, 0, 0, 0&#125;, &#123;80, 65, 78, 71, 0, 0&#125;, &#123;80, 65, 79, 0, 0, 0&#125;, &#123;80, 69, 73, 0, 0, 0&#125;, &#123;80, 69, 78, 0, 0, 0&#125;, &#123;80, 69, 78, 71, 0, 0&#125;, &#123;80, 73, 0, 0, 0, 0&#125;, &#123;80, 73, 65, 78, 0, 0&#125;, &#123;80, 73, 65, 79, 0, 0&#125;, &#123;80, 73, 69, 0, 0, 0&#125;, &#123;80, 73, 78, 0, 0, 0&#125;, &#123;80, 73, 78, 71, 0, 0&#125;, &#123;80, 79, 0, 0, 0, 0&#125;, &#123;80, 79, 85, 0, 0, 0&#125;, &#123;80, 85, 0, 0, 0, 0&#125;, &#123;81, 73, 0, 0, 0, 0&#125;, &#123;81, 73, 65, 0, 0, 0&#125;, &#123;81, 73, 65, 78, 0, 0&#125;, &#123;81, 73, 65, 78, 71, 0&#125;, &#123;81, 73, 65, 79, 0, 0&#125;, &#123;81, 73, 69, 0, 0, 0&#125;, &#123;81, 73, 78, 0, 0, 0&#125;, &#123;81, 73, 78, 71, 0, 0&#125;, &#123;81, 73, 79, 78, 71, 0&#125;, &#123;81, 73, 85, 0, 0, 0&#125;, &#123;81, 85, 0, 0, 0, 0&#125;, &#123;81, 85, 65, 78, 0, 0&#125;, &#123;81, 85, 69, 0, 0, 0&#125;, &#123;81, 85, 78, 0, 0, 0&#125;, &#123;82, 65, 78, 0, 0, 0&#125;, &#123;82, 65, 78, 71, 0, 0&#125;, &#123;82, 65, 79, 0, 0, 0&#125;, &#123;82, 69, 0, 0, 0, 0&#125;, &#123;82, 69, 78, 0, 0, 0&#125;, &#123;82, 69, 78, 71, 0, 0&#125;, &#123;82, 73, 0, 0, 0, 0&#125;, &#123;82, 79, 78, 71, 0, 0&#125;, &#123;82, 79, 85, 0, 0, 0&#125;, &#123;82, 85, 0, 0, 0, 0&#125;, &#123;82, 85, 65, 0, 0, 0&#125;, &#123;82, 85, 65, 78, 0, 0&#125;, &#123;82, 85, 73, 0, 0, 0&#125;, &#123;82, 85, 78, 0, 0, 0&#125;, &#123;82, 85, 79, 0, 0, 0&#125;, &#123;83, 65, 0, 0, 0, 0&#125;, &#123;83, 65, 73, 0, 0, 0&#125;, &#123;83, 65, 78, 0, 0, 0&#125;, &#123;83, 65, 78, 71, 0, 0&#125;, &#123;83, 65, 79, 0, 0, 0&#125;, &#123;83, 69, 0, 0, 0, 0&#125;, &#123;83, 69, 78, 0, 0, 0&#125;, &#123;83, 69, 78, 71, 0, 0&#125;, &#123;83, 72, 65, 0, 0, 0&#125;, &#123;83, 72, 65, 73, 0, 0&#125;, &#123;83, 72, 65, 78, 0, 0&#125;, &#123;83, 72, 65, 78, 71, 0&#125;, &#123;83, 72, 65, 79, 0, 0&#125;, &#123;83, 72, 69, 0, 0, 0&#125;, &#123;83, 72, 69, 78, 0, 0&#125;, &#123;88, 73, 78, 0, 0, 0&#125;, &#123;83, 72, 69, 78, 0, 0&#125;, &#123;83, 72, 69, 78, 71, 0&#125;, &#123;83, 72, 73, 0, 0, 0&#125;, &#123;83, 72, 79, 85, 0, 0&#125;, &#123;83, 72, 85, 0, 0, 0&#125;, &#123;83, 72, 85, 65, 0, 0&#125;, &#123;83, 72, 85, 65, 73, 0&#125;, &#123;83, 72, 85, 65, 78, 0&#125;, &#123;83, 72, 85, 65, 78, 71&#125;, &#123;83, 72, 85, 73, 0, 0&#125;, &#123;83, 72, 85, 78, 0, 0&#125;, &#123;83, 72, 85, 79, 0, 0&#125;, &#123;83, 73, 0, 0, 0, 0&#125;, &#123;83, 79, 78, 71, 0, 0&#125;, &#123;83, 79, 85, 0, 0, 0&#125;, &#123;83, 85, 0, 0, 0, 0&#125;, &#123;83, 85, 65, 78, 0, 0&#125;, &#123;83, 85, 73, 0, 0, 0&#125;, &#123;83, 85, 78, 0, 0, 0&#125;, &#123;83, 85, 79, 0, 0, 0&#125;, &#123;84, 65, 0, 0, 0, 0&#125;, &#123;84, 65, 73, 0, 0, 0&#125;, &#123;84, 65, 78, 0, 0, 0&#125;, &#123;84, 65, 78, 71, 0, 0&#125;, &#123;84, 65, 79, 0, 0, 0&#125;, &#123;84, 69, 0, 0, 0, 0&#125;, &#123;84, 69, 78, 71, 0, 0&#125;, &#123;84, 73, 0, 0, 0, 0&#125;, &#123;84, 73, 65, 78, 0, 0&#125;, &#123;84, 73, 65, 79, 0, 0&#125;, &#123;84, 73, 69, 0, 0, 0&#125;, &#123;84, 73, 78, 71, 0, 0&#125;, &#123;84, 79, 78, 71, 0, 0&#125;, &#123;84, 79, 85, 0, 0, 0&#125;, &#123;84, 85, 0, 0, 0, 0&#125;, &#123;84, 85, 65, 78, 0, 0&#125;, &#123;84, 85, 73, 0, 0, 0&#125;, &#123;84, 85, 78, 0, 0, 0&#125;, &#123;84, 85, 79, 0, 0, 0&#125;, &#123;87, 65, 0, 0, 0, 0&#125;, &#123;87, 65, 73, 0, 0, 0&#125;, &#123;87, 65, 78, 0, 0, 0&#125;, &#123;87, 65, 78, 71, 0, 0&#125;, &#123;87, 69, 73, 0, 0, 0&#125;, &#123;87, 69, 78, 0, 0, 0&#125;, &#123;87, 69, 78, 71, 0, 0&#125;, &#123;87, 79, 0, 0, 0, 0&#125;, &#123;87, 85, 0, 0, 0, 0&#125;, &#123;88, 73, 0, 0, 0, 0&#125;, &#123;88, 73, 65, 0, 0, 0&#125;, &#123;88, 73, 65, 78, 0, 0&#125;, &#123;88, 73, 65, 78, 71, 0&#125;, &#123;88, 73, 65, 79, 0, 0&#125;, &#123;88, 73, 69, 0, 0, 0&#125;, &#123;88, 73, 78, 0, 0, 0&#125;, &#123;88, 73, 78, 71, 0, 0&#125;, &#123;88, 73, 79, 78, 71, 0&#125;, &#123;88, 73, 85, 0, 0, 0&#125;, &#123;88, 85, 0, 0, 0, 0&#125;, &#123;88, 85, 65, 78, 0, 0&#125;, &#123;88, 85, 69, 0, 0, 0&#125;, &#123;88, 85, 78, 0, 0, 0&#125;, &#123;89, 65, 0, 0, 0, 0&#125;, &#123;89, 65, 78, 0, 0, 0&#125;, &#123;89, 65, 78, 71, 0, 0&#125;, &#123;89, 65, 79, 0, 0, 0&#125;, &#123;89, 69, 0, 0, 0, 0&#125;, &#123;89, 73, 0, 0, 0, 0&#125;, &#123;89, 73, 78, 0, 0, 0&#125;, &#123;89, 73, 78, 71, 0, 0&#125;, &#123;89, 79, 0, 0, 0, 0&#125;, &#123;89, 79, 78, 71, 0, 0&#125;, &#123;89, 79, 85, 0, 0, 0&#125;, &#123;89, 85, 0, 0, 0, 0&#125;, &#123;89, 85, 65, 78, 0, 0&#125;, &#123;89, 85, 69, 0, 0, 0&#125;, &#123;89, 85, 78, 0, 0, 0&#125;, &#123;74, 85, 78, 0, 0, 0&#125;, &#123;89, 85, 78, 0, 0, 0&#125;, &#123;90, 65, 0, 0, 0, 0&#125;, &#123;90, 65, 73, 0, 0, 0&#125;, &#123;90, 65, 78, 0, 0, 0&#125;, &#123;90, 65, 78, 71, 0, 0&#125;, &#123;90, 65, 79, 0, 0, 0&#125;, &#123;90, 69, 0, 0, 0, 0&#125;, &#123;90, 69, 73, 0, 0, 0&#125;, &#123;90, 69, 78, 0, 0, 0&#125;, &#123;90, 69, 78, 71, 0, 0&#125;, &#123;90, 72, 65, 0, 0, 0&#125;, &#123;90, 72, 65, 73, 0, 0&#125;, &#123;90, 72, 65, 78, 0, 0&#125;, &#123;90, 72, 65, 78, 71, 0&#125;, &#123;67, 72, 65, 78, 71, 0&#125;, &#123;90, 72, 65, 78, 71, 0&#125;, &#123;90, 72, 65, 79, 0, 0&#125;, &#123;90, 72, 69, 0, 0, 0&#125;, &#123;90, 72, 69, 78, 0, 0&#125;, &#123;90, 72, 69, 78, 71, 0&#125;, &#123;90, 72, 73, 0, 0, 0&#125;, &#123;83, 72, 73, 0, 0, 0&#125;, &#123;90, 72, 73, 0, 0, 0&#125;, &#123;90, 72, 79, 78, 71, 0&#125;, &#123;90, 72, 79, 85, 0, 0&#125;, &#123;90, 72, 85, 0, 0, 0&#125;, &#123;90, 72, 85, 65, 0, 0&#125;, &#123;90, 72, 85, 65, 73, 0&#125;, &#123;90, 72, 85, 65, 78, 0&#125;, &#123;90, 72, 85, 65, 78, 71&#125;, &#123;90, 72, 85, 73, 0, 0&#125;, &#123;90, 72, 85, 78, 0, 0&#125;, &#123;90, 72, 85, 79, 0, 0&#125;, &#123;90, 73, 0, 0, 0, 0&#125;, &#123;90, 79, 78, 71, 0, 0&#125;, &#123;90, 79, 85, 0, 0, 0&#125;, &#123;90, 85, 0, 0, 0, 0&#125;, &#123;90, 85, 65, 78, 0, 0&#125;, &#123;90, 85, 73, 0, 0, 0&#125;, &#123;90, 85, 78, 0, 0, 0&#125;, &#123;90, 85, 79, 0, 0, 0&#125;, &#123;0, 0, 0, 0, 0, 0&#125;, &#123;83, 72, 65, 78, 0, 0&#125;, &#123;0, 0, 0, 0, 0, 0&#125;,&#125;; /** * First and last Chinese character with known Pinyin according to zh collation */ private static final String FIRST_PINYIN_UNIHAN = "\u963F"; private static final String LAST_PINYIN_UNIHAN = "\u9FFF"; private static final Collator COLLATOR = Collator.getInstance(Locale.CHINA); private static PinyinHelper sInstance; private final boolean mHasChinaCollator; public static class Token &#123; /** * Separator between target string for each source char */ public static final String SEPARATOR = " "; public static final int LATIN = 1; public static final int PINYIN = 2; public static final int UNKNOWN = 3; public Token() &#123; &#125; public Token(int type, String source, String target) &#123; this.type = type; this.source = source; this.target = target; &#125; /** * Type of this token, ASCII, PINYIN or UNKNOWN. */ public int type; /** * Original string before translation. */ public String source; /** * Translated string of source. For Han, target is corresponding Pinyin. Otherwise target is * original string in source. */ public String target; &#125; protected PinyinHelper(boolean hasChinaCollator) &#123; mHasChinaCollator = hasChinaCollator; &#125; public static PinyinHelper get() &#123; synchronized (PinyinHelper.class) &#123; if (sInstance != null) &#123; return sInstance; &#125; final Locale locale[] = Collator.getAvailableLocales(); for (int i = 0; i &lt; locale.length; i++) &#123; if (locale[i].equals(Locale.CHINA)) &#123; // Do self validation just once. if (DEBUG) &#123; Log.d(TAG, "Self validation. Result: " + doSelfValidation()); &#125; sInstance = new PinyinHelper(true); return sInstance; &#125; &#125; sInstance = new PinyinHelper(true); return sInstance; &#125; &#125; private static boolean doSelfValidation() &#123; char lastChar = UNIHANS[0]; String lastString = Character.toString(lastChar); for (char c : UNIHANS) &#123; if (lastChar == c) &#123; continue; &#125; final String curString = Character.toString(c); int cmp = COLLATOR.compare(lastString, curString); if (cmp &gt;= 0) &#123; return false; &#125; lastString = curString; &#125; return true; &#125; private Token getToken(char character) &#123; Token token = new Token(); final String letter = Character.toString(character); token.source = letter; int offset = -1; int cmp; if (character &lt; 256) &#123; token.type = Token.LATIN; token.target = letter; return token; &#125; else &#123; cmp = COLLATOR.compare(letter, FIRST_PINYIN_UNIHAN); if (cmp &lt; 0) &#123; token.type = Token.UNKNOWN; token.target = letter; return token; &#125; else if (cmp == 0) &#123; token.type = Token.PINYIN; offset = 0; &#125; else &#123; cmp = COLLATOR.compare(letter, LAST_PINYIN_UNIHAN); if (cmp &gt; 0) &#123; token.type = Token.UNKNOWN; token.target = letter; return token; &#125; else if (cmp == 0) &#123; token.type = Token.PINYIN; offset = UNIHANS.length - 1; &#125; &#125; &#125; token.type = Token.PINYIN; if (offset &lt; 0) &#123; int begin = 0; int end = UNIHANS.length - 1; while (begin &lt;= end) &#123; offset = (begin + end) / 2; final String unihan = Character.toString(UNIHANS[offset]); cmp = COLLATOR.compare(letter, unihan); if (cmp == 0) &#123; break; &#125; else if (cmp &gt; 0) &#123; begin = offset + 1; &#125; else &#123; end = offset - 1; &#125; &#125; &#125; if (cmp &lt; 0) &#123; offset--; &#125; StringBuilder pinyin = new StringBuilder(); for (int j = 0; j &lt; PINYINS[offset].length &amp;&amp; PINYINS[offset][j] != 0; j++) &#123; pinyin.append((char) PINYINS[offset][j]); &#125; token.target = pinyin.toString(); if (TextUtils.isEmpty(token.target)) &#123; token.type = Token.UNKNOWN; token.target = token.source; &#125; return token; &#125; private ArrayList&lt;Token&gt; get(final String input) &#123; ArrayList&lt;Token&gt; tokens = new ArrayList&lt;Token&gt;(); if (!mHasChinaCollator || TextUtils.isEmpty(input)) &#123; // return empty tokens. return tokens; &#125; final int inputLength = input.length(); final StringBuilder sb = new StringBuilder(); int tokenType = Token.LATIN; for (int i = 0; i &lt; inputLength; i++) &#123; final char character = input.charAt(i); if (character == ' ') &#123; if (sb.length() &gt; 0) &#123; addToken(sb, tokens, tokenType); &#125; &#125; else if (character &lt; 256) &#123; if (tokenType != Token.LATIN &amp;&amp; sb.length() &gt; 0) &#123; addToken(sb, tokens, tokenType); &#125; tokenType = Token.LATIN; sb.append(character); &#125; else &#123; Token t = getToken(character); if (t.type == Token.PINYIN) &#123; if (sb.length() &gt; 0) &#123; addToken(sb, tokens, tokenType); &#125; tokens.add(t); tokenType = Token.PINYIN; &#125; else &#123; if (tokenType != t.type &amp;&amp; sb.length() &gt; 0) &#123; addToken(sb, tokens, tokenType); &#125; tokenType = t.type; sb.append(character); &#125; &#125; &#125; if (sb.length() &gt; 0) &#123; addToken(sb, tokens, tokenType); &#125; return tokens; &#125; private void addToken( final StringBuilder sb, final ArrayList&lt;Token&gt; tokens, final int tokenType) &#123; String str = sb.toString(); tokens.add(new Token(tokenType, str, str)); sb.setLength(0); &#125; /** * 唯一公开的方法 * * @param input 输入的文字 * @return 返回的汉字将会转化为大写英文, 如果是英文将会原样返回 */ public String getPinYin(String input) &#123; ArrayList&lt;Token&gt; tokens = get(input); StringBuilder sb = new StringBuilder(); if (tokens != null &amp;&amp; tokens.size() &gt; 0) &#123; for (Token token : tokens) &#123; if (Token.PINYIN == token.type) &#123; sb.append(token.target); &#125; else &#123; sb.append(token.source); &#125; &#125; &#125; return sb.toString(); &#125;&#125; ##以上]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android系统分享的注册和调起]]></title>
      <url>%2F2016%2F03%2F24%2FAndroid%E5%BC%80%E5%8F%91%2FAndroid%E7%B3%BB%E7%BB%9F%E5%88%86%E4%BA%AB%E7%9A%84%E6%B3%A8%E5%86%8C%E5%92%8C%E8%B0%83%E8%B5%B7%2F</url>
      <content type="text"><![CDATA[前言 现在有很多第三方分享平台，比如友盟，shareSdk等，其实我们在相册长按图片点击发送／分享就会调起很多应用，让你选择可以分享到很多平台，比如QQ，微信等，相对使用第三方要简陋一点，但是因为是系统的集成起来也相对简单。 注册系统的分享需要在manifest文件声明&lt;intent-filter&gt;，使得你可以在用户点击分享／发送按钮时调起你的应用，将图片和文字分享到你的App. 1234567891011121314151617181920212223&lt;activity android:name=".activity.SysShareActivity" android:label="我的分享" android:theme="@style/AppTheme.NoActionBar"&gt; //注册分享文字 &lt;intent-filter&gt; &lt;action android:name="android.intent.action.SEND"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:mimeType="image/*"/&gt; &lt;/intent-filter&gt; //注册分享单张图片 &lt;intent-filter&gt; &lt;action android:name="android.intent.action.SEND"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:mimeType="text/plain"/&gt; &lt;/intent-filter&gt; //注册分享多张图片 &lt;intent-filter&gt; &lt;action android:name="android.intent.action.SEND_MULTIPLE"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:mimeType="image/*"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155public class ShareSysUtils &#123; public static ShareSysUtils sysShareUtils; private Activity activity; private OnShareDataOkListener listener; public static int TYPE_TEXT = 0, TYPE_IMAGE = 1; public ShareSysUtils(Activity activity) &#123; this.activity = activity; &#125; public static ShareSysUtils get(Activity activity) &#123; if (sysShareUtils == null) &#123; synchronized (ShareSysUtils.class) &#123; if (sysShareUtils == null) &#123; sysShareUtils = new ShareSysUtils(activity); &#125; &#125; &#125; return sysShareUtils; &#125; /** * 作为接受分享的一方,处理分享来的数据 * * @param listener 处理监听,数据处理好之后会返回 */ public void handleShare(OnShareDataOkListener listener) &#123; this.listener = listener; Intent intent = activity.getIntent(); String action = intent.getAction(); String type = intent.getType(); if (null == action || type == null) &#123; Log.e("chendong", "没有检索到分享数据"); return; &#125; if (Intent.ACTION_SEND.equals(action) &amp;&amp; type != null) &#123; if ("text/plain".equals(type)) &#123; handleSendText(intent); &#125; else if (type.startsWith("image/")) &#123; handleSendImage(intent); &#125; &#125; else if (Intent.ACTION_SEND_MULTIPLE.equals(action) &amp;&amp; type != null) &#123; if (type.startsWith("image/")) &#123; handleSendMultipleImages(intent); &#125; &#125; &#125; /** * 分享文字 * * @param title 文字标题 * @param content 文字内容 */ public void shareText(String title, String content) &#123; Intent shareIntent = new Intent(); shareIntent.setAction(Intent.ACTION_SEND); shareIntent.putExtra(Intent.EXTRA_TEXT, content); shareIntent.putExtra(Intent.EXTRA_TITLE, title); shareIntent.setType("text/plain"); //设置分享列表的标题，并且每次都显示分享列表 activity.startActivity(Intent.createChooser(shareIntent, "分享到")); &#125; /** * 分享单张图片 * * @param path 图片的路径 */ public void shareSingleImage(String path) &#123; //由文件得到uri Uri imageUri = Uri.fromFile(new File(path));// Log.d("share", "uri:" + imageUri); //输出：file:///storage/emulated/0/test.jpg Intent shareIntent = new Intent(); shareIntent.setAction(Intent.ACTION_SEND); shareIntent.putExtra(Intent.EXTRA_STREAM, imageUri); shareIntent.setType("image/*"); activity.startActivity(Intent.createChooser(shareIntent, "分享到")); &#125; /** * 分享多张图片 * * @param paths 路径的集合 */ public void shareMultipleImage(List&lt;String&gt; paths) &#123; ArrayList&lt;Uri&gt; uriList = new ArrayList&lt;&gt;(); for (String path : paths) &#123; uriList.add(Uri.fromFile(new File(path))); &#125; Intent shareIntent = new Intent(); shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE); shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, uriList); shareIntent.setType("image/*"); activity.startActivity(Intent.createChooser(shareIntent, "分享到")); &#125; private void handleListener(int type, List&lt;String&gt; list, String title, String content) &#123; if (listener != null) &#123; listener.OnHandleOk(type, list, title, content); &#125; &#125; /** * 处理分享的文本 * * @param intent */ private void handleSendText(Intent intent) &#123; String sharedText = intent.getStringExtra(Intent.EXTRA_TEXT); String sharedTitle = intent.getStringExtra(Intent.EXTRA_TITLE); handleListener(TYPE_TEXT, null, sharedTitle, sharedText); &#125; /** * 处理分享的单张照片 * * @param intent */ private void handleSendImage(Intent intent) &#123; Uri imageUri = intent.getParcelableExtra(Intent.EXTRA_STREAM); if (imageUri == null) return; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(UriUtils.getRealPathFromURI(activity, imageUri)); handleListener(TYPE_IMAGE, list, null, null); &#125; /** * 处理分享的多张照片 * * @param intent */ private void handleSendMultipleImages(Intent intent) &#123; ArrayList&lt;Uri&gt; imageUris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM); LUtils.e("chendong", imageUris.toString()); if (imageUris == null) return; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (Uri uri : imageUris) &#123; if (uri != null) list.add(UriUtils.getRealPathFromURI(activity, uri)); &#125; handleListener(TYPE_IMAGE, list, null, null); &#125; public interface OnShareDataOkListener &#123; void OnHandleOk(int type, List&lt;String&gt; list, String title, String content); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536/** * CdLibsTest com.march.libs.utils * Created by 陈栋 on 16/3/25. * 功能: */public class UriUtils &#123; /** * 从uri获取path * * @param uri * @return */ public static String getRealPathFromURI(Context context, Uri uri) &#123; if (null == uri) return null; final String scheme = uri.getScheme(); String data = null; if (scheme == null) data = uri.getPath(); else if (ContentResolver.SCHEME_FILE.equals(scheme)) &#123; data = uri.getPath(); &#125; else if (ContentResolver.SCHEME_CONTENT.equals(scheme)) &#123; Cursor cursor = context.getContentResolver().query(uri, new String[]&#123;MediaStore.Images.ImageColumns.DATA&#125;, null, null, null); if (null != cursor) &#123; if (cursor.moveToFirst()) &#123; int index = cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA); if (index &gt; -1) &#123; data = cursor.getString(index); &#125; &#125; cursor.close(); &#125; &#125; return data; &#125;&#125; 如何处理分享得到数据？123456789101112//如果你按照前面的要求注册了Activity，你可以在Activity中使用下面的代码处理分享得到的数据shareSysUtils = ShareSysUtils.get(self);shareSysUtils.handleShare(new ShareSysUtils.OnShareDataOkListener() &#123; @Override public void OnHandleOk(int type, List&lt;String&gt; list, String title, String content) &#123; if (type == ShareSysUtils.TYPE_TEXT) &#123; Log.e("chendong", "分享文本是 " + title + " " + content); &#125; else if (type == ShareSysUtils.TYPE_IMAGE) &#123; Log.e("chendong", "分享图片是 " + list.toString()); &#125; &#125; &#125;); 如何发起分享？12345678//一行代码发起分享，会调起QQ,微信等Apppublic void ShareImg(View view) &#123; shareSysUtils.shareSingleImage("我是图片路径path");&#125;public void ShareTxt(View view) &#123; shareSysUtils.shareText("我是title", "我是content");&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ViewPager自定义控件广告板轮播]]></title>
      <url>%2F2016%2F03%2F16%2FAndroid%E5%BC%80%E5%8F%91%2FViewPager%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%B9%BF%E5%91%8A%E6%9D%BF%E8%BD%AE%E6%92%AD%2F</url>
      <content type="text"><![CDATA[GitHub GitHub地址 Gradle compile &#39;com.march.billboardview:billboardview:2.0.6-beta4&#39; xml 里面使用12345678910111213xml 里面使用&lt;com.march.billboardview.BillBoardView android:id="@+id/billboard" android:layout_width="match_parent" android:layout_height="250dp" board:isAutoRun="true" board:isLoopIt="true" board:intervalTime="2000" /&gt;属性：isAutoRun:是不是自动播放，不需要滑动，默认trueisLoopIt:是不是无限循环播放，默认是trueintervalTime:播放间隔时间，每隔多长时间走一页 构建实体12//实体类实现获取url和title的接口public class Demo implements BoardConfig&#123;&#125; 定义加载工具1234567//初始化图片加载的工具,你可以自定义使用Picasso还是Glide等图片加载库加载BillBoard.init(new BillBoard.BillLoadImg() &#123; @Override public void loadImg(Context context, String title, String url, ImageView imageView) &#123; imageView.setImageResource(Integer.parseInt(url)); &#125; &#125;); 使用SimpleBoardAdapter1234private BillBoardView billBoardView;private SimpleBoardAdapter&lt;Demo&gt; mBoardAdapter;mBoardAdapter = new SimpleBoardAdapter&lt;&gt;(getActivity(), demos);billBoardView.setAdapter(mBoardAdapter); 配置BillBoardView123456789billBoardView .setAdapter(mBoardAdapter) .setSwipeRefreshLayout(sw) .click(new OnBoardClickListener() &#123; @Override public void clickBillBoard(int pos, BoardConfig b) &#123; Log.e(&quot;chendong&quot;, &quot;click pos &quot; + pos + &quot; title is &quot; + b.getTitle()); &#125; &#125;).show(); 数据更新1mBoardAdapter.notifyDataSetChanged(demos); 开放停止和开始播放的方法12public void startPlay()public void stopPlay() SwipeRefreshLayout冲突 当与SwipeRefreshLayout嵌套使用时，解决SwipeRefreshLayout冲突 1public void setSwipeRefreshLayout(SwipeRefreshLayout sw) 轮播动画和时间 下面是可选的插值器,可自定义插值器 12//设置动画的方法public BillBoardView setAnimation(int duration, Interpolator interpolator) 插值器 描述 new AccelerateInterpolator() 开始慢后面加速,由于距离较近效果不明显,有点像是匀速 new AccelerateDecelerateInterpolator() 两头速度慢,中间加速,由于距离较近效果不明显,有点像是匀速 new DecelerateInterpolator() 开始快后面慢,由于距离较近效果不明显,有点像是匀速 new BounceInterpolator() 到达末尾跳跃弹起 new AnticipateInterpolator() 先甩一下在移动 new AnticipateOvershootInterpolator() 先甩一下到达终点后过界在后退 new OvershootInterpolator() 过界后返回 new LinearInterpolator() 常量变速 new LinearOutSlowInInterpolator() 开始快后面慢 其他API12345//BillBoardView//重新定义ViewPager的将停public void setOnBoardPageChangeListener(OnPageChangeListener onPageChangeListener)//获取内部的ViewPagerpublic ViewPager getViewPager() BoardAdapter12345678//一些变量，你可以在子类中访问protected Context mContext;protected int mLyRes;protected int preIndex = -1;//上一个被选中的protected List&lt;B&gt; datas;protected boolean isLoop;protected View mRootView;protected BillBoardView mBoardView; 基于SimpleBoardAdapter1234567891011121314//为了方便使用定义了SimpleBoardAdapter//获取TitleView用于改变字体，颜色，背景，文字大小等public TextView getTitleView()//获取底部Bar,用于改变背景，高度等public ViewGroup getBotLy()//获取导航条public LinearLayout getGuideLy()//设置选中和未选中的资源public void setSelectRes(int selectRes, int unSelectRes)//设置标题的位置POS_LEFT = 0, POS_CENTER = 1, POS_RIGHT = 2public void setTitleGravity(int gravity)//设置导航栏的位置POS_LEFT = 0, POS_CENTER = 1, POS_RIGHT = 2public void setGuideLyGravity(int gravity) 如何自定义Adapter12345678910111213141516171819202122232425262728293031//Adapter做的工作是，覆盖在BillBoardView上面，随着BillBoardView的变化，修改UIpublic class MyAdapter extends BoardAdapter&lt;Demo&gt; &#123; public MyAdapter(Context mContext, List&lt;Demo&gt; datas) &#123; super(mContext, datas); &#125; //资源ID.高度建议Match_parent @Override protected int getLayoutId() &#123; return 0; &#125; //获取控件，findById()或者一些初始化的操作 @Override protected void initAdapterViews() &#123; &#125; //当划到pos位置。更改界面显示 @Override public void changeItemDisplay(int pos, Demo demo) &#123; &#125; //当adapter连接到billboardView时，触发 @Override public void onBillBoardViewAttached(BillBoardView billBoardView) &#123; super.onBillBoardViewAttached(billBoardView); &#125;&#125; 优化 当你的页面退出时,暂定轮播将是优化的一个很好选择 123456789101112131415161718@Overrideprotected void onResume() &#123; super.onResume(); if(billBoardView!=null) billBoardView.startPlay();&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); billBoardView.stopPlay();&#125;@Overrideprotected void onPause() &#123; super.onPause(); billBoardView.stopPlay();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift基础语法1]]></title>
      <url>%2F2016%2F03%2F15%2F%E5%AD%A6%E4%B9%A0%2FSwift%E5%9F%BA%E7%A1%801%2F</url>
      <content type="text"><![CDATA[前言 从今天开始学习Swift－2016-3-16； 先学习简单语法，不涉及详细API Swift 3.0已经移除i++方法，请使用i+=1 快捷键123456//格式化代码 ctrl+i//删除一行 command+delete//注释一行command+/ 一些琐碎1234567891011121314151617181920212223242526272829303132//swift是一门安全的语言//不支持隐式类型转换//不支持空值，nil是一种单独的类型//数据类型后面带有数字，表示使用几位来表示，Int8最大为127var int8:Int8print(Int8.max)//二进制，八进制，16进制的表示var two = 0b111var eight = 0o111var sixTeen = 0x111print("\(two) \(eight) \(sixTeen)")//下划线表示忽略,更清晰的数据定义方式var bigNum = 1_000_000var _ = 100//轻量级的数据聚合，元组，元组可以存储任意类型的数据//指定类型var yuanzu0:(Int,String,Int,String) = (100,"0909",30,"222")print("\(yuanzu0.1)")//不指定类型，使用下标访问var yuanzu1 = (100,"0909",30,"222")print("\(yuanzu1.1)")//标志位，访问var yuanzu2 = (x:100,y:"aaa")print("\(yuanzu2.x)")//解包访问，不关心的数据可以使用_代替var (m,_) = yuanzu2print("\(m) ") 常量和变量1234567891011print("hello world");//常量(let)和变量(var)，未赋值的变量常量显示声明类型,赋值的变量常量会自动推断数据类型let contast = 1;print(contast)var a:Int//10进制a = 1000var str = "this is a str" //使用\(变量常量)可以直接打印变量常量出来var rst = "this is a rst = \(a)"print(rst) ##数组和字典123456789101112131415161718192021222324//定义数组，使用［］访问元素var list = [1,2,3,4,5];print(list);print(list[0]);//定义字典，使用key访问var map = ["a":1,"b":2,"c":3];print(map);print(map["a"])print(map["a"]! + 100) //如果列表和字典的类型可以被推断出来，可以不使用类型，也不用带（），在下面，shoplist首先被声明为String类型的数组，后又重新赋值，此时可以推断shoplist 是［String］var shoplist = [String]()shoplist = []//跟常量和变量的定义一样，如果类型可以被推断时，可以不使用类型声明，上面的list和map类型已经可以推断，当将它重新指向空的数组和字典list = []map = [:] //定义空的数组和字典var emptyList = [String]()var emptyMap = [String:Int]()print(emptyList.count)print(emptyMap.count) 控制流for1234567891011121314151617181920212223242526let testList = [1,2,3,4,5,6,7,8];//简单for循环for var i=0;i&lt;8;i+=1 &#123; print("for this is \(testList[i])")&#125;//for in 循环//注意这里的x是常量，不能修改它的值，所以下面（1）是错误的for x in testList&#123; print("for in this is \(x)") //(1) x = 1&#125;//遍历字典中的数组let map2scan = [ "a":[1,2,3,4,5], "b":["a","b","c"]] for (key,value) in map2scan&#123; print("key is \(key)") for num in value&#123; print("num is \(num)") &#125;&#125; if关键字123456789101112131415161718//涉及可选型的概念，后面单独介绍var optionalStr:String? = "hello"optionalStr = "world"print(optionalStr == nil) var greet = "hey"if let name = optionalStr&#123; greet = "hello \(name)";&#125;print(greet) if(optionalStr != nil)&#123; print("optional str is not nil")&#125;if score &gt;= 10&#123;&#125; switch关键字1234567891011121314151617181920212223242526272829303132333435363738394041//swift支持任意数据类型的switch比较，不仅限于Int和enum//break语句,不需要显式添加，默认语句后面都会break;//default语句,是不可以省略的,除非所有的值都被穷举出来了；//fallthrough语句，当满足某个case之后仍旧想使它匹配下一个case，使用 fallthrough，则不会被截断let vegetable = "red peper"switch vegetable&#123;//因为每个case之后都会有break，所以每个case之后必须至少有一行可执行语句，当需要多个匹配时，可以像下面这样case "b","B" print("this is b/B")case "a": print("this is a") fallthroughcase let x where x.hasSuffix("peper"): print("has suffix " + x)default: print("default")&#125;//高级用法//区间let num = 100switch num&#123; case 0 ..&lt; 100: print("小于100")&#125;//元组let point = (1,1)switch point&#123; case (_,0): print("x aliaxs"); fallthrough case (0,_): print("y aliaxs") fallthrough case (0,0): print("origin point") fallthrough case (-2 ... 2,-2 ... 2): print("near by origin point")&#125; while/repeat…while1234567891011//while/repeat...while循环, 当while语句成立时，语句体会执行。var num = 0;while num &lt; 100&#123; num+=1&#125;print("while num is \(num)") repeat&#123; num-=1;&#125;while num &gt; 0print("repeat num is \(num)") 操作符可选值操作符(??)12345//有点类似三目运算符,??表示默认值,当前面的值为空时将会使用后面的let nickName?String = "a"let fullName = "b"let name = "hello \(nickName ?? fullName)"print(name) 范围操作符(..&gt;／…)1234567891011//提供一种更简单实现循环的方式,...包含上界//0 1 2 3for x in 0..&lt;4&#123; print("x is \(x)")&#125;//0 1 2 3 4for x in 0...4&#123; print("x is is \(x)")&#125; 强制解包操作符(!)123//强制解包 unwrap 解包的概念会在可变型中介绍var num = 100var name = "this is " + num! 函数和闭包简述1函数是一个可以被抽取调用的封闭代码块，是可以被传递的数据类型 一个简单函数123456789//函数使用func关键字命名//使用 [参数名:参数类型] ...的方式定义参数//调用函数时，要用 [参数名:值] 的方式传递//func 函数名（参数列表（参数名:参数类型））-&gt; 返回类型 &#123;// 函数体｝func firstFun (name:String,pwd:String,newParams:String)-&gt;Bool &#123; print("name is \(name) and pwd is \(pwd)") return true&#125;firstFun("chendong",pwd:"1234567",newParams:"new params"); 返回多个值1234567891011121314151617181920//可以使用元组返回多个值，实际上是以元组作为值传递的方式//使用元组实现多个返回值//元组可以使用键访问，rst.max,也可以使用下标访问，rst.2func getMultiBackFun(scores:[Int])-&gt;(max:Int,min:Int,sum:Int)&#123; var sum = 0 var min = scores[0] var max = scores[0] for score in scores&#123; sum += score; if(score &gt; max)&#123; max = score; &#125; if(score &lt; min)&#123; min = score &#125; &#125; return (max,min,sum)&#125;let rst = getMultiBackFun([4,8,1,7,4,0,6,3,7])print("max is \(rst.max) min is \(rst.min) sum is \(rst.sum) rst.2 is \(rst.2)") 可变长度参数函数123456789101112//跟所有的语言一样，支持可变长度参数，本质是数组的传递//一个求均值的函数func changeParamFun(params :Int...)-&gt;Void&#123; var sum = 0; for x in params&#123; sum+=x &#125; print("averge is \(sum/(params.count))")&#125; changeParamFun(1,2,3,4)changeParamFun(0,9,8,7) ###函数嵌套定义1234567891011//函数可以嵌套定义,被嵌套的函数作用域有限，只能在嵌套它的｛｝中被访问，比如下面（1）中的代码是编译错误的，被嵌套的函数可以访问外面函数的变量或者全局变量，func aOutFun() -&gt; Void&#123; var num = 100 func aInFun()-&gt;String&#123; return "chendong \(num)" &#125; print(aInFun())&#125;aOutFun()//1 编译错误aInFun() 函数作为返回值123456789//函数作为返回值,下面的函数表示一个无参函数，返回值是一个（参数为Int,返回值是String的）函数类型，在函数returnFuncFun中定义内嵌函数并返回，在外部可以使用该函数func returnFuncFun()-&gt;(Int-&gt;String)&#123; func INTSTRING(num:Int)-&gt;String&#123; return "this num is \(num)" &#125; return INTSTRING&#125;let funINTSTR = returnFuncFun();print("func return is \(funINTSTR(1000))") 函数作为参数传递123456789101112//函数作为参数，下面的函数表示一个参数为Int类型，一个参数为（Int-&gt;String）的函数类型，返回值Stringfunc funParamFun(num:Int,param : Int -&gt; String)-&gt;String&#123; return "funparamfun + \(param(num))"&#125;func paramFunc(num:Int)-&gt;String&#123; return "paramfunc + \(num)"&#125;print("rst is \(funParamFun(100, param: paramFunc))")//结果是 rst is funparamfun + paramfunc + 100 匿名函数闭包12345678910111213141516171819//匿名闭包（in 前面是参数类型，in后面的是函数体）let numbers = [1,2,3,4,5];let get = numbers.map(&#123; （in 前面是函数参数和返回值，in后面的是函数体） (number:Int)-&gt;Int in let rst = number*2; return 3 + rst;&#125;)print("rst is \(get)")//如果一个闭包的类型已知，比如作为一个回调函数，你可以忽略参数的类型和返回值。单个语句闭包会把它语句的值当做结果返回.numbers.map(&#123; number in number * 3&#125;)//使用参数位置代指参数 numbers.sort(&#123;$0&gt;$1&#125;)let get2 = numbers.map(&#123;$0*2&#125;)print("numbers is \(get2)")]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android轻松集成Camera拍照]]></title>
      <url>%2F2016%2F03%2F12%2FAndroid%E5%BC%80%E5%8F%91%2FAndroid%E8%BD%BB%E6%9D%BE%E9%9B%86%E6%88%90Camera%E6%8B%8D%E7%85%A7%2F</url>
      <content type="text"><![CDATA[前言 最近有在做Camera拍照相关的项目，从一开始到现在看了好多资料，将Camera封装了一下，现在分享出来。 GitHub GitHub Gradle compile &#39;com.march.cameralibs:easycameralibs:1.0.8&#39; 介绍 不需要再去关注如何使用camera类和设置相关参数，提供简单的API接口 支持UI和Camera参数同步切换，不需要在外部修改UI，更便捷 使用Camera和SurfaceView 自支持触摸定点对焦和自动对焦 支持连拍和正常拍摄单张照片 异步存储照片，内存优化 适配6.0及大多数机型，支持图片横屏拍摄自动旋转 功能介绍 切换闪光灯 切换拍照模式，连拍模式像素略低，可调节 切换照片大小，支持3:4，1:1 图片本地存储 横屏图片自动旋转 镜头切换 在xml文件中使用1234567891011//参数说明&lt;declare-styleable name="CamContainerView"&gt; &lt;attr name="isShowTop" format="boolean"/&gt;//是否在顶部显示遮挡&lt;/declare-styleable&gt;//xml实例 &lt;com.march.libs.mycamera.CamContainerView android:id="@+id/activity_mycamera_container" android:layout_width="match_parent" android:layout_height="match_parent" cam:isShowTop="true"/&gt; 同步生命周期1234567891011121314151617@Override protected void onResume() &#123; super.onResume(); CameraNative.getInst().onResume(); &#125; @Override protected void onPause() &#123; super.onPause(); CameraNative.getInst().onPause(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); CameraNative.getInst().onDestory(); &#125; 获取实例并设置监听123456789101112131415161718192021222324252627282930313233343536373839404142//get the singleton of CameraNativeprivate CameraNative mCameraNative;mCameraNative = CameraNative.getInst();//设置保存图片的路径mCameraNative.setSaveDir(new File(ImageUtils.getSystemDcimPath()));//设置闪光灯监听，有三个回调可以自由实现mCameraNative.setOnFlashChangeListener(new CameraNative.OnFlashChangeListener() &#123; @Override public boolean OnTurnFlashOn() &#123; //your code return true; &#125;&#125;);//设置照片拍摄的监听的监听，将会实现三个方法mCameraNative.setOnSavePicListener(this);@Overridepublic void InSaveProgress(int num, float percent) &#123; L.info("正在存储 " + num + " rate " + percent); //由于拍摄和存储是异步进行的，在这里可以回调保存的进度&#125;@Overridepublic void OnSaveOver() &#123; L.info("保存完成"); //保存完成，回调发生&#125;@Overridepublic void CanotTake() &#123; ToastUtil.show("稍候操作"); //camera拍摄过快时将会产生异常，会回调改方法&#125;//错误回调监听mCameraNative.setOnErrorListener(new CameraNative.OnErrorListener() &#123; @Override public void error(String errMsg) &#123; //错误信息，默认错误信息仍旧是会打印的 &#125; &#125;); 闪光灯API1234567891011121314151617//切换闪光灯//如果相机支持将会切换到自动状态，否则直接切换到关闭状态，是可以自适应的切换模式，需要设置按钮和相关资源//flashBtn ImageView 切换按钮 可以为空，为空时不切换//res int[] 资源数组，长度必须是3，可以为空，为空时不切换public void toogleLightWithAuto(ImageView flashBtn, int... res)mCameraNative.toogleLightWithAuto(flashBtn, R.mipmap.camera_flashon, R.mipmap.camera_flashauto, R.mipmap.camera_flashoff); //开启和关闭状态切换//flashBtn ImageView 切换按钮 可以为空，为空时不切换//res int[] 资源数组，长度必须是2，可以为空，为空时不切换public void toogleLight(ImageView flashBtn, int... res) mCameraNative.toogleLight(flashBtn, R.mipmap.camera_flashon, R.mipmap.camera_flashoff); 照片大小API12345678//自动切换图片资源同时切换图片大小//size参数 为CameraNative.NotConvert时将会自己切换否则切换到制定状态(CameraNative.NotConvert,CameraNative.One2One,CameraNative.Four2Three)public void switchPicSize(int size, ImageView iv, int... res) //无关资源切换参数同上调用CamContainerView的相关方法切换照片大小和界面显示public void switchPicSize(int size)public boolean isSizeOne2One() public boolean isFour2Three() 照片模式API12345678//切换照片模式，两种模式//MODE_PIC 照片模式，像素在300w以上 //MODE_GIF 连拍模式，相片像素600*800//切换拍照模式,同时重新初始化相机public void switchTakeMode(int mode)public boolean isTakePic()public boolean isTakeGif() 拍照API123456789101112131415161718192021222324252627282930//拍摄照片//fileName 指定文件名存储,不能为空//接口public static abstract class OnTakePicListener &#123;//拍摄获得的二进制数组 public void onTakePic(byte[] data) &#123; &#125;//处理之后的bitmap public void onTakePic(Bitmap bit) &#123; &#125;//是否处理成bitmap,默认不处理 public boolean isConvert2Bitmap() &#123; return false; &#125;//压缩的sampleSize,默认不压缩 public int getInSampleSize(byte[] data) &#123; return 1; &#125;&#125;public boolean doTakePic(String fileName, boolean isConvert2Bit, OnTakePicListener listener)//快速连拍//开始连拍时调用doStartTakeFastPic()public void doStartTakeFastPic()//拍摄一张，fileName == null时不存储，使用listener获取拍摄的数据public void doTakeFastPic(String fileName, OnTakePicListener listener)//拍摄完毕停止连拍public void doStopFastPic() 图片处理API12//在外部处理byte数组,返回bitmappublic Bitmap handlePicData(boolean isFast, byte[] data, int sampleSize) 其他1234//由于存储照片是异步的，拍摄完毕之后需要调用doTakePicOver()方法，并在OnSaveOver()回调中执行相关操作doTakePicOver()//停止照片自定旋转,横屏拍摄的照片将不会自动横向显示public void shutDownAutoRotate() 常用操作12345678910111213141516171819202122232425262728public void clickBtn(View view) &#123; switch (view.getId()) &#123; case R.id.activity_mycamera_take: //拍照 cameraNative.doTakePic(str(System.currentTimeMillis()) + ".jpg", null); break; case R.id.activity_mycamera_switch: //切换摄像头 cameraNative.switchCamera(); break; case R.id.activity_mycamera_flash: //切换闪光灯 cameraNative.toogleLightWithAuto(null); break; case R.id.activity_mycamera_over: //拍照结束 cameraNative.takePicOver(); break; case R.id.activity_mycamera_mode: //切换拍摄模式 cameraNative.switchTakeMode(CameraNative.NotConvert); break; case R.id.activity_mycamera_size: //切换照片大小 cameraNative.switchPicSize(CameraNative.NotConvert); break; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[将自己写的库发布到Jcenter]]></title>
      <url>%2F2016%2F03%2F12%2F%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%2F%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%B0JCenter%2F</url>
      <content type="text"><![CDATA[1. 前言 我们使用gradle开发，可以通过compile命令将别人的library下载到本地使用，使用这种方式简单快速，而且当需要版本升级时改一下版本号就可以了，简直比使用jar包好了几百倍。 我们之所以可以使用别人的library，是因为别人将自己的library发布到了JCenter,我们可以通过compile命令将aar文件文档等内容下载下来使用，也就是说只要我们将自己的library发布到JCenter,那么自己和别人就都可以使用了。 网上有很多资料，介绍了各家各户的服务器，但是JCenter目前是library最多的服务器，AndroidStudio现在新建项目都是默认依赖 repositories {jcenter()}但是看着容易做着难，走了很多弯路，现在把我的经验分享出来，希望可以帮到别人。 2. 推荐阅读 推荐这篇文章 3. 踩过的坑 删除gradle.properties里面会有 systemProp.http.proxyHost=127.0.0.1 systemProp.http.proxyPort=1080 字段，使用代理可能会导致无法上传发布。 打包javadoc时会出问题，因为他会将你所有的注释打包进去，如果注释写的不规范就会报错，不过这个是有提示的，按照提示改掉就好了，注释要符合要求。 如果出现了gradle commond not found,说明你的gradle路径没有配置，mac可以参考这篇文章，windows的话自己查一下如何配置 你的library中的manifest文件有allowback属性最好删掉， 当别人或者你的别的工程引用这个库时，需要进行manifest的merge操作，如果某些属性冲突了会导致合并失败，因此库文件的manifest文件只保留必要的属性，即可。 4. 注册账号我们要发布自己的库到JCenter,首先要将代码发布到maven库，官方网站www.bintray.com ，进去网站注册登录就好了，注册之后可以拿到你的用户名和apikey。 apiKey的获取方法 －&gt; 右上角点击头像 －&gt; your profile -&gt; 头像下面edit -&gt; 最下面的APIkey 就可以获取了，后面有用. 5. 构建项目使用As开发你的项目应该是有多个module的，通常你的项目至少应该有app这个module，创建一个library类型的module（点击file - &gt; new moudle -&gt; library,就可以建立一个library moudle)，因为我们要发布到maven 的是你的library，所以这个moudle需要有。然后你应该把这个项目发布到github上去，后续需要填写项目的地址，当然这不是必选的。 6. 配置(重要)6.1 首先是 projectName.gradle配置这个文件主要是依赖一些必要的插件来完成后续的打包上传操作123456789101112131415161718//最后写完应该是这样的buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.2.3' //主要是下面的两行 classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0' classpath 'com.github.dcendents:android-maven-gradle-plugin:1.4.1' &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125; 6.2 配置local.propertieslocal.properties不会被上传到git上面，因此一些个人用户的信息需要配置在这里面，避免泄漏 1234567891011// 这里是你在bintray的id同下面bintray.userdeveloper.id=chendongmarch// 开发者的名字，随意developer.name=chendong// 开发者邮箱developer.email=helloworld4x@gmail.com// bintrayId bintray.user=chendongmarch// bintrayApiKeybintray.apikey=f452fcdf8...xxxx...4b1a925331 6.3 配置Library在你新创建的lib module下面的project.propertie文件，如果没有就新建一个 123456789101112131415161718192021groupId artifactId version决定了最后你的类库的依赖的地址例如我下面的配置最后的地址就是compile 'groupId:artifactId:version'compile 'com.march.lib-dev:lib-dev:0.0.1-beta6'// 项目的名称project.name=lib-dev// groupIdproject.groupId=com.march.lib-dev// artifactIdproject.artifactId=lib-dev// versionproject.versionName=0.0.1-beta6// 打包类型project.packaging=aar// 类库的主页project.siteUrl=git@github.com:chendongMarch/CommonLib// 类库的git地址project.gitUrl=git@github.com:chendongMarch/CommonLib.gitjavadoc.name=lib-dev 6.4 打包上传的脚本上面配置那么多，其实都在这个脚本中将这些数据读出来，作为打包上传时候使用，将下面的脚本放到project根目录下面即可，命名为bintrayUpload.gradle，拷贝下面的脚本到项目根目录就可以使用了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146apply plugin: 'com.github.dcendents.android-maven'apply plugin: 'com.jfrog.bintray'// load propertiesProperties properties = new Properties()File projectPropertiesFile = project.file("project.properties");if (projectPropertiesFile.exists()) &#123; properties.load(projectPropertiesFile.newDataInputStream())&#125;// read propertiesdef projectName = properties.getProperty("project.name")def projectGroupId = properties.getProperty("project.groupId")def projectArtifactId = properties.getProperty("project.artifactId")def projectVersionName = properties.getProperty("project.versionName")def projectPackaging = properties.getProperty("project.packaging")def projectSiteUrl = properties.getProperty("project.siteUrl")def projectGitUrl = properties.getProperty("project.gitUrl")File localPropertiesFile = project.file("../local.properties");if (localPropertiesFile.exists()) &#123; properties.load(localPropertiesFile.newDataInputStream())&#125;def developerId = properties.getProperty("developer.id")def developerName = properties.getProperty("developer.name")def developerEmail = properties.getProperty("developer.email")def bintrayUser = properties.getProperty("bintray.user")def bintrayApikey = properties.getProperty("bintray.apikey")def javadocName = properties.getProperty("javadoc.name")group = projectGroupId// This generates POM.xml with proper parametersinstall &#123; repositories.mavenInstaller &#123; pom &#123; project &#123; name projectName groupId projectGroupId artifactId projectArtifactId version projectVersionName packaging projectPackaging url projectSiteUrl licenses &#123; license &#123; name 'The Apache Software License, Version 2.0' url 'http://www.apache.org/licenses/LICENSE-2.0.txt' &#125; &#125; developers &#123; developer &#123; id developerId name developerName email developerEmail &#125; &#125; scm &#123; connection projectGitUrl developerConnection projectGitUrl url projectSiteUrl &#125; &#125; &#125; &#125;&#125;// This generates sources.jartask sourcesJar(type: Jar) &#123; from android.sourceSets.main.java.srcDirs classifier = 'sources'&#125;task javadoc(type: Javadoc) &#123; source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator))&#125;// This generates javadoc.jartask javadocJar(type: Jar, dependsOn: javadoc) &#123; classifier = 'javadoc' from javadoc.destinationDir&#125;artifacts &#123;// archives javadocJar archives sourcesJar&#125;//javadoc configurationjavadoc &#123; options &#123; encoding "UTF-8" charSet 'UTF-8' author true version projectVersionName links "http://docs.oracle.com/javase/7/docs/api" title javadocName &#125;&#125;////打包doc,避免注解报错android.libraryVariants.all &#123; variant -&gt; println variant.javaCompile.classpath.files if (variant.name == 'release') &#123; //我们只需 release 的 javadoc task("generate$&#123;variant.name.capitalize()&#125;Javadoc", type: Javadoc) &#123; // title = '' // description = '' source = variant.javaCompile.source classpath = files(variant.javaCompile.classpath.files, project.android.getBootClasspath()) options &#123; encoding "utf-8" links "http://docs.oracle.com/javase/7/docs/api/" linksOffline "http://d.android.com/reference", "$&#123;android.sdkDirectory&#125;/docs/reference" &#125; exclude '**/BuildConfig.java' exclude '**/R.java' &#125; task("javadoc$&#123;variant.name.capitalize()&#125;Jar", type: Jar, dependsOn: "generate$&#123;variant.name.capitalize()&#125;Javadoc") &#123; classifier = 'javadoc' from tasks.getByName("generate$&#123;variant.name.capitalize()&#125;Javadoc").destinationDir &#125; artifacts &#123; archives tasks.getByName("javadoc$&#123;variant.name.capitalize()&#125;Jar") &#125; &#125;&#125;// bintray configurationbintray &#123; user = bintrayUser key = bintrayApikey configurations = ['archives'] pkg &#123; repo = "maven" name = projectName websiteUrl = projectSiteUrl vcsUrl = projectGitUrl licenses = ["Apache-2.0"] publish = true &#125;&#125; 7. 打包发布7.1 执行脚本在需要打包上传的lib module的build.gradle文件中如下代码就可以执行上面的脚本啦 1apply from: '../bintrayUpload.gradle' 打开terminal，进入lib module目录下面执行如下命令开始打包上传，第一次可能需要下载一些以来文件会慢一些。 1../gradlew bintrayUpload 7.2 去网站查看打开bintray.com打开所在的项目，注意右上角有个链接，类似https://dl.bintray.com/chendongmarch/maven，这是你maven库的链接。注意左下角有三个很小的选项maven、gradle、lvy,点击gradle可以看到类似这样的compile &#39;com.march.lib-dev:lib-dev:0.0.1-beta6&#39;一个依赖地址，这是compile的地址，就算大功告成啦。 7.3 使用库123456789101112//在项目名称.gradle文件中添加你bintray的链接allprojects &#123; repositories &#123; jcenter() // 现在之所以添加这一句是因为你的类库只是发布到了maven // 但是没有发布到JCenter // 因此需要单独依赖你的bintray的地址。 maven &#123;url 'https://dl.bintray.com/chendongmarch/maven'&#125; &#125;&#125;//在app.gradle文件中添加compile 'com.march.lib-dev:lib-dev:0.0.1-beta6' 7.4 发布到JCenter在网站打开你的项目右下角可以看到Add to jcenter点击之后可以很简单的添加你的库到JCenter,但是审核需要时间，第一次会慢一点。等到审核通过，就可以将maven{url=””}这一块去掉，直接compile 7.5 发布本地库不用上传到 jcenter 单单运行 ./gradlew install 任务， gradle 会在 maven 的本地仓库中生成工件（artifact），只需将 mavenLocal 添加到 repositories，我们可以像发布到 JCenter 一样引用自己的库，方便打包那些多个项目共享又不想发布的私有库, 在project/build.gradle文件添加下面的依赖，可以使用本地库123456allprojects &#123; repositories &#123; mavenLocal() jcenter() &#125;&#125; 8. 一些理解总体来说，最最重要的是打包上传的脚本，他负责打包源文件，生成aar，生成doc然后上传到bintray，我之前采用过别的方式打包类库，本文介绍的方法有个很大的优点就是把这个任务独立出来，写在bintrayUpload.gradle文件中，需要打包上传的library只需要配置一下类库相关信息，引用这个脚本就可以上传，不需要进行复杂的配置，而且可以将一个项目中的多个类库同时上传，每个类库只要在它的build.gradle文件中引用一下该脚本就可以啦。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[将自己写的库发布到JitPack]]></title>
      <url>%2F2016%2F03%2F12%2F%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%2F%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%B0JitPack%2F</url>
      <content type="text"><![CDATA[JitPack优缺 在使用Jcenter发布库代码时，需要先上传到Bintray网站，比较麻烦，不过我之前已经给出了简化的方案,根据这篇文章发布自己的库到JCenter可以很快的配置好项目。本文介绍另外一种发布自己的库代码的方式，使用JitPack发布代码更简单一些。 AndroidStudio创建项目时没有默认生成JitPack的依赖，当使用库时需要添加如下依赖1234repositories &#123; jcenter() maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125; 创建工程新建Library Module,这些就不仔细说了，大家都会，需要注意的一点是，使用JCenter时，库的名字是跟你的Module name有关的，但是JitPack是与你的Project name有关的,所以给你的项目起一个好名字，他将作为库的名称。 配置插件与发布到JCenter一样，需要插件,这里说一下这个插件，该插件的GitHub地址，在发布到JCenter时也用到了这个插件，现在的最新版本1.4.1，我试了一下，编译不成功，看了Issues,大概是因为gradle需要提升到2.14.1才可以，关于这个问题可以自己去查一下，像我下面这样的配置是ok的，版本的对应可以去Git上看看。12345678910buildscript &#123; repositories &#123; jcenter() mavenCentral() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.1.2&apos; classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.3&apos; &#125;&#125; 配置Module的build.gradle123456//默认就有的apply plugin: &apos;com.android.library&apos;//这个跟Jcenter一样的插件apply plugin: &apos;com.github.dcendents.android-maven&apos;//你的Github用户名替换一下group=&apos;com.github.chendongMarch&apos; 发布到GitHub 接下来就去GitHub上打开你的项目－&gt;点击release－&gt;点击创建新的release版本－&gt;书写版本号和release信息－&gt;就会看见到此就完成了发布。如下 JitPack发布 最后去JitPack,会看见如下界面,输入你的项目地址，会看到版本号，点击get it，下面会出现compile地址 完成 AS依赖 1compile &apos;com.github.chendongMarch:JitPackLibs:1.0.2&apos;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在Mac下配置Gradle命令]]></title>
      <url>%2F2016%2F03%2F12%2F%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%2F%E5%9C%A8Mac%E4%B8%8B%E9%85%8D%E7%BD%AEGradle%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[推荐阅读Mac 下配置 Sdk,Gradle 相关下载下载gradle http://gradle.org/downloads/ 配置环境变量 打开.bash-profile 12touch .bash-profileopen -e .bash_profile 打开 bash_profile，配置环境变量。 12345//不使用ndk可以不配置export NDK_PATH=&quot;/Users/Bob_ge/Documents/android_dev/ndk/android-ndk-r10d&quot;export SDK_PATH=&quot;/Users/Bob_ge/Library/Android/sdk/platform-tools&quot;export GRADLE_HOME=&quot;/Users/Bob_ge/Documents/android_dev/gradle/gradle-2.4/bin&quot;export PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/usr/local/ant/bin:/opt/reverse:$&#123;SDK_PATH&#125;:$&#123;NDK_PATH&#125;:$&#123;GRADLE_HOME&#125; 更新 bash_profile 1source .bash-profile 输入adb 检测是否配置正确 1gradle -version]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在Android平台下合成Gif]]></title>
      <url>%2F2016%2F03%2F09%2FAndroid%E5%BC%80%E5%8F%91%2FAndroid%E5%90%88%E6%88%90GIF%2F</url>
      <content type="text"><![CDATA[前言 最近在做合成gif的工作，在网上搜到了很多资料，总结一下，总共找到了两种方法，分别是使用jni和java算法实现。测试表明java算法比so文件更快，大约快两倍，不知道为啥。 java算法合成 Java算法源代码 网上流传很广的就是下面在java中的算法，修改了一些bug AnimatedGifEncoder.java LZWEncoder.java NeuQuant.java C算法 C的源代码 网上有很多关于gifflen合成gif的文章 可以很轻松的get到C源代码，但是需要ndk进行编译 当然也可以用现成的so文件，但是需要将utils类建立在指定包下 一份合成好的so文件 so文件 加载so文件时需要将jni接口写在指定的包下，目前com.xingye.gif 合成好的jar文件 jar文件下载 结合so文件可以直接使用，不需要自己建包 GitHub 详见该类 总结 java的库很简单，有那几个合成的类，定制一个工具类就好了，C的库比较繁琐，虽然效率还没有java快，总结一下就是 自己用C代码合成so 用我合成的so,但是你需要按照编译好的con.xingye.gif包下的GifUtil 来执行代码 更简单，jar文件已经打包好，集成so文件和jar文件，编译可以使用,就是自定义不方便了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[QuickAdapter重构]]></title>
      <url>%2F2016%2F03%2F09%2FAndroid%E5%BC%80%E5%8F%91%2FAdapter%E5%B0%81%E8%A3%855-ListView_QuickAdapter%2F</url>
      <content type="text"><![CDATA[GitHub库代码链接 Gradlecompile &#39;com.march.adapterlibs:adapterlibs:1.0.6&#39; 前言 基于前端时间总结的EasyAdapter（看原理的可以看这些博客）重新构建了代码，基本思想还是一样的，目的是对外开放更加简单的API,其中的原理，想知晓的可以去看我以前的博客。现在的版本已经与以前的版本独立开了。 单类型抽象适配QuickAdapter123456789101112QuickAdapter&lt;Demo&gt; adapter =new QuickAdapter&lt;Demo&gt;(BaseApplication.getInst(), R.layout.item_quickadapter, data) &#123; @Override public void bindData4View(ViewHolder holder, Demo data, int pos) &#123; holder.setText(R.id.item_quickadapter_title, data.getmDemoTitle()); &#125; @Override public void bindListener4View(ViewHolder holder, Demo data, int pos) &#123; //在这里给内部控件绑定监听不是必须实现的 &#125; &#125;; 使用QuickTypeAdapter QuickTypeAdapter的带layout资源参数构造方法,注意不要调用addType了,实体类需要实现QuickInterface接口 1234567891011QuickTypeAdapter&lt;Demo&gt; typeAdapter =new QuickTypeAdapter&lt;Demo&gt;(BaseApplication.getInst(), data,R.layout.item_a) &#123; @Override public void bindData4View(ViewHolder holder, Demo data, int type, int pos) &#123; //单类型,type一直返回0 &#125; @Override public void bindListener4View(ViewHolder holder, Demo data, int type, int pos) &#123; //在这里给内部控件绑定监听不是必须实现的 &#125;&#125;; 多类型适配1234567891011121314151617181920212223//实体类需要实现QuickInterface接口QuickTypeAdapter&lt;Demo&gt; typeAdapter = new QuickTypeAdapter&lt;Demo&gt;(BaseApplication.getInst(), data) &#123; @Override public void bindData4View(ViewHolder holder, Demo data, int type, int pos) &#123; switch (type) &#123; case Demo.CODE_DETAIL: holder.setText(R.id.item_quickadapter_type_title, data.getmDemoTitle()); break; case Demo.JUST_TEST: holder.setText(R.id.item_quickadapter_title, data.getmDemoTitle()); break; &#125; &#125; @Override public void bindListener4View(ViewHolder holder, Demo data, int type, int pos) &#123; //在这里给内部控件绑定监听不是必须实现的 &#125; &#125;;//添加每种类型的xml文件typeAdapter.addType(Demo.CODE_DETAIL, R.layout.item_quickadapter_type) .addType(Demo.JUST_TEST, R.layout.item_quickadapter); 加载网络图片 可以提前创建图片加载工具,然后调用ViewHodler.setImg()方法可以直接加载 12345678//你可以在Activity或者Application调用这段代码进行全局配置,第二次调用会将以前的设置覆盖,所以只需要执行一次Quick.init(new Quick.QuickLoad() &#123; @Override public void load(Context context, String url, ImageView view) &#123; Log.e("chendong","加载图片"); Glide.with(context).load("http://www.fresco-cn.org/static/fresco-logo.png").into(view); &#125; &#125;); 更新使用方法12345678910111213//Demo类是我的实体类//如果你使用的控件ViewHolder没有为你集成,如何避免强转?使用泛型解决 holder.&lt;Button&gt;getView(R.id.abc).setText("");//设置监听事件public ViewHolder setLis(int resId,View.OnClickListener listener,Object tag)//带有tag监听public ViewHolder setLis(int resId,View.OnClickListener listener)//不带tag监听public ViewHolder setTag(int resId, Object tag)//给控件设置tagpublic &lt;T&gt; T getTag(int resId)//从ViewHolder获取tag,包含泛型,你可以这样holder.&lt;Demo&gt;getTag(R.id.xxx)//如果你在控件中设置了tag,当你在适配器外部使用tag时务必使用改方法获取,用来替代view.getTag()方法,包含泛型,你可以这样用 Quick.&lt;Demo&gt;getTagOutOfAdapter(listView);Quick.getTagOutOfAdapter(View view)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义下方导航Tab]]></title>
      <url>%2F2016%2F03%2F09%2FAndroid%E5%BC%80%E5%8F%91%2F%E8%87%AA%E5%AE%9A%E4%B9%89Tab%E5%AF%BC%E8%88%AA%2F</url>
      <content type="text"><![CDATA[前言 基本大多数应用都会使用底部Tab的导航方式，实现底部Tab导航的方式很多，之前有TabHost,现在有TabLayout,之前一直用的是LinearLayout嵌套的方式或者RadioGroup,但是都相对麻烦，所以自定义了一个控件可以更方便的实现底部tab导航。 GitHub地址GitHub源码地址 Gradlecompile &#39;com.march.tabholder:tabholder:1.0.2&#39; 在xml文件中使用12345678910111213141516&lt;com.march.tabholder.TabHolder android:id="@+id/activity_tab_test_tabholder" android:layout_width="match_parent" android:layout_height="50dp" android:background="#ddd" //没有被选中时文字颜色 app:TabHolderNormalColor="#567" //选中时文字颜色 app:TabHolderSelectColor="#00f" //显示的类型，horizontal表示图片在文字左边，vertical表示图片在文字下边 app:TabHolderType="horizontal" //是否显示文字 app:TabHolderWithText="true" //是否显示分割线 app:TabHolderWithDivider="true" /&gt; 初始化123456789101112131415TabHolder mTabHolder = (TabHolder) findViewById(R.id.activity_tab_test_tabholder);//添加tabmTabHolder.addTab(R.drawable.camera_filter, R.drawable.camera_filter_press, "滤镜") .addTab(R.drawable.camera_record, R.drawable.camera_record_press, "记录") .addTab(R.drawable.camera_sticker, R.drawable.camera_sticker_pressed, "贴纸") .addTab(R.drawable.camera_sticker, R.drawable.camera_sticker_pressed, "贴纸");//设置监听事件mTabHolder.setOnItemSelectListener(new TabHolder.OnItemSelectListener() &#123; @Override public void OnItemSelect(int preSelect, int currentSelect, TabView preView, TabView currentView) &#123; Log.e("chendong", "上一个选择是 " + preSelect + " 当前选择是 " + currentSelect); &#125;&#125;); 与ViewPager联动1234567891011121314151617//给TabHolder设置ViewPager,是否平滑移动,监听mTabHolder.setViewPager(vp, false, new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @Override public void onPageSelected(int position) &#123; &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125; &#125;); API1234567891011//停止自动切换,在使用下面的方法时会造成与自动切换的冲突,建议停用public void setAutoToogle(boolean autoToogle)//选中一个public void select(int pos)//不选中一个public void unselect(int pos)//切换一个public void toogle(int pos)//选中一个,上一个被选中的会置为不选中mTabHolder.singleSelect(0)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android物理按键及物理连接]]></title>
      <url>%2F2016%2F02%2F26%2FAndroid%E5%BC%80%E5%8F%91%2FAndroid%E7%89%A9%E7%90%86%E6%8C%89%E9%94%AE%2F</url>
      <content type="text"><![CDATA[前言 主要是自拍杆拍照这个需求引发的 事件分发 拦截按键按下抬起时的事件分发 12345678@Override public boolean dispatchKeyEvent(KeyEvent event) &#123; //如果是长按事件交给onKeyLongPress处理 if (event.getRepeatCount() &gt; 0) return onKeyLongPress(event.getKeyCode(), event); return super.dispatchKeyEvent(event); &#125; 返回按键12345//返回键的监听很常见，android提供了简便的方法@Overridepublic void onBackPressed() &#123; finishThisPage();&#125; 按键按下事件处理 (音量，耳机按键，back键) 123456789101112131415161718192021222324//home键和power键没有监听到//我当时需要的是音量键和耳机按键可以拍照，是可以监听到的@Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; L.info(event.toString()); switch (keyCode) &#123; case KeyEvent.KEYCODE_VOLUME_DOWN: L.info("KEYCODE_VOLUME_DOWN-音量键减小声音"); return true; case KeyEvent.KEYCODE_VOLUME_UP: L.info("KEYCODE_VOLUME_UP-音量键增加声音"); return true; case KeyEvent.KEYCODE_VOLUME_MUTE: L.info("KEYCODE_VOLUME_MUTE-音量键静音"); return true; case KeyEvent.KEYCODE_HEADSETHOOK: L.info("KEYCODE_HEADSETHOOK-耳机线按键"); return true; case KeyEvent.KEYCODE_BACK: L.info("KEYCODE_BACK-返回键"); return true; &#125; return super.onKeyDown(keyCode, event); &#125; 其他事件1234567891011121314151617181920212223242526272829303132//使用快捷键可以快速选中菜单中的某一项，在Android没有什么卵用@Override public boolean onCreateOptionsMenu(Menu menu) &#123; MenuItem add = menu.add(""); add.setShortcut('A','A'); return super.onCreateOptionsMenu(menu); &#125;@Override public boolean onKeyShortcut(int keyCode, KeyEvent event) &#123; L.info("onKeyShortcut " + event.toString()); return super.onKeyShortcut(keyCode, event); &#125;@Override public boolean onKeyLongPress(int keyCode, KeyEvent event) &#123; L.info("onKeyLongPress " + event.toString()); return super.onKeyLongPress(keyCode, event); &#125; //暂时没有用到，网上有说在手写和汉字输入时会触发@Override public boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event) &#123; L.info("onKeyMultiple " + event.toString()); return super.onKeyMultiple(keyCode, repeatCount, event); &#125;//按键抬起时会触发@Override public boolean onKeyUp(int keyCode, KeyEvent event) &#123; L.info("onKeyUp " + event.toString()); return super.onKeyUp(keyCode, event); &#125; 外设监测 检测耳机线，蓝牙耳机是否连接 1234567891011121314151617181920212223242526272829303132private boolean checkControlIsConnected() &#123; //检测耳机线是否连接 AudioManager am = (AudioManager) getSystemService(AUDIO_SERVICE); //这个方法已经过时，api介绍仅仅用来检测是否连接，可以注册广播接收者接受耳机插拔的广播 if (am.isWiredHeadsetOn()) &#123; //耳机插入 return true; &#125; //检测蓝牙设备是否连接 BluetoothAdapter ba = BluetoothAdapter.getDefaultAdapter(); //蓝牙适配器是否存在，即是否发生了错误 if (ba == null || !ba.isEnabled()) &#123; //蓝牙不可用 return false; &#125; else if (ba.isEnabled()) &#123; Set&lt;BluetoothDevice&gt; bondedDevices = ba.getBondedDevices(); if (bondedDevices == null || bondedDevices.size() &lt;= 0) &#123; //当前没有设备连接 return false; &#125; else &#123; for (BluetoothDevice d : bondedDevices) &#123; if (d.getBondState() == BluetoothDevice.BOND_BONDED) &#123; //当前有设备接入并处于连接状态 return true; &#125; &#125; &#125; &#125; return false; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BBPP智能贴纸参数]]></title>
      <url>%2F2016%2F01%2F23%2F%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB%2FBBPP%E8%B4%B4%E7%BA%B8%2F</url>
      <content type="text"><![CDATA[说明参数分别为x坐标，y坐标，高度，旋转角度 相对坐标，偏移的位置占宽或者高的比重（0，1），左右开区间表示相对坐标 x 可以使用相对或者绝对坐标 y 可以使用相对或者绝对坐标 height 必须使用相对距离，宽度进行等比例适应 rotate 旋转角度，绝对数值 不同尺寸图片绝对坐标换算图片尺寸变化，横坐标不需要换算，纵坐标需要换算 bitH 图片高度 bitW 图片宽度 float ratio = (bitH 1.0f / bitW) (3.0f / 4f); 如果是绝对坐标需要 纵坐标＊ratio 第一套左上位置昵称 10, -15, 0.125f, 0 左上角日期 -5, 60f, 0.125f, 0 箭头 0.2f, 110f, 0.042f, 30 出生天数,显示多张 照片时间 0.54f, 0.1f, 0.07f, 20f 左下位置身高 12, 50f, 0.1f, 0 体重 12, 0f, 0.1f, 0 第二套左上位置外框 0, -5, 0.999f, 0 文字 0, 0.125f, 0.125f, 0 左下位置爸爸 40f, 40f, 0.14f, 0 左中间位置体重 20, -40, 0.18f, 0 花的line 10, 15f, 0.08f, 0 身高 20, 55f, 0.125f, 0 男女 20, 105f, 0.09f, 0 右下位置妈妈 40f, 40f, 0.14f, 0 右中间位置月 0, -75, 0.1f, 0 日 20, -42, 0.07f, 0 年 25, 0, 0.11f, 0 星座 20, 57, 0.08f, 0 生肖 20, 105f, 0.09f, 0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//生肖算法char *GetDayOf(PSYSTEMTIME pSt) &#123; /*天干名称*/ const char *cTianGan[] = &#123;"甲","乙","丙","丁","戊","己","庚","辛","壬","癸"&#125;; /*地支名称*/ const char *cDiZhi[] = &#123;"子","丑","寅","卯","辰","巳","午", "未","申","酉","戌","亥"&#125;; /*属相名称*/ const char *cShuXiang[] = &#123;"鼠","牛","虎","兔","龙","蛇", "马","羊","猴","鸡","狗","猪"&#125;; /*农历日期名*/ const char *cDayName[] = &#123;"*","初一","初二","初三","初四","初五", "初六","初七","初八","初九","初十", "十一","十二","十三","十四","十五", "十六","十七","十八","十九","二十", "廿一","廿二","廿三","廿四","廿五", "廿六","廿七","廿八","廿九","三十"&#125;; /*农历月份名*/ const char *cMonName[] = &#123;"*","正","二","三","四","五","六", "七","八","九","十","十一","腊"&#125;; /*公历每月前面的天数*/ const int wMonthAdd[12] = &#123;0,31,59,90,120,151,181,212,243,273,304,334&#125;; /*农历数据*/ const int wNongliData[100] = &#123;2635,333387,1701,1748,267701,694,2391,133423,1175,396438 ,3402,3749,331177,1453,694,201326,2350,465197,3221,3402 ,400202,2901,1386,267611,605,2349,137515,2709,464533,1738 ,2901,330421,1242,2651,199255,1323,529706,3733,1706,398762 ,2741,1206,267438,2647,1318,204070,3477,461653,1386,2413 ,330077,1197,2637,268877,3365,531109,2900,2922,398042,2395 ,1179,267415,2635,661067,1701,1748,398772,2742,2391,330031 ,1175,1611,200010,3749,527717,1452,2742,332397,2350,3222 ,268949,3402,3493,133973,1386,464219,605,2349,334123,2709 ,2890,267946,2773,592565,1210,2651,395863,1323,2707,265877&#125;; static int wCurYear,wCurMonth,wCurDay; static int nTheDate,nIsEnd,m,k,n,i,nBit; TCHAR szNongli[30], szNongliDay[10],szShuXiang[10]; /*---取当前公历年、月、日---*/ wCurYear = pSt-&gt;wYear; wCurMonth = pSt-&gt;wMonth; wCurDay = pSt-&gt;wDay; /*---计算到初始时间1921年2月8日的天数：1921-2-8(正月初一)---*/ nTheDate = (wCurYear - 1921) * 365 + (wCurYear - 1921) / 4 + wCurDay + wMonthAdd [wCurMonth - 1] - 38; if((!(wCurYear % 4)) &amp;&amp; (wCurMonth &gt; 2)) nTheDate = nTheDate + 1; /*--计算农历天干、地支、月、日---*/ nIsEnd = 0; m = 0; while(nIsEnd != 1) &#123; if(wNongliData[m] &lt; 4095) k = 11; else k = 12; n = k; while(n&gt;=0) &#123; //获取wNongliData(m)的第n个二进制位的值 nBit = wNongliData[m]; for(i=1;i&lt;n+1;i++) nBit = nBit/2; nBit = nBit % 2; if (nTheDate &lt;= (29 + nBit)) &#123; nIsEnd = 1; break; &#125; nTheDate = nTheDate - 29 - nBit; n = n - 1; &#125; if(nIsEnd) break; m = m + 1; &#125; wCurYear = 1921 + m; wCurMonth = k - n + 1; wCurDay = nTheDate; if (k == 12) &#123; if (wCurMonth == wNongliData[m] / 65536 + 1) wCurMonth = 1 - wCurMonth; else if (wCurMonth &gt; wNongliData[m] / 65536 + 1) wCurMonth = wCurMonth - 1; &#125; /*--生成农历天干、地支、属相 ==&gt; wNongli--*/ wsprintf(szShuXiang,"%s",cShuXiang[((wCurYear - 4) % 60) % 12]); wsprintf(szNongli,"%s(%s%s)年",szShuXiang,cTianGan[((wCurYear - 4) % 60) % 10],cDiZhi[((wCurYear - 4) % 60) % 12]); /*--生成农历月、日 ==&gt; wNongliDay--*/ if (wCurMonth &lt; 1) wsprintf(szNongliDay,"闰%s",cMonName[-1 * wCurMonth]); else strcpy(szNongliDay,cMonName[wCurMonth]); strcat(szNongliDay,"月"); strcat(szNongliDay,cDayName[wCurDay]); return strcat(szNongli,szNongliDay); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python基础1]]></title>
      <url>%2F2016%2F01%2F21%2F%E5%AD%A6%E4%B9%A0%2Fpython%E5%9F%BA%E7%A1%801%2F</url>
      <content type="text"><![CDATA[前言 我使用的Pycharm编译器，刚开始就遇到了一个问题，不能输入中文，解决办法就是在文件头部添加代码#-*- coding:utf8 -*- Python交互12345678910111213141516171819# 使用python交互模式# 在命令行界面输入｀python｀进入交互模式# ｀help()｀进入帮助模式# 尝试｀keywords｀获取关键字帮助#｀help("modules")｀查看modules# ｀quit｀ 退出帮助模式#dir(object) 它返回传递给它的任何对象的属性名称经过排序的列表#dir()当前倒入的模块#下面以内建函数id为例#获取文档介绍,｀id.__doc__｀#获取名称,并不是所有的都有`id.__name__`属性#`hasattr(dir,'__doc__')`,`getattr(dir,'__doc__')`获取一个对象的属性#callable可调用性`callable("a")` false,`callable(dir)` true#`isinstance("python", str)`,`issubclass(child.father)` 数据类型12345678# 列表(同类型数据构成的数组)list ＝ ［1，2，3，4］# 元组（数据类型可以不同，简单方便的数据聚合，类似结构体）tuple = (1,"second",1.2)# set（数据不重复，使用list构建，无序，不能使用索引访问）set = set([1,2,3,4])# 字典（键值对存储数据）dict ＝ ｛"a":"b","c":"d"｝ 基础语法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218# 打印# 自动追加换行符print "hello world"# 将不会打印换行符号print "hello world",＃ 使用匹配符num = 100num2 = 200print "num is %d"%numprint "num is %d,num2 is %d"%(num,num2)# 内建函数id()和type()a = 3# 获取内存地址print "id(a) is ", id(a)# 获取变量类型print "type(a) is ", type(a)# 运算符(两个比较特殊的)# 级数乘2的3次方print "use ** = ", 2 ** 3# 除后取整print "use // = ", 9 // 4# 逻辑运算 and | or | notif a == 0 and b == 0: a = 2# for in 循环for i in [1, 2, 3, 4]: print i,# 模块的导入的几种方式import mathfrom math import powfrom math import pow,absfrom math import *print pow(10, 3)from math import pow as pingfangprint pingfang(10, 3)# 赋值# 多个赋值可以直接顺序写，会挨个自动赋值x, y, z = 1, "abc", [1, 2, 3]print x, y, z# 自动创建元组，将后面的数据,装入元组xx = 1, 2, 3, 4, "qqq"print xx# 交换数据的方式yy, zz = 3, 4print yy, zzyy, zz = zz, yyprint yy, zz# 链式赋值,两个变量指向统一空间,id()一样的m = n = 123print m, nprint m is n# 判断结构xxx = 1if xxx == 1: print "this is test ", 1elif xxx == 2: print "this is test ", 2else: print "this is test ", 100#获取控制台输入inputNum = raw_input()# 三元运算# A = X if B else Y# 如果B为真,执行A = X,否则执行A = Ymm, nn = 1, 2rstStr = "abc" if mm &gt; nn else "def"print rstStr# for循环和内建函数range(start,stop,step),range(start,stop,1),range(0,stop,1)返回的是数字元素的列表start开始,stop结束,每次增加step个strx = "abcdefg"for i in range(len(strx)): print strx[i],range(9)range(3, 9)range(3, 9, 4)＃ 一个可迭代的对象可以直接转换为序列对象print list(strx)print set(strx)print tuple(strx)# 遍历字典dictStr = &#123;"a": "b", "c": "d"&#125;# 不建议使用,效率相对低for key in dictStr: print "1key value is ", key, dictStr[key]# 遍历keyfor key in dictStr.keys(): print "2key value is ", key, dictStr[key] for key, value in dictStr.items(): print "3key value is ", key, value# 更优for key, value in dictStr.iteritems(): print "4key value is ", key, value # 单独取value使用下面的方法效率更高for value in dictStr.values(): print "5value is ", value# 内建函数zip(),将两个序列数据类型,每一项取出来,合并为一个元组,构成元组的liststr1 = "abcdef"str2 = "12345"print zip(str1, str2, str2)# [('a', '1', '1'), ('b', '2', '2'), ('c', '3', '3'), ('d', '4', '4'), ('e', '5', '5')]# 交换key,value,每个item是两个元素的tuple的list可以直接转换为dictdict1 = &#123;"a": "1", "b": "2", "c": "3"&#125;print dict(zip(dict1.values(), dict1.keys()))# 内建函数enumerate()生成的是（item为下标和元素构成的两元元组）的可迭代对象，可以直接转换为列表mList = ["a", "b", "c", "d", "e"]for (i, j) in enumerate(mList): print i, " -- ", jprint list(enumerate(mList, start=1))#[(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e')]# 替换字符串中的字符,字符串正则分割originStr = "Do u like Canglaoshi? Canglaoshi is a good teather!"splitStrs = originStr.split(" ")for i, s in enumerate(splitStrs): if "Canglaoshi" in s: splitStrs[i] = "Python"# list解析,去掉元素前后空格,list解析可以简单快捷的修改每一个元素，生成新的listoriginList = [" abc", " vbf ", "rtg "]afterList = [one.strip() for one in originList]print afterList# list切片[start = 0,stop = len(list),step = 1],一个简单从list提取部分数据的方式list2cut = [1,2,3,4,5,6,7]listRst = list2cut[0:5:2]print "list2Rst is " ,listRst# 一个猜数字的小程序，简单介绍循环结构和判断结构的简单实用import randomnumber = random.randint(1,100)while(True): print "请输入一个数字,猜测约定的数字是多少?" input = raw_input() if (int)(input) == number: print "正确!" break elif (int)(input) &lt; number: print "太小了!" else: print "太大了!"# for... else 和 while... else# 跳出循环结构之后执行else语句for i in range(1,100): print i,else: print "end"# 迭代list2Iter = [1,2,3,4,5,6]iterIt = iter(list2Iter)# 这里会提示一个警告while True: print iterIt.next()# 文件迭代#f其实是一个可以迭代的对象,可以使用列表操作list2File = [line for line in open(fileName)]print "list2File is ",list2File# 可以更简单list2File = list(open(fileName))print "list2File2 is ",list2File 文件简单操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455文件操作fileName = "/Users/march/123.txt"# 以一种模式打开文件获取可迭代索引file = open(fileName, "rw")for line in file: print line,file.close()#打开文件的模式r 以读方式打开文件，可读取文件信息。w 以写方式打开文件，可向文件写入信息。如文件存在，则清空该文件，再写入新内容a 以追加模式打开文件（即一打开文件，文件指针自动移到文件末尾），如果文件不存在则创建r+ 以读写方式打开文件，可对文件进行读和写操作。w+ 消除文件内容，然后以读写方式打开文件。a+ 以读写方式打开文件，并把文件指针移到文件尾。b 以二进制模式打开文件，而不是以文本模式。该模式只对 Windows 或 Dos 有效，类 Unix 的文件是用二进制模式进行操作的。# 不需要关闭的安全方法with open("/Users/march/123.txt", "a") as ff: ff.write("this is new line")# 获取文件状态import osfileStatus = os.stat(fileName)print fileStatusimport timeprint time.localtime(fileStatus.st_ctime)# 指定size时读取指定size的数据,否则读取全文，下面的所有方法都遵循这一规则file = open(fileName)# 读取字节file.read()file.read(100)# 读取一行file.readline()file.readline(100)# 读取所有数据存储在列表中file.readlines()file.readlines(100)# 移动指针file.seek(10)# 当前指针的位置file.tell()# 另外一种简化的读取文件的方式import fileinputfor line in fileinput.input(fileName): print "use fileinput print is " , line 列表操作12345678910111213141516171819charList = ['1A','2','3','4','5','6','7','8','9','10','11','11']strList = ["1","2","3","4","5","6","7","8","9","10","11","11"]charList.append("new_a")#在指定位置添加元素,指定位置之后的元素向后移动一个,长度+1charList.insert(1,12)#当前元素在列表中的位置print("pos of 3 ",charList.index("3"))#当前元素在列表中出现的次数print("total num of 11 ",charList.count('11'))#将当前字符串\列表(可迭代类型的数据)拆分成单个字符添加在末尾，返回值是noneprint(charList.extend(strList))#从末尾弹出一个元素,或从指定位置弹出,返回值 是该元素print(charList.pop(2))#移除指定元素,不能使用下标做参数charList.remove('1A')#列表反向charList.reverse()#针对第一个字母或数字排序,更多参数比较复杂charList.sort()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android图像处理相关]]></title>
      <url>%2F2016%2F01%2F18%2FAndroid%E5%BC%80%E5%8F%91%2FAndroid%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[Bitmap和Drawable转换12345678910111213141516//drawable 转 bitmappublic static Bitmap drawableToBitmap(Drawable drawable) &#123; int width = drawable.getIntrinsicWidth(); int height = drawable.getIntrinsicHeight(); Bitmap bitmap = Bitmap.createBitmap(width, height, drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565); Canvas canvas = new Canvas(bitmap); drawable.setBounds(0, 0, width, height); drawable.draw(canvas); return bitmap; &#125; //bitmap 转 drawablepublic static Drawable bitmapToDrawble(Bitmap bitmap,Context mcontext)&#123; Drawable drawable = new BitmapDrawable(mcontext.getResources(), bitmap); return drawable; &#125; 获取图片创建的时间1234567891011121314151617181920212223//文件修改的时间File file = new File("");file.lastModified();//获取照片拍摄的时间// MediaStore.Images.Media下面有DATE_TAKEN,DATE_ADD,DATE_MODIFIED的参数，分别是照片拍摄的时间，添加到ContentProvider的时间，最后修改的时间，经过测试显示，DATE_TAKEN这个字段下面的时间是最靠谱的，不说他是不是准确，但是系统相册也是使用的这个时间作为照片信息，亲测。另外，有趣的是，只有DATE_TAKEN这个字段下是毫秒级的，另外两个都是秒级的。public static long getImgCreateTime(Context context, String path) &#123; long createTime = -1; Uri mImageUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI; ContentResolver mContentResolver = context.getContentResolver(); Cursor mCursor = mContentResolver.query(mImageUri, new String[]&#123;MediaStore.Images.Media.DATE_TAKEN&#125;, MediaStore.Images.Media.DATA + "=?", new String[]&#123;path&#125;, MediaStore.Images.Media.DATE_TAKEN); if (mCursor == null) &#123; return -1; &#125; while (mCursor.moveToNext()) &#123; //获取图片的路径 String str = mCursor.getString(mCursor .getColumnIndex(MediaStore.Images.Media.DATE_TAKEN)); createTime = Long.parseLong(str); &#125; return createTime ; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Handler源码分析]]></title>
      <url>%2F2015%2F11%2F17%2F%E5%AD%A6%E4%B9%A0%2FJava_Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[介绍 Handler意思是处理者，它是android特有的用来消息处理的一个类。使用它可以解决很多android中常见的问题. Handler体现的是一种消息的发送与处理异步进行的机制，消息发送时即刻返回，将消息加入队列中，另一端looper负责循环取出消息进行操作。 需要注意的是Handler可以发送Message也可以发送Runnable对象。但是消息处理必定是在Handler所在的线程中，也就是说UI线程中的Handler发送的消息也是在UI线程中执行，所以同样不能执行耗时操作。 使用场景： 发送延时消息，执行延时任务，使用线程睡眠的方式过于粗糙。。通常是用Handler发送延时消息或者使用Timer来完成延时操作。 在子线程“操作”UI，众所周知子线程是不能操作UI的，想要在子线程的任务执行完之后更改UI,就需要在子线程向主线程发送消息让主线程来修改UI。 结合异步任务实现任务回调，这个实际上是等同于2的，因为异步任务内部也是子线程，使用Handler+异步任务可以实现请求的回调，但是通常我们更加偏向于接口回调的方式，而不是传递Handler。 在子线程中使用Handler,对任务进行串行化处理，可以更加高效的管理任务的执行。 Handler原理图解： Looper类介绍 Looper类负责在消息队列的另一端取出消息进行处理，Handler采用消息的先进先出原则。 成员变量 Looper中的成员变量ThreadLocal，提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。查了很多资料，这里有很好的的解释，大家可以去膜拜一下。 Looper类中，首先ThreadLocal变量是private static的，每个线程只能有一个Looper对象，在我看来，使用ThreadLocal是为了对每个线程的Looper进行管理。使用ThreadLocal存储Looper就可以很方便的隔离其他线程随时存取本线程的Looper对象，结合后面的代码，发现创建Looper时会使用当前线程为键，新创建的Looper为值存放到ThreadLocal中，prepare()又会进行判断是否已经创建了该线程的Looper,这么说可能有些抽象，建议看完后面的代码，再回来看这段也许会更加清晰一点。 123456//ThreadLocal.get() will return null unless you've called prepare().static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();private static Looper sMainLooper; // guarded by Looper.class（被这个类保护）final MessageQueue mQueue;final Thread mThread; 构造方法 构造方法,私有化的构造方法，并不允许外部调用，做的操作是创建一个MessageQueue和将mThread对象指向了本线程。这里有个重要的地方是，MessageQueue是Looper创建并首先持有的。 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 在Looper之中有一个private static Looper sMainLooper;变量，这个变量代表主线程（UI）的Looper，这也就是我们不需要在UI线程显式调用Looper.prepare()方法的原因，看下面的代码及注释： 12345678910111213141516171819202122/**//初始化当前线程Looper,将它标记为应用的主要Looper。应用程序的主Looer是Android环境创建的 ,所以你应该不需要自己调用这个函数* Initialize the current thread as a looper, marking it as an* application's main looper. The main looper for your application* is created by the Android environment, so you should never need* to call this function yourself. See also: &#123;@link #prepare()&#125;*/public static void prepareMainLooper() &#123;//进行一次准备并且是不允许打断的prepare(false);synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125;//获取这个loopersMainLooper = myLooper();&#125;&#125;//myLooper返回的是本线程的Looperpublic static Looper myLooper() &#123;return sThreadLocal.get();&#125; 成员方法 prepare方法,创建Looper放入sThreadLocal，同时要求每个线程只能有一个Looper对象，多创建会报异常。 123456789public static void prepare() &#123;prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123;if (sThreadLocal.get() != null) &#123;throw new RuntimeException("Only one Looper may be created per thread");&#125;sThreadLocal.set(new Looper(quitAllowed));&#125; loop方法，使用该方法循环取出MessageQueue的消息。死循环取出消息，进行处理，处理完之后，同时消息会被回收掉，使用这个机制可以进行消息对象的复用，这里loop()结合MessageQueue的next()方法，形成了一个轮询的过程，详细的内容会在MessageQueue类的分析中来看，到时候会解释死循环轮询消息的机制。这里有其他对象的部分方法，暂且不去考虑，做下标记，看到Message的源码自然就会明白。 ###留下的问题： Message msg = queue.next();msg.target.dispatchMessage(msg);msg.recycleUnchecked();稍后我们会去解决。 123456789101112131415161718192021222324public static void loop() &#123;final Looper me = myLooper();if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");&#125;final MessageQueue queue = me.mQueue;// Make sure the identity of this thread is that of the local process,// and keep track of what that identity token actually is.Binder.clearCallingIdentity();final long ident = Binder.clearCallingIdentity();//死循环取出消息，进行处理，当取不到消息时，return掉，等待下次调用loop(),同时消息会被回收掉，使用这个机制可以进行消息对象的复用，这里涉及了Message对象的部分方法，暂且不去考虑，做下标记，看到Message的源码自然就会明白for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123;// No message indicates that the message queue is quitting. return;&#125;msg.target.dispatchMessage(msg);// Make sure that during the course of dispatching the// identity of the thread wasn't corrupted.final long newIdent = Binder.clearCallingIdentity();msg.recycleUnchecked(); &#125;&#125; Message类成员变量 Message类十分类似于Bean类，毕竟它是用来承载消息的。 what,arg1,arg2,obj都是预设好用来盛放简单消息内容的变量，原文的注释中使用了lower-cost表示使用这些变量可以降低开销，就是不用自己创建维护这些变量，而且消息是可以被复用的，确实降低了开销。 target变量，是一个Handler,后面的代码中会具体介绍他的作用，这个变量也算这个类的核心了。 Runnable callback,代表一个任务，前面说过Handler可以发送简单消息也可以发送任务。 Message next，代表下一个Message的引用，由此形成了一个链表的结构。 还有很多常量，变量不做一一介绍。下面有注释，不太详细，大家可以看完后面的再回来看也许会更加清晰。感兴趣的可以仔细去看源码注释。 123456789101112131415161718192021public int what;//消息标示public int arg1; public int arg2;public Object obj;public Messenger replyTo;public int sendingUid = -1;//标示该消息正在使用之中static final int FLAG_IN_USE = 1 &lt;&lt; 0;static final int FLAG_ASYNCHRONOUS = 1 &lt;&lt; 1;tatic final int FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE;int flags;long when;Bundle data;Handler target;//Handler重点哦Runnable callback;//一个任务可以用来发送，类似于Bean的一个属性Message next;//下一个Message，用于构成链表private static final Object sPoolSync = new Object();//同步对象private static Message sPool;//链表根节点，他维护了一个空的Message队列用来复用private static int sPoolSize = 0;//链表的长度private static final int MAX_POOL_SIZE = 50;//链表最大数量private static boolean gCheckRecycle = true; 成员方法obtain() Message类中实现了obtain()的8个重载方法，提供了各种各样的参数，为的只是我们在外部用起来好用，所以大家使用Message时不妨多去用用其他方法，我到现在为止一般都是偏用参数为空的方法，其他的重载基本没看过，另外Handler也提供了大量的obtain方法，是的Message的重用和管理更加的方便了，所以千万不要去new Message。其他的方法也会回调空参方法然后进行一下外围的初始化，所以我们就来看看空参方法。 代码不多，解释一下，首先这个变量sPoolSync，看名字就知道他是用来同步操作的，目的是当一个操作在获取Message是进行同步操作，避免其他的操作再来创建Message，否则会怎么样？Message本身形成了一个链表的结构，不进行同步就会，出现多个头，或者一个Message后面接入多个Message，那么后接入的就会覆盖掉，是这样吗？还是出错误。 接下来是一个判断，我们看到sPool这个变量，它是一个Message对象，经过我的研究它是这个链表的头指针，同时sPool维护的是一个曾经创建过的空的可复用的Message队列，了解这一点至关重要，这是Message可复用的关键。看看他是怎么操作的 如果这个根sPool为空，则返回一个新的Message，Message的构造方法我看了，是个空的，所有的属性都在外部或者发送的那一刻设置。 如果不是空，那么表示可复用Message队列可用，则取出头部的MessageMessage m = sPool,同时指针向后移动一位sPool = m.next;此时m是等于sPool的，以此表示sPool后移一位，然后将取出的Message.next置为null，因为这个消息是要拿来发送的，他此时可是指向的可复用Message队列的头，所以将它的next置为null，不然会怎么样？我们看Looper源码时，循环何时终止呢，就是在next==null时终止，如果不置为null,for循环是不会停止的，会把空的Message队列遍历一遍。最后可复用的链表长度减一sPoolSize--; 其他的obtain方法我们不再去研究，大同小异吧。12345678910111213public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message();&#125; Message的回收方法 看一下代码，了解了上面说的机制，这个代码不难理解。解释一下，如何回收一个Message,要有一个概念就是Message调用该方法回收的是自己，首先将自己的next指向sPoolnext = sPool;也就是说。此时自己已经链接到了可复用的Message队列头部（每次都叫他。可复用的Message队列。真麻烦），然后sPool = this;sPool指针又指向了 可复用的Message队列头部，队列长度++完成了消息的回收。在Looper中提到的msg.recycleUnchecked();这个方法就是在这里实现的。 12345678910 void recycleUnchecked() &#123;.....//这里进行了好多代码，做了一个操作，将成员变量清空。 synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125; &#125; ###补充 Message实现了Parcelable接口表明它是可以传输的。 1public final class Message implements Parcelable &#123;&#125; MessageQueue类介绍 内部通过链接Message形成了一个消息队列，有两个比较核心的方法。boolean enqueueMessage(Message msg, long when){}和Message next()方法，Looper类中遗留的第二个问题Message msg = queue.next();会在这里解释。 入队方法 前面巴拉巴拉一通判断，内部的target不能是null,Message对象不能被占用，线程不能退出。。。。 这里的mMessages变量起到了与Message中sPool相同的作用，它是队列的指针，指向消息队列的头，只是这里维护的队列是要被处理的消息队列。但是由于sendMsgDelay方法的存在，入队时不能单纯的链接消息，还需要判断时间戳。 if (p == null || when == 0 || when &lt; p.when)这个判断if(是第一个消息 ||要被处理的时间是0 ||要被处理的时间小于当前队列头消息的时间也就是已经到达处理这个消息的时间)，此时将会将消息链接在队列头部msg.next = p;，同时指针指向它mMessages = msg;,并且此消息是不要被唤醒的needWake = mBlocked;,这个操作与Message中的操作十分相似，不多做介绍。 else语句块中表明此消息是一个延时消息，此时进行的操作是采用了一个for循环，完成的功能是找到这个消息被处理的时间when，大于这个时间的第一个消息，将它插入到该位置。如果没有找到会一直循环，最后找到preMsg指向的前一个消息和p = mMessage指向的后一消息，进行链接操作，msg.next = p; prev.next = msg;就是普通的链接操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950boolean enqueueMessage(Message msg, long when) &#123;if (msg.target == null) &#123;throw new IllegalArgumentException("Message must have a target.");&#125;if (msg.isInUse()) &#123;throw new IllegalStateException(msg + " This message is already in use.");&#125;synchronized (this) &#123;if (mQuitting) &#123;IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w("MessageQueue", e.getMessage(), e);msg.recycle();return false;&#125;//核心方法从这里开始msg.markInUse();msg.when = when;Message p = mMessages;boolean needWake;if (p == null || when == 0 || when &lt; p.when) &#123;// New head, wake up the event queue if blocked.msg.next = p;mMessages = msg;needWake = mBlocked;&#125; else &#123;// Inserted within the middle of the queue. Usually we don't have to wake// up the event queue unless there is a barrier at the head of the queue// and the message is the earliest asynchronous message in the queue.needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();Message prev;for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125;&#125;msg.next = p; // invariant: p == prev.nextprev.next = msg;&#125;// We can assume mPtr != 0 because mQuitting is false.if (needWake) &#123; nativeWake(mPtr);&#125;&#125;return true;&#125; 出队方法 之前在Looper.loop()方法中看到有这么一段代码,结合MessageQueue的出队方法，可以发现这是一个循环轮询消息队列的操作。在死循环中调用了Message msg = queue.next(); // might block方法，当返回msg==null，循环体结束，什么时候会结束，看next()方法中返回null的只有一种情况就是线程结束时，返回null，线程结束，他的Looper自然应该结束。 死循环实际是发生在MessageQueue中的，我在注释中写了说明。关于MessageQueue的很多本地方法的介绍，大家可以参考这里 12345Message msg = queue.next(); // might blockif (msg == null) &#123;// No message indicates that the message queue is quitting.return;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101Message next() &#123;//// Return here if the message loop has already quit and been disposed.// This can happen if the application tries to restart a looper after quit// which is not supported.final long ptr = mPtr;if (ptr == 0) &#123; return null;&#125;int pendingIdleHandlerCount = -1; // -1 only during first iteration//超时时间int nextPollTimeoutMillis = 0;//开始循环取出消息for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands();&#125;nativePollOnce(ptr, nextPollTimeoutMillis);//接下来进行锁定，开始取出消息synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; //取到消息是空，然后进行一个循环查找下一个可用消息 if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125;if (msg != null) &#123; if (now &lt; msg.when) &#123;// Next message is not ready. Set a timeout to wake up when it is ready.//当前时间没有达到执行这个消息的时间。将会进行超时等待 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; //取出头部的消息返回 // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; return msg;&#125;&#125; else &#123; // No more messages. nextPollTimeoutMillis = -1;&#125;// Process the quit message now that all pending messages have been handled.//线程不存在时返回null，loop()也会随之结束if (mQuitting) &#123; dispose(); return null;&#125;// If first time idle, then get the number of idlers to run.// Idle handles only run if the queue is empty or if the first message// in the queue (possibly a barrier) is due to be handled in the future.if (pendingIdleHandlerCount &lt; 0&amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size();&#125;//死循环发生在这里，具体还没有很明白，需要再去研究if (pendingIdleHandlerCount &lt;= 0) &#123;// No idle handlers to run. Loop and wait some more. mBlocked = true;continue;&#125;if (mPendingIdleHandlers == null) &#123;mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];&#125;mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);&#125;// Run the idle handlers.// We only ever reach this code block during the first iteration.for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handlerboolean keep = false;try &#123; keep = idler.queueIdle();&#125; catch (Throwable t) &#123;Log.wtf("MessageQueue", "IdleHandler threw exception", t);&#125;if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125;&#125;&#125;// Reset the idle handler count to 0 so we do not run them again.pendingIdleHandlerCount = 0;// While calling an idle handler, a new message could have been delivered// so go back and look again for a pending message without waiting.nextPollTimeoutMillis = 0; &#125;&#125; Handler类成员变量12345678//从这里看得出Handler很好的连接了Looper和MessageQueuefinal MessageQueue mQueue;final Looper mLooper;//这是一个接口，用来处理消息，下面是具体实现，也是我们通常要实现的方法。final Callback mCallback;public interface Callback &#123; public boolean handleMessage(Message msg);&#125; 构造方法 重载了多个构造方法，老规矩，我们只看没有最底层的构造方法和我们最常用的构造方法 123456789101112131415161718//常用空参构造方法public Handler() &#123; this(null, false);&#125;//根构造方法public Handler(Callback callback, boolean async) &#123;//获得当前线程的Looper，大家还记得Looper.myLooper()方法吧，return sThreadLocal.get();mLooper = Looper.myLooper();if (mLooper == null) &#123;//必须先调用Looper.prepare()throw new RuntimeException("Can't create handler inside thread that has not called Looper.prepare()");&#125;//拿到Looper的MessageQueue,这个MessageQueue是Looper创建的。mQueue = mLooper.mQueue;//这个是回调，用来处理消息mCallback = callback;mAsynchronous = async;&#125; 成员方法 obtain()方法，这个方法不做解释，返回的是Message的obtain()方法，详细请看Message类的分析。 发送消息，我们浏览一下所有发送消息的方法。方法很多，大致的思想是，填充消息，发送消息，很多方法都是重载互相调用的，关注最后一个方法，它调用了MessageQueue的入队方法，同时将msg.target设置为this,将这个消息插入到了队列中，也就是被发送的Message持有发送它的Handler的引用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//以下是各种发送消息的方法，可以浏览一下。public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;public final boolean postAtTime(Runnable r, long uptimeMillis)&#123; return sendMessageAtTime(getPostMessage(r), uptimeMillis);&#125;public final boolean postAtTime(Runnable r, Object token, long uptimeMillis)&#123; return sendMessageAtTime(getPostMessage(r, token), uptimeMillis);&#125;public final boolean postDelayed(Runnable r, long delayMillis)&#123; return sendMessageDelayed(getPostMessage(r), delayMillis);&#125;public final boolean postAtFrontOfQueue(Runnable r)&#123; return sendMessageAtFrontOfQueue(getPostMessage(r));&#125;public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendEmptyMessage(int what)&#123; return sendEmptyMessageDelayed(what, 0);&#125;public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis);&#125;public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageAtTime(msg, uptimeMillis);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123;delayMillis = 0;&#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException(this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;public final boolean sendMessageAtFrontOfQueue(Message msg) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException(this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, 0);&#125;//这两个方法是发送Runnable任务时会调用的方法private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125;private static Message getPostMessage(Runnable r, Object token) &#123; Message m = Message.obtain(); m.obj = token; m.callback = r; return m;&#125;//消息入队，同时Message将会持有发送它的Handler的引用private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123;msg.setAsynchronous(true);&#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 事件分发与处理 还记得Looper中遗留的问题吗？msg.target.dispatchMessage(msg);结合发送消息的方法，可以得出，msg.target就是发送它的那个Handler,处理消息时调用dispatchMessage方法，也就是下面的方法，所以，Message携带它的发送者，谁发送的消息誰来处理它。 分析一下下面的逻辑。msg.callback是消息中包含的任务，如果是一个任务的消息，那么不需要外部处理，直接调用该Runnable任务的run方法，所以还是在当前线程执行，并没有开启新的线程，不要看到Runnable就想到线程，这也是我以前的一个误区 不是一个Runnable任务，mCallback是一个接口，在介绍成员变量是提到过，他可以通过构造方法在外部实现，当然不是必须实现的，如果实现了这个接口，那么调用这个接口的mCallback.handleMessage(msg)方法处理消息。 如果没有实现这个接口，则调用handleMessage(msg);方法，这个方法是空的，需要你在子类中重载，如果你没有重载他不会执行任何操作。这算提供了处理消息的两种方式。 1234567891011121314151617public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125;private static void handleCallback(Message message) &#123; message.callback.run();&#125;public void handleMessage(Message msg) &#123;&#125; ##总结 线程中Handler消息机制的使用,Looper类中给出了很好的示例代码。注意的是在非UI线程需要我们显式的调用Looper.prepare(); Looper.loop();方法来完成消息的轮询。 123456789101112class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ArrayList源码分析(Java&Android)]]></title>
      <url>%2F2015%2F11%2F15%2F%E5%AD%A6%E4%B9%A0%2FJava_ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[前言 开始看源代码了才知道android和java的源代码有好多出入，都了解一下吧，我把java和android源码比较了一下，相似的还是多的。我是以android源码为主，因为感觉android比较繁琐，不同的地方会贴java的代码对比。 java真的设计的很好，很多类内部实现差别很大，但是在外部看起来是一样的，比如LinkedList和ArrayList,设计良好的API使我们不需要去关注内部的实现，举个例子说，我们需要一个绳子，他可以是真丝制成的，那么它比较坚固，也可以是牛皮制成的，那么它可以不怕水，但是对使用绳子的人来说，他声明自己需要的绳子需要具有什么样的特性，但是他却不知道真丝的需要什么工艺，牛皮的又需要什么工艺。我们程序员就是使用绳子的人，各种各样的List就是绳子，虽然内部实现大相径庭，但是都对外开放了一条绳子的外表，使得我们可以极为方便的使用它，这体现了面向对象的编程思想，也可以使java程序员更加专注的实现功能而不尽量少的关心逻辑和算法。 ArrayList类 ArrayList内部基于数组实现,继承了AbstractList类，实现了Cloneable接口表示其可被克隆复制，实现了Serializable接口表示其可被序列化，实现了RandomAccess接口，表示其可快速随机访问（但是这个接口是空的，只是表示它具有这样的特性）。1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements Cloneable, Serializable, RandomAccess&#123;&#125; 一些常量和成员 android中提供了最小容量，java中并没有这个成员，而是使用了10这个数字作为初始容量。 1234567//anrdroid源码//最小容量private static final int MIN_CAPACITY_INCREMENT = 12;//元素数量int size;//对象数组，transient表示在序列化时它会被忽略。。啥意思？transient Object[] array; 初始化指定初始容量构造 首先容量大于0，如果容量==0会使用EmptyArray.OBJECT来初始化，在android的源码里面链接不到EmptyArray这个类，去了这个网站看到了源码，EmptyArray.OBJECT是一个容量是0的数组。所以也就是说，如果指定容量==0则创建一个容量是0的对象数组，反之创建一个指定容量大小的数组。(java中没有做这个判断，本来这个判断就什么用) 1234567//android 源码public ArrayList(int capacity) &#123; if (capacity &lt; 0) &#123; throw new IllegalArgumentException("capacity &lt; 0: " + capacity); &#125; array = (capacity == 0 ? EmptyArray.OBJECT : new Object[capacity]); &#125; 无参构造函数 同上，初始容量是0。但是java源码中初始容量是10。 12345678//android 源码 public ArrayList() &#123; array = EmptyArray.OBJECT; &#125; //java源码 public ArrayList() &#123;this(10); &#125; 初始化时拷贝集合 主要的操作是判断是不是一个对象数组，如果是直接内部数组直接指向，如果不是进行一次拷贝，java中所有类都继承自Object。这是为了防止基本数据类型吗？（&lt;-这是我不懂的地方）用的方法不一样，java代码更少一点。 System.arraycopy()方法是native修饰的，使用C实现的底层方法。 Arrays.copyOf()函数内部也使用了System.arraycopy()方法。 就是我不懂的那个地方了,感觉使用这个方法可以解决不是对象数组的问题，但是不懂这个判断是为了什么，System.arraycopy又是如何内部实现的。 1234//android 源码if (a.getClass() != Object[].class) &#123;System.arraycopy(a, 0, newArray, 0, a.length);&#125; 1234567891011121314//android 源码public ArrayList(Collection&lt;? extends E&gt; collection) &#123; if (collection == null) &#123; throw new NullPointerException("collection == null"); &#125; Object[] a = collection.toArray(); if (a.getClass() != Object[].class) &#123; Object[] newArray = new Object[a.length]; System.arraycopy(a, 0, newArray, 0, a.length); a = newArray; &#125; array = a; size = a.length;&#125; 12345678//java源码public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; Add方法Android中的实现123456789101112131415161718192021222324252627282930313233343536@Override public boolean add(E object) &#123; Object[] a = array; int s = size; if (s == a.length) &#123; Object[] newArray = new Object[s + (s &lt; (MIN_CAPACITY_INCREMENT / 2) ? MIN_CAPACITY_INCREMENT : s &gt;&gt; 1)]; System.arraycopy(a, 0, newArray, 0, s); array = a = newArray; &#125; a[s] = object; size = s + 1; modCount++; return true; &#125; @Override public void add(int index, E object) &#123; Object[] a = array; int s = size; if (index &gt; s || index &lt; 0) &#123; throwIndexOutOfBoundsException(index, s); &#125; if (s &lt; a.length) &#123; System.arraycopy(a, index, a, index + 1, s - index); &#125; else &#123; // assert s == a.length; Object[] newArray = new Object[newCapacity(s)]; System.arraycopy(a, 0, newArray, 0, index); System.arraycopy(a, index, newArray, index + 1, s - index); array = a = newArray; &#125; a[index] = object; size = s + 1; modCount++; &#125; Java中的实现 跟android基本一样的，之所以代码简单了，是因为java将判断扩容的操作放在了方法实现，但是androd只是将计算新容量的方法提取出来了。 123456789101112131415public boolean add(E e) &#123; ensureCapacity(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125;public void add(int index, E element) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( "Index: "+index+", Size: "+size); ensureCapacity(size+1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; 核心代码分析 解释一下下面这段代码，在java中也是如此实现的只是提取到了方法中，会在下面的扩容机制中说明。 首先最后都进行了一个赋值操作a[index] = object;前面的代码的工作就是将这个位置空出来。代码5 如果当前的size没有超过length,则将index位置之后的位置向后移动一位，将index位置空出来（代码1），如果超过长度了，则进行一次扩容（代码2），将数据拷贝到新数组（代码3），再将数组后移一位（代码4） 它是怎么移动的呢？System.arraycopy(a, index, newArray, index + 1, s - index)了解参数的含义（src,源数组中开始复制的位置，dest,目标数组开始粘贴的位置，复制的长度），这样就明白了，包括代码1是一样的意思，a数组和newArray数组是相同的，将a中index开始的数据复制到newArray中index+1开始的位置，然后复制的长度是s-index,刚好index位置被空出来了，举个例子，数据a={21，22，23，25，26}，newArray={21，22，23，25，26},需要在3的位置插入一个24，则将3开始的size-index(5-3=2)长度的数组也就是25，26，复制到newArray中index+1(3+1=4)开始的位置，得到新数组21，22，23，空，25，26，然后array[3]=24; 123456789101112Object[] a = array;int s = size;if (s &lt; a.length) &#123;System.arraycopy(a, index, a, index + 1, s - index);//---1&#125; else &#123; Object[] newArray = new Object[newCapacity(s)];//---2System.arraycopy(a, 0, newArray, 0, index);//---3System.arraycopy(a, index, newArray, index + 1, s - index);//---4array = a = newArray;&#125;a[index] = object;//5size = s + 1; 扩容机制 单独拿出来是因为android和java扩容机制稍有不同 Android中的实现 扩容时，如果当前容量小于6则让其等于12，否则扩大为原来的两倍。 12345678private static int newCapacity(int currentCapacity) &#123;int increment = (currentCapacity &lt; (MIN_CAPACITY_INCREMENT / 2) ?MIN_CAPACITY_INCREMENT : currentCapacity &gt;&gt; 1);return currentCapacity + increment;&#125;//这只是计算了新的容量，真正的扩容如此实现Object[] newArray = new Object[newCapacity(s)];System.arraycopy(a, 0, newArray, 0, index); java中的实现, java中数组拷贝都是用Arrays.copyOf()方法的，基本原理相同。 可以发现java扩容将容量扩大到了原来容量的1.5倍。 这里有一行代码,看注释的意思是这个方法更加优化了，调皮的程序员a.大意是minCapacity 通常更加逼近size. 1if (newCapacity &lt; minCapacity) newCapacity = minCapacity; 123456789101112public void ensureCapacity(int minCapacity) &#123; modCount++; int oldCapacity = elementData.length; if (minCapacity &gt; oldCapacity) &#123; Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; if (newCapacity &lt; minCapacity) newCapacity = minCapacity; // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125;&#125; 综上 就是核心方法了吧，已经可以了解到它基本的原理，当然还有indexOf(),contains(),remove(),writeObject(),readObject(),内部迭代器的实现，toArray()的实现，set(),addAll()…..其中的原理与上面提到的很多都是相同的，感兴趣的可以自行了解，这里不介绍了，后面有时间再贴一下吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android多类型抽象适配]]></title>
      <url>%2F2015%2F11%2F15%2FAndroid%E5%BC%80%E5%8F%91%2FAdapter%E5%B0%81%E8%A3%853-ListView%E5%A4%9A%E7%B1%BB%E5%9E%8B%E6%8A%BD%E8%B1%A1%E9%80%82%E9%85%8D%2F</url>
      <content type="text"><![CDATA[前言 上一篇文章介绍了如何进行分类适配，看过的小伙伴可以虽然比较完美的实现了分类适配以及复用，但是代码相当繁琐，我们有两种类型时已经出现了多层if嵌套，如果有三四种类型，估计自己都要转晕了，而且就像我们对单类型适配器抽象时做的，避免重复代码！如果没看过上一篇，建议浏览一下，这里写的很多都是基于第一篇的。 抽象ViewHolder12345678910111213141516171819202122232425public static class MultiViewHolder extends ViewHolder&#123; /** * SparseArray */ private SparseArray&lt;View&gt; cacheViews; private View itemView; public MultiViewHolder(View itemView, int viewCount) &#123; super(); this.itemView = itemView; cacheViews = new SparseArray&lt;View&gt;(viewCount); &#125; @Override public View getView(int resId) &#123; View v = cacheViews.get(resId); if (v == null) &#123; v = itemView.findViewById(resId); if (v != null) &#123; cacheViews.put(resId, v); &#125; &#125; return v; &#125;&#125; 使用接口获取对象的类型 我们在分类适配的时候不可避免的要获得数据的对象，以此作为根据装载不同的布局文件. 123456789/** 1. 接口，分类适配的对象需要实现的接口，目的是约束实体类实现getType方法 2. 3. @author chendong 4. */public interface MultiEasyAdapterInterface &#123; public int getType();&#125; 抽象分类适配器 我们需要避免在子类中避免重复编码，同时在子类实现自己的方法，使用抽象父类。 我们不了解传递进来的数据是什么类型，使用泛型。 我们需要限制传进来的数据必须实现获得获得子类的方法，所以必须要求数据实现MultiEasyAdapterInterface接口，使用泛型限定符确定上限。 12public abstract class MultiEasyAdapter&lt;T extends MultiEasyAdapterInterface&gt; extends BaseAdapter &#123;&#125; 成员变量12private LayoutInflater layoutInflater;private List&lt;T&gt; datas; 分析一下其他成员，根据上一篇传统分类适配的写法，我们姑且忽略类型的差异 每个类型需要一个布局资源文件id 每个类型布局文件中字UI控件的个数（用来优化） 每个类型一个唯一的键值（用来解决复用Item空指针的问题） 我们用一个实体类存储这些信息 123456789101112131415161718192021222324252627282930** * 存储类型信息的实体类 * * @author chendong * @功能：分类适配器配置信息实体类 */public class MultiEasyAdapterEntity &#123; /** * @param type * item类型，int类型变量，Item是什么类型的就填写什么类型 * @param resId * 资源id，对应类型的资源id，你需要装载的资源文件的ID * @param viewCount * 资源文件中对应的需要获取的视图的个数 */ public MultiEasyAdapterEntity(int type, int resId, int viewCount) &#123; super(); this.resId = resId; this.viewCount = viewCount; &#125; private int type; private int resId; private int viewCount; public MultiEasyAdapterEntity() &#123; super(); &#125;&#125; 可能有点繁琐，type和viewCount 可以省略掉，加入type是为了更灵活的获得数据类型，viewCount则是为了优化SparseArray,综上第三个成员变量，就是使用type作为键，MultiEasyAdapterEntity作为值的一个SparseArray，他的作用就是存储不同类型的数据适配时需要的配置信息，有点类似配置文件的意思。 1private SparseArray&lt;MultiEasyAdapterEntity&gt; Res4Type; 完善代码 结合分类适配的方法，变量我们已经存储到了SparseArray中，所以代码就很清晰了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * version 2&lt;br/&gt;注意事项：类型数为n时，那么定义的类型必须在0-n-1之间，这是使用listview自带缓存的要求。 * 抽象适配器升级版，可以进行分类适配，使用了模板方法模式，将设置item显示内容的部分抽象到了类外&lt;br/&gt; * @param &lt;T&gt; &lt;br/&gt;必须实现MultiEasyAdapterInterface接口&#123;@link MultiEasyAdapterInterface&#125;&lt;br/&gt; * @author chendong */public abstract class MultiEasyAdapter&lt;T extends MultiEasyAdapterInterface&gt; extends BaseAdapter &#123; private LayoutInflater layoutInflater; private List&lt;T&gt; datas; private SparseArray&lt;MultiEasyAdapterEntity&gt; Res4Type; private Context context; /** * @param context 上下文对象 * @param datas 数据集 * @param Res4Type 资源配置文件&#123;@link MultiEasyAdapterEntity&#125;this is like a config entity */ public MultiEasyAdapter(Context context, List&lt;T&gt; datas, SparseArray&lt;MultiEasyAdapterEntity&gt; Res4Type) &#123; super(); this.layoutInflater = LayoutInflater.from(context); this.datas = datas; this.Res4Type = Res4Type; this.context = context; &#125; protected Context getContext()&#123; return context; &#125; protected List&lt;T&gt; getDatas()&#123; return datas; &#125; public void swapData(List&lt;T&gt; datas)&#123; this.datas = datas; notifyDataSetChanged(); &#125; @Override public int getViewTypeCount() &#123; return Res4Type.size(); &#125; @Override public int getItemViewType(int position) &#123; return datas.get(position).getType(); &#125; public int getCount() &#123; return datas.size(); &#125; public Object getItem(int position) &#123; return datas.get(position); &#125; public long getItemId(int position) &#123; return position; &#125; public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; /* get the type*/ int type = datas.get(position).getType(); if (convertView == null) &#123; int resId = Res4Type.get(type).getResId(); convertView = layoutInflater.inflate(resId, parent, false); holder = new ViewHolder(convertView, Res4Type.get(type) .getViewCount()); convertView.setTag(holder); bindListener4View(holder,datas.get(position), type, position); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; bindData4View(holder,datas.get(position), type, position); return convertView; &#125; /** * 绑定数据 * bind data * * @param holder the viewholder * @param type data&apos;s type * @param data data */ public abstract void bindData4View(ViewHolder holder, T data, int type,int pos); /** * 绑定监听 * bind listener * * @param holder the viewholder * @param type data&apos;s type * @param pos position */ public abstract void bindListener4View(ViewHolder holder, T data, int type,int pos);&#125; 测试1234567891011121314151617181920212223242526272829303132333435363738listview = (ListView) findViewById(R.id.listview); list = new ArrayList&lt;Student&gt;(); for (int i = 0; i &lt; 20; i++) &#123; if (i % 5 == 0) list.add(new Student(&quot;name&quot; + i, &quot;age&quot; + i, &quot;sex&quot;, 3)); else list.add(new Student(&quot;name&quot; + i, &quot;age&quot; + i, &quot;sex&quot;, i % 2 == 0 ? 1 : 2)); &#125; SparseArray&lt;MultiEasyAdapterEntity&gt; sparseArray = new SparseArray&lt;MultiEasyAdapterEntity&gt;( 3); sparseArray.put(1, new MultiEasyAdapterEntity(1, R.layout.item_type1, 4)); sparseArray.put(2, new MultiEasyAdapterEntity(2, R.layout.item_type2, 4)); sparseArray.put(3, new MultiEasyAdapterEntity(3, R.layout.item_type3, 4)); listview.setAdapter(new MultiEasyAdapter&lt;Student&gt;( getApplicationContext(), list, sparseArray) &#123; @Override public void bindData4View(ViewHolder holder, Student data, int type) &#123; ((TextView) holder.getView(R.id.tv_name)).setText(data .getName()); ((TextView) holder.getView(R.id.tv_sex)).setText(data.getSex()); ((TextView) holder.getView(R.id.tv_age)).setText(data.getAge() + &quot;&quot;); if (type == 3) ((TextView) holder.getView(R.id.tv_type)).setText(data .getType()+&quot;&quot;); &#125;@Override public void bindListener4View(ViewHolder holder, Student data, int type) &#123; //绑定监听事件 &#125; &#125;); 效果 大家可以看到三中布局适配的没有问题，只有蓝色背景的布局显示了type,他是类型3的数据]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android单类型抽象适配器]]></title>
      <url>%2F2015%2F11%2F14%2FAndroid%E5%BC%80%E5%8F%91%2FAdapter%E5%B0%81%E8%A3%851-ListView%E5%8D%95%E7%B1%BB%E5%9E%8B%E9%80%82%E9%85%8D%2F</url>
      <content type="text"><![CDATA[前言 介绍一下适配器的抽象，在我们做项目的时候会有很多很多地方使用ListView，也就意味着需要写很多很多的适配器，当我们写的项目很大时就会很烦很烦，每次都要写同样的代码片实现类似的功能，所以我们就有必要对传统的适配器抽象一下。 传统适配器的优化写法 核心代码就是getVIew()方法，在里面我们进行Item的复用，而相对于其他方法就会显得很多余，因为每个适配器都在重复相同的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class FirstpageGridAdapter extends BaseAdapter &#123; /* gridview数据 */ private String[] choices = new String[] &#123; &quot;新房&quot;, &quot;二手房&quot;, &quot;租房&quot;, &quot;资讯&quot;, &quot;打折优惠&quot;, &quot;最新开盘&quot;, &quot;房贷计算&quot;, &quot;更多&quot; &#125;; private int[] images = new int[] &#123; R.drawable.selector_xinfang, R.drawable.selector_ershou, R.drawable.selector_zufang, R.drawable.selector_zixun, R.drawable.selector_youhui, R.drawable.selector_kaipan, R.drawable.selector_calculator, R.drawable.selector_more &#125;; private LayoutInflater layoutInflater; private onClickChildIbListener listener; public FirstpageGridAdapter(Context context, onClickChildIbListener listener) &#123; super(); this.layoutInflater = LayoutInflater.from(context); this.listener = listener; &#125; public interface onClickChildIbListener &#123; public void clickChild(int pos,View view); &#125; public int getCount() &#123; return choices.length; &#125; public Object getItem(int position) &#123; return choices[position]; &#125; public long getItemId(int position) &#123; return position; &#125; public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; if (convertView == null) &#123; holder = new ViewHolder(); convertView = layoutInflater.inflate(R.layout.item_main_grid, parent, false); holder.ib = (ImageButton) convertView .findViewById(R.id.item_main_grid_ib); holder.tv = (TextView) convertView .findViewById(R.id.item_main_grid_tv); convertView.setTag(holder); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; holder.ib.setBackgroundResource(images[position]); holder.tv.setText(choices[position]); final int pos = position; holder.ib.setOnClickListener(new OnClickListener() &#123; public void onClick(View v) &#123; listener.clickChild(pos,v); &#125; &#125;); return convertView; &#125; private class ViewHolder &#123; ImageButton ib; TextView tv; &#125;&#125; 抽象ViewHolder 我们可以分析一下ViewHolder类，它维护一个Item的一组UI组件，如果我们要使用使用通用的ViewHolder就会遇到一个问题，你不知道不同的布局有什么组件在里面，如何维护一组UI呢，数组？链表？或者Map?当查找View时我们使用id来进行查找，那么想在ViewHolder中查找View就需要使用id作为键，我们选择使用SparseArray，也就是稀疏数组，什么是稀疏数组，使用id（大整数）作为键值存储数据会造成大多数的未被使用，如果使用一般的表存储会造成很大的浪费，稀疏数组对数组进行了压缩，节约了很大空间，详见这里 1private SparseArray&lt;View&gt; cacheViews; 使用稀疏数组存储UI控件以后我们需要一个获取UI控件的方法，方法很清晰的，itemView是传递进来的父控件，就是convertView从中根据id获取控件 1234567891011@Override public View getView(int resId) &#123; View v = cacheViews.get(resId); if (v == null) &#123; v = itemView.findViewById(resId); if (v != null) &#123; cacheViews.put(resId, v); &#125; &#125; return v; &#125; ViewHolder完整代码，这里传入了一个viewCount,为什么呢？就像ArrayList一样，不定义空间大小时初始容量16，超出空间大小时每次增加25，但就是初始容量的16对于我们来说已经是浪费了，一个Item不可能有16个控件那么多。指定大小提高内存使用。 12345678910111213141516171819202122232425262728293031/** * * @author chendong * 用来实现复用加载的单类型ViewHolder * */ public static class SingleViewHolder&#123; /** * 使用SparseArray */ private SparseArray&lt;View&gt; cacheViews; private View itemView; public SingleViewHolder(View itemView, int viewCount) &#123; super(); this.itemView = itemView; cacheViews = new SparseArray&lt;View&gt;(viewCount); &#125; @Override public View getView(int resId) &#123; View v = cacheViews.get(resId); if (v == null) &#123; v = itemView.findViewById(resId); if (v != null) &#123; cacheViews.put(resId, v); &#125; &#125; return v; &#125; &#125; 抽象适配器 传统的适配器有太多的重复代码需要编写，我们可以把重复的代码在父类中编写好，使得子类可以直接复用，！使用抽象父类 父类的getView()方法中使用了一个抽象方法，使用了一个设计模式模板方法模式，将方法的实现推迟到了子类中 泛型，传递的数据类型是不确定的，使用泛型可以解决这个问题，泛型的使用不了解的建议搜一下，后面深入的介绍会使用更复杂的泛型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** 1. 抽象适配器，使用了模板方法模式，将设置item显示内容的部分抽象到了类外 这是单类型的抽象适配 2. 3. @author chendong 4. 5. @param &lt;T&gt; 6. 泛型 */public abstract class SingleEasyAdapter&lt;T&gt; extends BaseAdapter &#123; private LayoutInflater layoutInflater; private int resId; private List&lt;T&gt; datas; private int viewCount = 5; /** * @param context * 上下文对象，建议使用getApplicationContext(); * @param resId * item布局id * @param datas * 数据集 * @param viewCount * item中的view个数，用来优化SparseArray&lt;View&gt; */ public SingleEasyAdapter(Context context, int resId, List&lt;T&gt; datas, int viewCount) &#123; super(); this.layoutInflater = LayoutInflater.from(context); this.resId = resId; this.datas = datas; this.viewCount = viewCount; &#125; public int getCount() &#123; return datas.size(); &#125; public Object getItem(int position) &#123; return datas.get(position); &#125; public long getItemId(int position) &#123; return position; &#125; public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; if (convertView == null) &#123; convertView = layoutInflater.inflate(resId, parent, false); holder = new ViewHolder(convertView, viewCount); convertView.setTag(holder); //在这里绑定监听，避免重复绑定。 bindListener4View(holder, datas.get(position), position); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; bindData4View(holder, datas.get(position), position); return convertView; &#125; /** * 绑定数据 * * @param holder * @param data */ public abstract void bindData4View(ViewHolder holder, T data, int pos); /** * 绑定监听 * * @param holder * @param pos */ public abstract void bindListener4View(ViewHolder holder, T data, int pos); &#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * 抽象适配器，使用了模板方法模式，将设置item显示内容的部分抽象到了类外 这是单类型的抽象适配 * * @param &lt;T&gt; 泛型 * @author chendong */public abstract class SingleEasyAdapter&lt;T&gt; extends BaseAdapter &#123; private LayoutInflater layoutInflater; private int resId; private List&lt;T&gt; datas; private int viewCount = 5; private Context context; /** * @param context 上下文对象，建议使用getApplicationContext(); * @param resId item布局id * @param datas 数据集 * @param viewCount item中的view个数，用来优化SparseArray&lt;View&gt; */ public SingleEasyAdapter(Context context, int resId, List&lt;T&gt; datas, int viewCount) &#123; super(); this.layoutInflater = LayoutInflater.from(context); this.resId = resId; this.datas = datas; this.viewCount = viewCount; this.context = context; &#125; public Context getContext() &#123; return this.context; &#125; public List&lt;T&gt; getData() &#123; return datas; &#125; public void swapData(List&lt;T&gt; datas) &#123; this.datas = datas; notifyDataSetChanged(); &#125; public int getCount() &#123; return datas.size(); &#125; public Object getItem(int position) &#123; return datas.get(position); &#125; public long getItemId(int position) &#123; return position; &#125; public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; if (convertView == null) &#123; convertView = layoutInflater.inflate(resId, parent, false); holder = new ViewHolder(convertView, viewCount); convertView.setTag(holder); //在这里绑定监听 bindListener4View(holder, datas.get(position), position); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; bindData4View(holder, datas.get(position), position); return convertView; &#125; /** * 绑定数据 * * @param holder * @param data */ public abstract void bindData4View(ViewHolder holder, T data, int pos); /** * 绑定监听 * * @param holder * @param pos */ public abstract void bindListener4View(ViewHolder holder, T data, int pos);&#125; 测试123456789101112131415161718192021222324listview = (ListView) findViewById(R.id.listview); list = new ArrayList&lt;Student&gt;(); for (int i = 0; i &lt; 20; i++) &#123; if (i % 5 == 0) list.add(new Student(&quot;name&quot; + i, &quot;age&quot; + i, &quot;sex&quot;, 3)); else list.add(new Student(&quot;name&quot; + i, &quot;age&quot; + i, &quot;sex&quot;, i % 2 == 0 ? 1 : 2)); &#125; listview.setAdapter(new SingleEasyAdapter&lt;Student&gt;( getApplicationContext(), R.layout.item_type1, list, 4) &#123; @Override public void bindData4View(SingleViewHolder holder, Student data，int pos) &#123; ((TextView)holder.getView(R.id.tv_name)).setText(data.getName()); //此处省略若干代码 &#125;@Override public void bindListener4View(SingleViewHolder holder, Student data，int pos) &#123; //此处省略若干代码 &#125; &#125;); 效果 可以看到我们只用了很少的代码就完成了功能，而且很清晰，简单地适配不需要创建适配器类了，使用匿名的也很快就可以实现。演示有点丑，基本都实现了。 总结 将适配器抽象出来作为一个类库，再使用的时候就会简单很多很多，当然如果你的适配器数据很复杂，那么也可以继承抽象父类生成自己的类。!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android分类适配]]></title>
      <url>%2F2015%2F11%2F14%2FAndroid%E5%BC%80%E5%8F%91%2FAdapter%E5%B0%81%E8%A3%852-ListView%E5%A4%9A%E7%B1%BB%E5%9E%8B%E9%80%82%E9%85%8D%2F</url>
      <content type="text"><![CDATA[前言 在使用适配器为ListView填充数据时，数据类型往往不是单一的，单一的数据显示太单调，对数据格式要求也比较高，我们在项目中往往使用网络请求获取json数据然后将其显示在Item中，此时获取的数据类型可能会有两到三种格式，此时就用到了分类适配，使用分类适配可以更加友好显示ListView 既然需要分类适配，我们就必须拿到数据的类型，你的数据也就必须直接或者间接的实现获取类型的方法，其实ListView中已经包含了这个获取类型的方法，当然你也可以使用自己的获取类型的方法 12345678910//重写以下两个方法，listview在内部会准备getViewTypeCount()个缓冲区，用来复用同种类型的View,不同类型的View不会出现复用错误。@Overridepublic int getItemViewType(int position) &#123; int type = Integer.parseInt(newsEntities.get(position).getType()); return type;&#125;@Overridepublic int getViewTypeCount() &#123; return count;&#125; 进行分类适配12345678910111213141516171819202122232425262728293031323334public View getView(int position, View convertView, ViewGroup parent) &#123; if (getItemViewType(position) == 1) &#123; ViewHolderVertical holder = null; if (convertView == null) &#123; convertView = layoutInflater.inflate( R.layout.item_firstpagelist_vertical, parent, false); holder = new ViewHolderVertical(); holder.iv = (ImageView) convertView .findViewById(R.id.item_firstpagelist_vertical_iv); //获取其他的控件.... convertView.setTag(holder); &#125; else &#123; holder = (ViewHolderVertical) convertView.getTag(); &#125; NewsEntity entity = newsEntities.get(position); //为控件设置显示的数据.... &#125; else &#123; ViewHolder holder = null; if (convertView == null) &#123; convertView = layoutInflater.inflate( R.layout.item_firstpagelist_horizontal, parent, false); holder = new ViewHolder(); holder.iv = (ImageView) convertView .findViewById(R.id.item_firstpagelist_iv); //获取其他的控件.... convertView.setTag(holder); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; NewsEntity entity = newsEntities.get(position); //为控件设置显示的数据.... &#125; return convertView; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HashMap源码分析（Android&Java）]]></title>
      <url>%2F2015%2F11%2F14%2F%E5%AD%A6%E4%B9%A0%2FJava_HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[前言 基本的数据结构有，数组，链表，树，图。 数组的特点是长度固定，空间连续，占用内存很大，空间复杂度是O(n),但是寻址容易，时间复杂度O(1).总结：寻址容易，插入删除困难。 链表的特点是长度可变，存储空间离散，占用内存小，空间复杂度是O(1),但是寻址困难，时间复杂度为O(n).总结：寻址困难，插入删除容易。 哈希表基于数组结构，采用键值的方式存储数据，插入删除容易，寻址是根据键值直接查找数据，时间复杂度是O(1)，但是使用哈希值存储数据总会出现哈希冲突，解决哈希冲突的方法主要有，开放定址法（再散列），再哈希法，链地址法（拉链法），建立公共溢出区。 缺点：存储空间填满时需要将其复制到另一个更大的数组结构中，并进行再哈希计算，这是哈希表内存占用的暴涨点，这是基于数组结构的一个缺点。 哈希表不能以一种特定的顺序遍历数据结构中的所有数据，如果需要按序存储，使用哈希表并不合适 介绍 HashMap是线程不安全的HashTable是线程安全的。 HashMap就是基于链地址法实现的数据存储。也就是链表的数组。 HashMap允许键 值 为null。HashTable是不允许的。 在Android和Java里面对HashMap的实现，稍有不同，开始我还以为是我的jdk有问题。 在HashMap的基础数组中，每一个数组项称之为一个桶，HashMap就是基于这种桶+链表的结构。 存储方式，使用key值取哈希，一般的算法是hash(key)/len获得他存放位置的下标，这样就将key与下标对应起来。 存储的数据结构 总结来说，HashMap就是数组+内部类（Entry）实现，Entry中具有下一个Entry的引用，由此构成了链表的结构。之前看过有人介绍说是Set+静态内部类，其实并不是。第一行的代码是用来对HashMap进行操作时使用的变量，比如迭代HashMap所有的子项，添加一个EntrySet到HashMap中，删除，修改。。。。 12private transient Set&lt;Entry&lt;K, V&gt;&gt; entrySet;transient HashMapEntry&lt;K, V&gt;[] table; HashMapEntry HashMap中有一个很重要的存储结构HashMapEntry,用来保存键值对，和下一个Entry的引用，这就形成了一个链表结构。 在Java中，这个静态内部类叫Entry,在android中叫HashMapEntry，在功能上应该是相似的。是一个存储数据的基础bean,关注一下源码： 123456789101112131415161718192021222324252627282930313233343536373839static class HashMapEntry&lt;K, V&gt; implements Entry&lt;K, V&gt; &#123; final K key; V value; final int hash; HashMapEntry&lt;K, V&gt; next; HashMapEntry(K key, V value, int hash, HashMapEntry&lt;K, V&gt; next) &#123; this.key = key; this.value = value; this.hash = hash; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V value) &#123; V oldValue = this.value; this.value = value; return oldValue; &#125; @Override public final boolean equals(Object o) &#123; if (!(o instanceof Entry)) &#123; return false; &#125; Entry&lt;?, ?&gt; e = (Entry&lt;?, ?&gt;) o; return Objects.equal(e.getKey(), key) &amp;&amp; Objects.equal(e.getValue(), value); &#125; @Override public final int hashCode() &#123; return (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode()); &#125; @Override public final String toString() &#123; return key + "=" + value; &#125;&#125; 哈希值的计算 存储数据是根据key的哈希值来存储的，类似这样的方法hash(key.hashcode()) Java和Android中对求哈希值的操作相似但是哈希算法不同，当进行存取操作时，key都需要使用这个算法进行中转。 在Android中使用的是Collections类下的静态方法及进行哈希计算，但是这里的h是key的hashcode(),看注释使用的是Wang/Jenkins哈希算法的变体,源代码： 1234567891011//java实现private static int secondaryHash(int h) &#123; // Spread bits to regularize both segment and index locations, // using variant of single-word Wang/Jenkins hash. h += (h &lt;&lt; 15) ^ 0xffffcd7d; h ^= (h &gt;&gt;&gt; 10); h += (h &lt;&lt; 3); h ^= (h &gt;&gt;&gt; 6); h += (h &lt;&lt; 2) + (h &lt;&lt; 14); return h ^ (h &gt;&gt;&gt; 16);&#125; 12345678//android实现static int hash(int h) &#123; // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; put方法 检查键值是否为空，null时将存储到forNullEntry所在的链表中。 获取哈希值之后获得下标索引，检查key是否已经存在，是则替换，否则添加到当前链表，基本思想是这样的，几个不同的点 putForNullKey(value)方法，在Android和Java中都有实现，当键值为null时，分配一个数组的一项，这个数组指向key == null 的Entry 一个不同点，Java中是在添加Entry之后重新计算容量，而Android是在AddNewEntry之前进行。 扩容的方法都是扩大为原来的两倍。 在Android中的实现基本类似，使用Collections静态方法进行二次哈希计算，计算下表索引 123456789101112131415161718192021222324252627282930313233//在java中的实现代码:public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); int hash = hash(key.hashCode()); //计算hash值，使用indexFor（）这个函数获得该哈希值对应数组下标，由此可以得到对应的那个链表。 int i = indexFor(hash, table.length ); for (Entry&lt;K,V&gt; e = table [i]; e != null; e = e.next) &#123; Object k; //关注这部分代码是替换掉已经存在的key对应的value if (e.hash == hash &amp;&amp; ((k = e.key ) == key || key.equals(k))) &#123; V oldValue = e. value; e. value = value; e.recordAccess( this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null ; &#125; //解释一下这部分代码，做的操作就是将新添加的Entry放在链表的头部，而原来的链表会接在这个新的Entry后面。void addEntry(int hash, K key, V value, int bucketIndex) &#123;//注意这里的bucketIndex是上一个函数得到的数组下标。取到该数组项链接的Entry给了临时变量eEntry&lt;K,V&gt; e = table [bucketIndex];//新建了一个Entry将其链接到了数组项上，然后把e给了新的Entry的Next,也就是后面的链表重新链接到了新的Entry后面，而新的Entry作为了该链表的第一项。table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);//添加之后重新计算容量。if (size ++ &gt;= threshold) resize(2 * table.length );&#125; 12345678910111213141516171819202122232425262728293031//android中的实现@Override public V put(K key, V value) &#123; if (key == null) &#123; return putValueForNullKey(value); &#125; int hash = Collections.secondaryHash(key); HashMapEntry&lt;K, V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); for (HashMapEntry&lt;K, V&gt; e = tab[index]; e != null; e = e.next) &#123; if (e.hash == hash &amp;&amp; key.equals(e.key)) &#123; preModify(e); V oldValue = e.value; e.value = value; return oldValue; &#125; &#125; // No entry for (non-null) key is present; create one modCount++; //注意这里是先进行扩容后进行添加的 if (size++ &gt; threshold) &#123; tab = doubleCapacity(); index = hash &amp; (tab.length - 1); &#125; addNewEntry(key, value, hash, index); return null;&#125;//Android添加代码就更简单了，不过也很好理解，操作与java中是一样的。不过方法很巧//妙，简化了代码，让我想起了InputStream is = new FileInputStream("path")is = new BufferedInputStream(is)`void addNewEntry(K key, V value, int hash, int index) &#123;table[index] = new HashMapEntry&lt;K, V&gt;(key, value, hash, table[index]);&#125; get方法 同样的获取hashcode,再哈希计算哈希值，获得下标索引，得到对应链表，遍历链表得到结果，在Java和Android中实现大同小异. 1234567891011121314//java中的实现public V get(Object key) &#123; if (key == null) return getForNullKey(); int hash = hash(key.hashCode()); for (Entry&lt;K,V&gt; e = table [indexFor(hash, table.length )]; e != null; e = e. next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value ; &#125; return null; &#125; 123456789101112131415161718//Android中的实现public V get(Object key) &#123; if (key == null) &#123; HashMapEntry&lt;K, V&gt; e = entryForNullKey; return e == null ? null : e.value; &#125; int hash = Collections.secondaryHash(key); HashMapEntry&lt;K, V&gt;[] tab = table; for (HashMapEntry&lt;K, V&gt; e = tab[hash &amp; (tab.length - 1)]; e != null; e = e.next) &#123; K eKey = e.key; if (eKey == key || (e.hash == hash &amp;&amp; key.equals(eKey))) &#123; return e.value; &#125; &#125; return null;&#125; 初始化 在Java和Android中HashMap的初始化略有不同,Android中初始容量是2，Java中初始容量是16。 Java实现 Java中的初始容量和负载因子是学习Java比较经典的内容，看一下Java中HashMap的默认构造方法 123456789static final int DEFAULT_INITIAL_CAPACITY = 16;static final float DEFAULT_LOAD_FACTOR = 0.75f;public HashMap() &#123;//默认的构造方法会初始化一个容量是16，负载因子0.75的HashMap,threshold有阈值的意思，就是当前容量可以承受的负载,当超过这个负载时就会进行扩容。this.loadFactor = DEFAULT_LOAD_FACTOR;threshold = (int )(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR );table = new Entry[DEFAULT_INITIAL_CAPACITY];init();&#125; 带有参数的构造方法实现 12345678910111213141516171819202122232425262728293031323334//指定容量和负载因子时会检查容量和负载因子的值是不是有问题//然后会进行一个位运算算法获得-》大于当前要求的容量的-》最小的2的幂//（也就是如果是7--》8如果是9--》16）public HashMap(int initialCapacity, float loadFactor) &#123;if (initialCapacity &lt; 0)throw new IllegalArgumentException("Illegal initial capacity: " +initialCapacity);if (initialCapacity &gt; MAXIMUM_CAPACITY)initialCapacity = MAXIMUM_CAPACITY;if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))throw new IllegalArgumentException("Illegal load factor: " +loadFactor);// Find a power of 2 &gt;= initialCapacity//算法原理：capacity初始为1，当capacity小于initialCapacity时左移一位，就是*2,直到找到大于当前要求的容量最小的2的幂int capacity = 1;while (capacity &lt; initialCapacity)capacity &lt;&lt;= 1;this.loadFactor = loadFactor;threshold = (int )(capacity * loadFactor);table = new Entry[capacity];init();&#125;//容量增加，transfer(newTable);会将原来的数据再哈希重新放入数据void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length ; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor); &#125; 在Android中的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//默认的初始最小容量是4，一个静态的初始数组的容量是最小容量无符号右移1位，也就是2，默认构造时，会将该静态数组交给table,这里有一行源码的注释（ Forces first put invocation to replace EMPTY_TABLE），意思是根据第一次put方法加入的数量来扩充数组，此时负载容量是-1，添加时会立刻扩充容量，这可能也是为什么Android中添加元素是先检查扩充容量再添加的原因。。在put时第一次百分百检测到容量不够，此时进行一次doubleCapacity()将容量加倍，在这个方法中会调用private static final int MINIMUM_CAPACITY = 4;private static final Entry[] EMPTY_TABLE = new HashMapEntry[MINIMUM_CAPACITY &gt;&gt;&gt; 1];public HashMap() &#123; table = (HashMapEntry&lt;K, V&gt;[]) EMPTY_TABLE; threshold = -1; // Forces first put invocation to replace EMPTY_TABLE&#125;//容量增长或初始化时会调用该方法，重置阈值，与Java稍有不同，使用固定的容量的3/4来作为阈值，Java中还要比较容量的大小，取Math.min(容量，)private HashMapEntry&lt;K, V&gt;[] doubleCapacity() &#123; HashMapEntry&lt;K, V&gt;[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; return oldTable; &#125; int newCapacity = oldCapacity * 2; HashMapEntry&lt;K, V&gt;[] newTable = makeTable(newCapacity); if (size == 0) &#123; return newTable; &#125; for (int j = 0; j &lt; oldCapacity; j++) &#123; /* * Rehash the bucket using the minimum number of field writes. * This is the most subtle and delicate code in the class. */ HashMapEntry&lt;K, V&gt; e = oldTable[j]; if (e == null) &#123; continue; &#125; int highBit = e.hash &amp; oldCapacity; HashMapEntry&lt;K, V&gt; broken = null; newTable[j | highBit] = e; for (HashMapEntry&lt;K, V&gt; n = e.next; n != null; e = n, n = n.next) &#123; int nextHighBit = n.hash &amp; oldCapacity; if (nextHighBit != highBit) &#123; if (broken == null) newTable[j | nextHighBit] = n; else broken.next = n; broken = e; highBit = nextHighBit; &#125; &#125; if (broken != null) broken.next = null; &#125; return newTable;&#125;private HashMapEntry&lt;K, V&gt;[] makeTable(int newCapacity) &#123; @SuppressWarnings("unchecked") HashMapEntry&lt;K, V&gt;[] newTable = (HashMapEntry&lt;K, V&gt;[]) new HashMapEntry[newCapacity]; table = newTable; //阈值时是容量的3/4,使用了位运算 threshold = (newCapacity &gt;&gt; 1) + (newCapacity &gt;&gt; 2); // 3/4 capacity return newTable;&#125;//同样的检查机制，然后使用了一个方法，又是Collections类中的方法Collections.roundUpToPowerOfTwo(capacity);，作用是一样的，将容量修改为大于输入容量的最小的2的幂。但是使用二进制实现，会不会更牛逼一点。public HashMap(int capacity) &#123; if (capacity &lt; 0) &#123; throw new IllegalArgumentException("Capacity: " + capacity); &#125; if (capacity == 0) &#123; @SuppressWarnings("unchecked") HashMapEntry&lt;K, V&gt;[] tab = (HashMapEntry&lt;K, V&gt;[]) EMPTY_TABLE; table = tab; threshold = -1; // Forces first put() to replace EMPTY_TABLE return; &#125; if (capacity &lt; MINIMUM_CAPACITY) &#123; capacity = MINIMUM_CAPACITY; &#125; else if (capacity &gt; MAXIMUM_CAPACITY) &#123; capacity = MAXIMUM_CAPACITY; &#125; else &#123; capacity = Collections.roundUpToPowerOfTwo(capacity); &#125; makeTable(capacity);&#125;//看不懂啊，应该收藏一下关于二进制的算法，高大上的别人都看不懂public static int roundUpToPowerOfTwo(int i) &#123; i--; // If input is a power of two, shift its high-order bit right. // "Smear" the high-order bit all the way to the right. i |= i &gt;&gt;&gt; 1; i |= i &gt;&gt;&gt; 2; i |= i &gt;&gt;&gt; 4; i |= i &gt;&gt;&gt; 8; i |= i &gt;&gt;&gt; 16; return i + 1;&#125; 更多 JDK1.8在容量过大时使用红黑树存储数据，事件复杂度O(logn),对于红黑树不是很了解，算法很菜，暂时放放吧。 阈值 = 容量 负载因子，当容量超过阈值时会进行扩容和再散列，此时是hashmap的内存占用的增长点，扩容会将容量扩大为原来的两倍然后将数据拷贝到新的区域进行再散列。但是这里有个问题不太懂：HashMap扩容，每次添加一个元素size++,当size&gt;阈值（容量负载因子）时进行扩容，但是HashMap是基于数组+链表的，添加的元素不一定集中到一个数组项。举个例子说，当一个hashmap容量是16，阈值就是12，此时添加的元素如果有12个了，但是却只是集中在某几个数组项所在 的链表中，那么此时进行扩容合适吗？暂时合理的解释是hash（）算法可以很好的将数据分散在所有的数组项中，那么这种比较也是比较合理的。 为什么要将初始容量计算得到大于该容量的最小的2的幂？我们可以看一下这个代码int index = hash &amp; (tab.length - 1);在java中有相同的设计是一个函数indexfor(int hash)在计算hashcode对应的数组下标时使用hash&amp;len-1代替了hash%len，只有在len是2的幂时，这两个方法才是等价不等效的。可能不太好理解，举个例子：len是16时，二进制10000，len-1是01111，如果得到的hash小于16时，比如是3吧，进行&amp;运算01111&amp;00011得到的结果是3，也就是本身。确实等价于3%16，再比如大于16，是19吧，再大也是一个意思，也就是01111&amp;10011得到的结果是3，等价于19%16，右数第5位以上的1都被过滤掉了，说这么多只是解释一下确实hash&amp;len-1等价于hash%len，但是使用位运算效率会大大提高，在源码中位运算随处可见。ps:我总觉的还有别的作用，但是没有了解到。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android新控件RecyclerView]]></title>
      <url>%2F2015%2F11%2F12%2FAndroid%E5%BC%80%E5%8F%91%2FAndroid%E6%96%B0%E6%8E%A7%E4%BB%B6RecyclerView%2F</url>
      <content type="text"><![CDATA[前言 RecycerView是类似于ListView和GridView的控件，可以使用列表的形式展示数据，同时也很好的支持了瀑布流的模式，但是他根本上是继承自ViewGroup的public class RecyclerView extends ViewGroup implements ScrollingView, NestedScrollingChild。 LayoutManager 在代码中设置LayoutManager，需要在设置adapter之前设置LayoutManager 12345678RecyclerView.LayoutManager layoutManager = null;//线性布局，第二个参数支持水平垂直两种方向，第三个参数用来设置是否反向显示layoutManager = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false);//网格布局，第二个参数设置列数，第三个参数支持水平垂直两种方向，第四个参数用来设置是否反向显示layoutManager = new GridLayoutManager(this,3,GridLayoutManager.HORIZONTAL,false);//瀑布流布局，第一个参数设置列数，第二个参数支持水平垂直两种方向 layoutManager = new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL);recyclerView.setLayoutManager(layoutManager); ViewHolder 继承Recycler.ViewHolder实现自定义ViewHolder 1234567891011121314151617//这里只是实现简单的功能，旨在介绍了解RecyclerView的使用。//需要注意的一点是，RecyclerView并没有实现OnItemClickListener事件，也就是我们无法直接获得Item的点击事件。//采用的方法是在最外层的父布局添加点击事件来模拟Item点击。//getAdapterPosition();函数获取当前Item在Adapter中的位置//getLayoutPosition());函数获得当前Item在布局中的位置class CustomViewHolder extends RecyclerView.ViewHolder &#123; TextView tv; public CustomViewHolder (View itemView) &#123; super(itemView); tv = (TextView) itemView.findViewById(R.id.test_tv); itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.i("chendong", "点击了item" + getAdapterPosition() + " layout --"+getLayoutPosition()); &#125; &#125;); &#125; &#125; Adapter 继承Recycler.Adapter实现适配器 123456789101112131415161718192021222324252627282930class ContentAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; &#123; public ContentAdapter() &#123; //在这里获得需要的参数 &#125; @Override public int getItemViewType(int position) &#123; //获取数据的类型，用于多类型适配 &#125; @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; //获取对应类型的ViewHolder,加载不同的布局，类似ListView中getView（）的代码，示例代码： View view = getLayoutInflater().inflate(R.layout.test, parent, false); return new CustomViewHolder(view); &#125; @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; //向ViewHolder中的控件绑定数据,这里用的是强转，也可以使用泛型直接生成CustomViewHolder，但是多类型适配时还是需要强转。 CustomViewHolder temp = (CustomViewHolder)holder; holder.tv.setText("a"); &#125; @Override public int getItemCount() &#123; //获取Item个数 return 0; &#125; &#125; 数据更新1234567891011121314151617//类似ListView的数据更新，但是开放了更多方法，由于RecyclerView继承自ViewGroup，可以轻松实现对其中每一个控件的操作，而不用更新整个列表。//舒心列表adapter.notifyDataSetChanged();//删除某一位置的Itemadapter.notifyItemRemoved(0);//修改某一位置的Itemadapter.notifyItemChanged(0);//向某一位置掺入Itemadapter.notifyItemInserted(0);//将pos1的Item移动到pos2adapter.notifyItemMoved(0,1);//通知部分Item改变adapter.notifyItemRangeChanged(0,4);//向0-4的位置插入数据adapter.notifyItemRangeInserted(0,4);//移除0-4的数据adapter.notifyItemRangeRemoved(0,4); 分割线 RecyclerView提供了插入分隔线的方法，但是是个抽象类，需要我们自己重写，并且没有实现好的默认分隔线。1234567891011121314151617recyclerView.addItemDecoration(new RecyclerView.ItemDecoration() &#123;//onDraw方法先于绘制Item @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDraw(c, parent, state); &#125;//onDrawOver在绘制Item之后，一般我们选择复写其中一个即可。 @Override public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDrawOver(c, parent, state); &#125;//getItemOffsets 可以通过outRect.set()为每个Item设置一定的偏移量，主要用于绘制 @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); &#125; &#125;); 动画效果 RecyclerView为数据的更新增加了动画效果,并且提供了一个默认的动画，我们可以通过实现ItemAnimator实现自己的动画效果。 1recyclerView.setItemAnimator(new DefaultItemAnimator()); 总结 RecyclerView采用插拔式的数据填充，提供了更加强大的显示效果，可以轻松实现，各个方向的ListView,GridView,瀑布流效果，简单方便。但在进行多类型分类适配时需要创建大量的ViewHolder，需要我们进一步取封装和完善。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义控件(2)—继承ViewGroup]]></title>
      <url>%2F2015%2F11%2F01%2FAndroid%E5%BC%80%E5%8F%91%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B62%E7%BB%A7%E6%89%BFViewgroup%2F</url>
      <content type="text"><![CDATA[前言 继承ViewGroup是自定义控件的一般方法，根据需要选择需要继承的ViewGroup的子类，本章将使用纯代码添加控件,方式确实不直观，但是可以用来练习使用代码操作控件的方法，毕竟不是所有的代码都可以用xml文件代替。 案例介绍 这次的目的实现一个类似这样的组合控件，出现这种需求是因为需要在一个ListView中添加一个类似ListView的部分，但是数量很少，可以不需要使用ListView,而是使用动态添加控件的方式。 代码 完全使用代码来写控件，没有xml布局，调试的时候是个大问题，写的代码往往不能实时的显示在预览界面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181public class SpecialItemView extends RelativeLayout &#123; //分析该布局定义以下组件 //图片 private ImageView imgIcon; //标题 private TextView txtTitle; //子标题 private TextView txtSubTitle; //专辑数量 private TextView txtNum; //右边更多按钮 private ImageButton ibArrow; //下方横线，因为最后一行是不显示横线的 private ImageView ivLine; /** * 代码中new时使用 * * @param context */ public SpecialItemView(Context context) &#123; this(context, null); &#125; /** * 在xml文件中使用 * * @param context * @param attrs */ public SpecialItemView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context, attrs); &#125; /** * 初始化 * * @param context * @param attributeSet */ private void init(Context context, AttributeSet attributeSet) &#123; //获取屏幕宽度 int width = context.getResources().getDisplayMetrics().widthPixels; //设置当前控件的padding this.setPadding(6,10,6,10); //初始化控件 imgIcon = new ImageView(context); //LayoutParams对象用来控制控件在ViewGroup中显示的样子 RelativeLayout.LayoutParams layoutParams = new LayoutParams((int) (width*0.2),(int) (width*0.2)); //垂直居中相当于layout_centervertical=true layoutParams.addRule(CENTER_VERTICAL); //配置控件 imgIcon.setScaleType(ImageView.ScaleType.CENTER_CROP); imgIcon.setLayoutParams(layoutParams); //相当于android:id imgIcon.setId(R.id.sp_item_icon); imgIcon.setImageResource(R.mipmap.finding_zone_img); //添加控件到ViewGroup addView(imgIcon); //除了可以设置为具体的数值，也可以使用常量，相当于xml文件中使用android：layout_width = "wrap_content" layoutParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); //左边margin layoutParams.leftMargin = 20; //相当于android:aligntop="R.id.sp_item_icon" layoutParams.addRule(ALIGN_TOP, R.id.sp_item_icon); layoutParams.addRule(RIGHT_OF, R.id.sp_item_icon); //以下是textview的设置 txtTitle.setText("标题"); txtTitle = new TextView(context); txtTitle.setId(R.id.sp_item_title); txtTitle.setTextSize(TypedValue.COMPLEX_UNIT_SP,18); txtTitle.setTextColor(Color.BLACK); txtTitle.setLayoutParams(layoutParams); txtTitle.setSingleLine(); txtTitle.setEllipsize(TextUtils.TruncateAt.END); addView(txtTitle); txtSubTitle = new TextView(context); txtSubTitle.setId(R.id.sp_item_subtitle); layoutParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); //todo sp2dp layoutParams.addRule(CENTER_VERTICAL); layoutParams.addRule(ALIGN_LEFT, R.id.sp_item_title); txtSubTitle.setText("字标题"); //todo sp2dp txtSubTitle.setTextSize(TypedValue.COMPLEX_UNIT_SP, 16); txtSubTitle.setTextColor(Color.GRAY); txtSubTitle.setLayoutParams(layoutParams); txtSubTitle.setPadding(0,0,16,0); txtSubTitle.setSingleLine(); txtSubTitle.setEllipsize(TextUtils.TruncateAt.END); addView(txtSubTitle); txtNum = new TextView(context); txtNum.setId(R.id.sp_item_subtitle); layoutParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); //todo sp2dp layoutParams.addRule(ALIGN_LEFT, R.id.sp_item_title); layoutParams.addRule(ALIGN_BOTTOM, R.id.sp_item_icon); txtNum.setText("共有几张专辑"); //todo sp2dp txtNum.setTextSize(TypedValue.COMPLEX_UNIT_SP, 16); txtNum.setTextColor(Color.GRAY); txtNum.setLayoutParams(layoutParams); txtNum.setSingleLine(); txtNum.setEllipsize(TextUtils.TruncateAt.END); txtNum.setGravity(CENTER_VERTICAL); //图标必须经过setbounds Drawable leftD = ContextCompat.getDrawable(getContext(), R.mipmap.finding_album_img); leftD.setBounds(0, 0, 20, 0); txtNum.setCompoundDrawablesWithIntrinsicBounds(leftD, null, null, null); txtNum.setId(R.id.sp_item_num); addView(txtNum); ibArrow = new ImageButton(context); ibArrow.setId(R.id.sp_item_subtitle); layoutParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); //todo sp2dp layoutParams.addRule(CENTER_VERTICAL); layoutParams.addRule(ALIGN_PARENT_RIGHT); //todo sp2dp layoutParams.rightMargin = 16; ibArrow.setBackgroundResource(R.drawable.selector_more); //todo sp2dp ibArrow.setLayoutParams(layoutParams); addView(ibArrow); ivLine = new ImageView(context); layoutParams = new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,1); layoutParams.addRule(ALIGN_LEFT,R.id.sp_item_title); layoutParams.addRule(BELOW,R.id.sp_item_num); //todo sp2dp layoutParams.topMargin=10; ivLine.setLayoutParams(layoutParams); ivLine.setBackgroundResource(R.drawable.shape_line); addView(ivLine); &#125; public void setTitle(String txt)&#123; txtTitle.setText(txt==null?"":txt); &#125; public void setSubTitle(String txt)&#123; txtSubTitle.setText(txt==null?"":txt); &#125; public void setNum(String txt)&#123; txtNum.setText(txt==null?"":txt); &#125; public void setShowLine(int xx)&#123; ivLine.setVisibility(xx); &#125; public void setImg(String url)&#123; Picasso.with(getContext()).load(url).into(imgIcon); &#125; public ImageView getImgIcon()&#123; return imgIcon; &#125; public ImageButton getImgArrow()&#123; return ibArrow; &#125; private OnMoreClick onMoreClick; public //使用接口将ibArrow点击事件传递出去 public interface OnMoreClick&#123; void click(); &#125;&#125; 在xml文件中使用1234&lt;com.march.himalayasfm.app.widgets.SpecialItemView android:layout_width="match_parent" android:layout_height="wrap_content" /&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android新控件CardView]]></title>
      <url>%2F2015%2F10%2F14%2FAndroid%E5%BC%80%E5%8F%91%2FAndroid%E6%96%B0%E6%8E%A7%E4%BB%B6CardView%2F</url>
      <content type="text"><![CDATA[Gradle compile &#39;com.android.support:cardview-v7:21.+ xml文件1234567891011121314&lt;android.support.v7.widget.CardViewandroid:layout_marginTop="20dp" android:layout_width="wrap_content"android:layout_height="wrap_content"app:cardCornerRadius="10dp"app:cardElevation="5dp"app:contentPadding="10dp" app:cardPreventCornerOverlap="true"&gt;&lt;ImageView android:scaleType="centerCrop"android:src="@mipmap/test" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt;&lt;/android.support.v7.widget.CardView&gt; 几个属性值1234567891011121314app:cardElevation=&quot;5dp&quot;//阴影app:cardElevation 阴影的大小app:cardMaxElevation 阴影最大高度app:cardBackgroundColor 卡片的背景色app:cardCornerRadius 卡片的圆角大小app:contentPadding 卡片内容于边距的间隔app:contentPaddingBottomapp:contentPaddingTopapp:contentPaddingLeftapp:contentPaddingRightapp:contentPaddingStartapp:contentPaddingEndapp:cardUseCompatPadding 设置内边距，V21+的版本和之前的版本仍旧具有一样的计算方式app:cardPreventConrerOverlap 在V20和之前的版本中添加内边距，这个属性为了防止内容和边角的重叠]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序之Java中的Sort函数]]></title>
      <url>%2F2015%2F10%2F10%2F%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%2F%E6%8E%92%E5%BA%8F%E4%B9%8BJava%E4%B8%AD%E7%9A%84Sort%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[Arrays.sort() Arrays.sort()使用了两种排序方法，快速排序和优化的合并排序。 快速排序主要是对哪些基本类型数据（int,short,long等）排序。 而合并排序用于对对象类型进行排序。 原因 使用不同类型的排序算法主要是由于快速排序是不稳定的，而合并排序是稳定的。这里的稳定是指比较相等的数据在排序之后仍然按照排序之前的前后顺序排列。对于基本数据类型，稳定性没有意义，而对于对象类型，稳定性是比较重要的，因为对象相等的判断可能只是判断关键属性，最好保持相等对象的非关键属性的顺序与排序前一致。 另外一个原因是由于合并排序相对而言 比较次数 比快速排序少， 移动(对象引用的移动)次数 比快速排序多，而对于对象来说，移动是简单的，只是引用的转换，但是比较相对更加耗时。 合并排序的时间复杂度是n*logn, 快速排序的平均时间复杂度也是n*logn，但是合并排序的需要额外的n个引用的空间。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ADB命令大全]]></title>
      <url>%2F2015%2F09%2F07%2F%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%2FADB%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
      <content type="text"><![CDATA[ADB，即 Android Debug Bridge，它是 Android 开发/测试人员不可替代的强大工具，也是 Android 设备玩家的好玩具。 持续更新中，欢迎提 PR 和 Issue 补充指正，觉得有用的可以将 此 GitHub 仓库 Star 收藏备用。 注：有部分命令的支持情况可能与 Android 系统版本及定制 ROM 的实现有关。 基本用法 命令语法 为命令指定目标设备 启动/停止 查看 adb 版本 以 root 权限运行 adbd 指定 adb server 的网络端口 设备连接管理 查询已连接设备/模拟器 USB 连接 无线连接（需要借助 USB 线） 无线连接（无需借助 USB 线） 应用管理 查看应用列表 所有应用 系统应用 第三方应用 包名包含某字符串的应用 安装 APK 卸载应用 清除应用数据与缓存 查看前台 Activity 与应用交互 调起 Activity 调起 Service 发送广播 强制停止应用 文件管理 复制设备里的文件到电脑 复制电脑里的文件到设备 模拟按键/输入 电源键 菜单键 HOME 键 返回键 音量控制 媒体控制 点亮/熄灭屏幕 滑动解锁 输入文本 查看日志 Android 日志 按级别过滤日志 按 tag 和级别过滤日志 日志格式 清空日志 内核日志 查看设备信息 型号 电池状况 屏幕分辨率 屏幕密度 显示屏参数 android_id IMEI Android 系统版本 Mac 地址 CPU 信息 内存信息 更多硬件与系统属性 实用功能 屏幕截图 录制屏幕 重新挂载 system 分区为可写 查看连接过的 WiFi 密码 设置系统日期和时间 重启手机 检测设备是否已 root 使用 Monkey 进行压力测试 开启/关闭 WiFi 刷机相关命令 重启到 Recovery 模式 从 Recovery 重启到 Android 重启到 Fastboot 模式 通过 sideload 更新系统 更多 adb shell 命令 查看进程 查看实时资源占用情况 其它 adb 的非官方实现 致谢 参考链接 基本用法命令语法adb 命令的基本语法如下： 1adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt; 如果只有一个设备/模拟器连接时，可以省略掉 [-d|-e|-s &lt;serialNumber&gt;] 这一部分，直接使用 adb &lt;command&gt;。 为命令指定目标设备如果有多个设备/模拟器连接，则需要为命令指定目标设备。 参数 含义 -d 指定当前唯一通过 USB 连接的 Android 设备为命令目标 -e 指定当前唯一运行的模拟器为命令目标 -s &lt;serialNumber&gt; 指定相应 serialNumber 号的设备/模拟器为命令目标 在多个设备/模拟器连接的情况下较常用的是 -s &lt;serialNumber&gt; 参数，serialNumber 可以通过 adb devices 命令获取。如： 12345$ adb devicesList of devices attachedcf264b8f deviceemulator-5554 device 输出里的 cf264b8f 和 emulator-5554 即为 serialNumber。比如这时想指定 cf264b8f 这个设备来运行 adb 命令获取屏幕分辨率： 1adb -s cf264b8f shell wm size 遇到多设备/模拟器的情况均使用这几个参数为命令指定目标设备，下文中为简化描述，不再重复。 启动/停止启动 adb server 命令： 1adb start-server （一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。） 停止 adb server 命令： 1adb kill-server 查看 adb 版本命令： 1adb version 示例输出： 12Android Debug Bridge version 1.0.36Revision 8f855a3d9b35-android 以 root 权限运行 adbdadb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。 所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 adb xxx 执行。这时可以 adb shell 然后 su 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。 命令： 1adb root 正常输出： 1restarting adbd as root 现在再运行 adb shell，看看命令行提示符是不是变成 # 了？ 有些手机 root 后也无法通过 adb root 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 adbd cannot run as root in production builds，此时可以先安装 adbd Insecure，然后 adb root 试试。 相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 adb unroot 命令。 指定 adb server 的网络端口命令： 1adb -P &lt;port&gt; start-server 默认端口为 5037。 设备连接管理查询已连接设备/模拟器命令： 1adb devices 输出示例： 123List of devices attachedcf264b8f deviceemulator-5554 device 输出格式为 [serialNumber] [state]，serialNumber 即我们常说的 SN，state 有如下几种： offline —— 表示设备未连接成功或无响应。 device —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。 no device —— 没有设备/模拟器连接。 以上输出显示当前已经连接了两台设备/模拟器，cf264b8f 与 emulator-5554 分别是它们的 SN。从 emulator-5554 这个名字可以看出它是一个 Android 模拟器。 常见异常输出： 没有设备/模拟器连接成功。 1List of devices attached 设备/模拟器未连接到 adb 或无响应。 12List of devices attachedcf264b8f offline USB 连接通过 USB 连接来正常使用 adb 需要保证几点： 硬件状态正常。 包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好。 Android 设备的开发者选项和 USB 调试模式已开启。 可以到「设置」-「开发者选项」-「Android 调试」查看。 如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。 设备驱动状态正常。 这一点貌似在 Linux 和 Mac OS X 下不用操心，在 Windows 下有可能遇到需要安装驱动的情况，确认这一点可以右键「计算机」-「属性」，到「设备管理器」里查看相关设备上是否有黄色感叹号或问号，如果没有就说明驱动状态已经好了。否则可以下载一个手机助手类程序来安装驱动先。 通过 USB 线连接好电脑和设备后确认状态。 1adb devices 如果能看到 1xxxxxx device 说明连接成功。 无线连接（需要借助 USB 线）除了可以通过 USB 连接设备与电脑来使用 adb，也可以通过无线连接——虽然连接过程中也有需要使用 USB 的步骤，但是连接成功之后你的设备就可以在一定范围内摆脱 USB 连接线的限制啦！ 操作步骤： 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 将设备与电脑通过 USB 线连接。 应确保连接成功（可运行 adb devices 看是否能列出该设备）。 让设备在 5555 端口监听 TCP/IP 连接： 1adb tcpip 5555 断开 USB 连接。 找到设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到。 通过 IP 地址连接设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 确认连接状态。 1adb devices 如果能看到 1&lt;device-ip-address&gt;:5555 device 说明连接成功。 如果连接不了，请确认 Android 设备与电脑是连接到了同一个 WiFi，然后再次执行 adb connect &lt;device-ip-address&gt; 那一步； 如果还是不行的话，通过 adb kill-server 重新启动 adb 然后从头再来一次试试。 断开无线连接 命令： 1adb disconnect &lt;device-ip-address&gt; 无线连接（无需借助 USB 线）注：需要 root 权限。 上一节「无线连接（需要借助 USB 线）」是官方文档里介绍的方法，需要借助于 USB 数据线来实现无线连接。 既然我们想要实现无线连接，那能不能所有步骤下来都是无线的呢？答案是能的。 在 Android 设备上安装一个终端模拟器。 已经安装过的设备可以跳过此步。我使用的终端模拟器下载地址是：Terminal Emulator for Android Downloads 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 打开 Android 设备上的终端模拟器，在里面依次运行命令： 12susetprop service.adb.tcp.port 5555 找到 Android 设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到。 在电脑上通过 adb 和 IP 地址连接 Android 设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 如果能看到 connected to &lt;device-ip-address&gt;:5555 这样的输出则表示连接成功。 应用管理查看应用列表查看应用列表的基本命令格式是 1adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER] 即在 adb shell pm list packages 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下： 参数 显示列表 无 所有应用 -f 显示应用关联的 apk 文件 -d 只显示 disabled 的应用 -e 只显示 enabled 的应用 -s 只显示系统应用 -3 只显示第三方应用 -i 显示应用的 installer -u 包含已卸载应用 &lt;FILTER&gt; 包名包含 &lt;FILTER&gt; 字符串 所有应用命令： 1adb shell pm list packages 输出示例： 12345678910111213package:com.android.smoketestpackage:com.example.android.livecubespackage:com.android.providers.telephonypackage:com.google.android.googlequicksearchboxpackage:com.android.providers.calendarpackage:com.android.providers.mediapackage:com.android.protipspackage:com.android.documentsuipackage:com.android.gallerypackage:com.android.externalstorage...// other packages here... 系统应用命令： 1adb shell pm list packages -s 第三方应用命令： 1adb shell pm list packages -3 包名包含某字符串的应用比如要查看包名包含字符串 mazhuang 的应用列表，命令： 1adb shell pm list packages mazhuang 当然也可以使用 grep 来过滤： 1adb shell pm list packages | grep mazhuang 安装 APK命令格式： 1adb install [-lrtsdg] &lt;path_to_apk&gt; 参数： adb install 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下： 参数 含义 -l 将应用安装到保护目录 /mnt/asec -r 允许覆盖安装 -t 允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=&quot;true&quot; 的应用 -s 将应用安装到 sdcard -d 允许降级覆盖安装 -g 授予所有运行时权限 运行命令后如果见到类似如下输出（状态为 Success）代表安装成功： 123[100%] /data/local/tmp/1.apk pkg: /data/local/tmp/1.apkSuccess 上面是当前最新版 v1.0.36 的 adb 的输出，会显示 push apk 文件到手机的进度百分比。 使用旧版本 adb 的输出则是这样的： 12312040 KB/s (22205609 bytes in 1.801s) pkg: /data/local/tmp/SogouInput_android_v8.3_sweb.apkSuccess 而如果状态为 Failure 则表示安装失败，比如： 123[100%] /data/local/tmp/map-20160831.apk pkg: /data/local/tmp/map-20160831.apkFailure [INSTALL_FAILED_ALREADY_EXISTS] 常见安装失败输出代码、含义及可能的解决办法如下： 输出 含义 解决办法 INSTALL_FAILED_ALREADY_EXISTS 应用已经存在 使用 -r 参数 INSTALL_FAILED_INVALID_APK 无效的 APK 文件 INSTALL_FAILED_INVALID_URI 无效的 APK 文件名 确保 APK 文件名里无中文 INSTALL_FAILED_INSUFFICIENT_STORAGE 空间不足 清理空间 INSTALL_FAILED_DUPLICATE_PACKAGE 已经存在同名程序 INSTALL_FAILED_NO_SHARED_USER 请求的共享用户不存在 INSTALL_FAILED_UPDATE_INCOMPATIBLE 已经安装过签名不一样的同名应用，且数据没有移除 INSTALL_FAILED_SHARED_USER_INCOMPATIBLE 请求的共享用户存在但签名不一致 INSTALL_FAILED_MISSING_SHARED_LIBRARY 安装包使用了设备上不可用的共享库 INSTALL_FAILED_REPLACE_COULDNT_DELETE 替换时无法删除 INSTALL_FAILED_DEXOPT dex 优化验证失败或空间不足 INSTALL_FAILED_OLDER_SDK 设备系统版本低于应用要求 INSTALL_FAILED_CONFLICTING_PROVIDER 设备里已经存在与应用里同名的 content provider INSTALL_FAILED_NEWER_SDK 设备系统版本高于应用要求 INSTALL_FAILED_TEST_ONLY 应用是 test-only 的，但安装时没有指定 -t 参数 INSTALL_FAILED_CPU_ABI_INCOMPATIBLE 包含不兼容设备 CPU 应用程序二进制接口的 native code INSTALL_FAILED_MISSING_FEATURE 应用使用了设备不可用的功能 INSTALL_FAILED_CONTAINER_ERROR sdcard 访问失败 确认 sdcard 可用，或者安装到内置存储 INSTALL_FAILED_INVALID_INSTALL_LOCATION 不能安装到指定位置 切换安装位置，添加或删除 -s 参数 INSTALL_FAILED_MEDIA_UNAVAILABLE 安装位置不可用 一般为 sdcard，确认 sdcard 可用或安装到内置存储 INSTALL_FAILED_VERIFICATION_TIMEOUT 验证安装包超时 INSTALL_FAILED_VERIFICATION_FAILURE 验证安装包失败 INSTALL_FAILED_PACKAGE_CHANGED 应用与调用程序期望的不一致 INSTALL_FAILED_UID_CHANGED 以前安装过该应用，与本次分配的 UID 不一致 清除以前安装过的残留文件 INSTALL_FAILED_VERSION_DOWNGRADE 已经安装了该应用更高版本 使用 -d 参数 INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE 已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限 INSTALL_PARSE_FAILED_NOT_APK 指定路径不是文件，或不是以 .apk 结尾 INSTALL_PARSE_FAILED_BAD_MANIFEST 无法解析的 AndroidManifest.xml 文件 INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION 解析器遇到异常 INSTALL_PARSE_FAILED_NO_CERTIFICATES 安装包没有签名 INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES 已安装该应用，且签名与 APK 文件不一致 先卸载设备上的该应用，再安装 INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING 解析 APK 文件时遇到 CertificateEncodingException INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME manifest 文件里没有或者使用了无效的包名 INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID manifest 文件里指定了无效的共享用户 ID INSTALL_PARSE_FAILED_MANIFEST_MALFORMED 解析 manifest 文件时遇到结构性错误 INSTALL_PARSE_FAILED_MANIFEST_EMPTY 在 manifest 文件里找不到找可操作标签（instrumentation 或 application） INSTALL_FAILED_INTERNAL_ERROR 因系统问题安装失败 INSTALL_FAILED_USER_RESTRICTED 用户被限制安装应用 INSTALL_FAILED_DUPLICATE_PERMISSION 应用尝试定义一个已经存在的权限名称 INSTALL_FAILED_NO_MATCHING_ABIS 应用包含设备的应用程序二进制接口不支持的 native code INSTALL_CANCELED_BY_USER 应用安装需要在设备上确认，但未操作设备或点了取消 在设备上同意安装 INSTALL_FAILED_ACWF_INCOMPATIBLE 应用程序与设备不兼容 does not contain AndroidManifest.xml 无效的 APK 文件 is not a valid zip file 无效的 APK 文件 Offline 设备未连接成功 先将设备与 adb 连接成功 unauthorized 设备未授权允许调试 error: device not found 没有连接成功的设备 先将设备与 adb 连接成功 protocol failure 设备已断开连接 先将设备与 adb 连接成功 Unknown option: -s Android 2.2 以下不支持安装到 sdcard 不使用 -s 参数 No space left on devicerm 空间不足 清理空间 Permission denied … sdcard … sdcard 不可用 参考：PackageManager.java adb install 内部原理简介 adb install 实际是分三步完成： push apk 文件到 /data/local/tmp。 调用 pm install 安装。 删除 /data/local/tmp 下的对应 apk 文件。 所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。 卸载应用命令： 1adb uninstall [-k] &lt;packagename&gt; &lt;packagename&gt; 表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录。 命令示例： 1adb uninstall com.qihoo360.mobilesafe 表示卸载 360 手机卫士。 清除应用数据与缓存命令： 1adb shell pm clear &lt;packagename&gt; &lt;packagename&gt; 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。 命令示例： 1adb shell pm clear com.qihoo360.mobilesafe 表示清除 360 手机卫士的数据和缓存。 查看前台 Activity命令： 1adb shell dumpsys activity activities | grep mFocusedActivity 输出示例： 1mFocusedActivity: ActivityRecord&#123;8079d7e u0 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher t42&#125; 其中的 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher 就是当前处于前台的 Activity。 与应用交互主要是使用 am &lt;command&gt; 命令，常用的 &lt;command&gt; 如下： command 用途 start [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Activity startservice [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Service broadcast [options] &lt;INTENT&gt; 发送 &lt;INTENT&gt; 指定的广播 force-stop &lt;packagename&gt; 停止 &lt;packagename&gt; 相关的进程 &lt;INTENT&gt; 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。 用于决定 intent 对象的选项如下： 参数 含义 -a &lt;ACTION&gt; 指定 action，比如 android.intent.action.VIEW -c &lt;CATEGORY&gt; 指定 category，比如 android.intent.category.APP_CONTACTS -n &lt;COMPONENT&gt; 指定完整 component 名，用于明确指定启动哪个 Activity，如 com.example.app/.ExampleActivity &lt;INTENT&gt; 里还能带数据，就像写代码时的 Bundle 一样： 参数 含义 --esn &lt;EXTRA_KEY&gt; null 值（只有 key 名） `-e –es ` string 值 --ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt; boolean 值 --ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt; integer 值 --el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt; long 值 --ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt; float 值 --eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt; URI --ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt; component name --eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...] integer 数组 --ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...] long 数组 调起 Activity命令格式： 1adb shell am start [options] &lt;INTENT&gt; 例如： 1adb shell am start -n com.tencent.mm/.ui.LauncherUI 表示调起微信主界面。 1adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity --es "toast" "hello, world" 表示调起 org.mazhuang.boottimemeasure/.MainActivity 并传给它 string 数据键值对 toast - hello, world。 调起 Service命令格式： 1adb shell am startservice [options] &lt;INTENT&gt; 例如： 1adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService 表示调起微信的某 Service。 发送广播命令格式： 1adb shell am broadcast [options] &lt;INTENT&gt; 例如： 1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n org.mazhuang.boottimemeasure/.BootCompletedReceiver 表示向 org.mazhuang.boottimemeasure/.BootCompletedReceiver 发送一个 BOOT_COMPLETED 广播，这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。 强制停止应用命令： 1adb shell am force-stop &lt;packagename&gt; 命令示例： 1adb shell am force-stop com.qihoo360.mobilesafe 表示停止 360 安全卫士的一切进程与服务。 文件管理复制设备里的文件到电脑命令： 1adb pull &lt;设备里的文件路径&gt; [电脑上的目录] 其中 电脑上的目录 参数可以省略，默认复制到当前目录。 例： 1adb pull /sdcard/sr.mp4 ~/tmp/ 小技巧：设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 adb shell 和 su 命令在 adb shell 里获取 root 权限后，先 cp /path/on/device /sdcard/filename 将文件复制到 sdcard，然后 adb pull /sdcard/filename /path/on/pc。 复制电脑里的文件到设备命令： 1adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt; 例： 1adb push ~/sr.mp4 /sdcard/ 小技巧：设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 adb push /path/on/pc /sdcard/filename，然后 adb shell 和 su 在 adb shell 里获取 root 权限后，cp /sdcard/filename /path/on/device。 模拟按键/输入在 adb shell 里有个很实用的命令叫 input，通过它可以做一些有趣的事情。 input 命令的完整 help 信息如下： 12345678910111213141516171819202122Usage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]The sources are: mouse keyboard joystick touchnavigation touchpad trackball stylus dpad gesture touchscreen gamepadThe commands and default sources are: text &lt;string&gt; (Default: touchscreen) keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard) tap &lt;x&gt; &lt;y&gt; (Default: touchscreen) swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen) press (Default: trackball) roll &lt;dx&gt; &lt;dy&gt; (Default: trackball) 比如使用 adb shell input keyevent &lt;keycode&gt; 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 KeyEvent，摘引部分我觉得有意思的如下： keycode 含义 3 HOME 键 4 返回键 5 打开拨号应用 6 挂断电话 24 增加音量 25 降低音量 26 电源键 27 拍照（需要在相机应用里） 64 打开浏览器 82 菜单键 85 播放/暂停 86 停止播放 87 播放下一首 88 播放上一首 122 移动光标到行首或列表顶部 123 移动光标到行末或列表底部 126 恢复播放 127 暂停播放 164 静音 176 打开系统设置 187 切换应用 207 打开联系人 208 打开日历 209 打开音乐 210 打开计算器 220 降低屏幕亮度 221 提高屏幕亮度 223 系统休眠 224 点亮屏幕 231 打开语音助手 276 如果没有 wakelock 则让系统休眠 下面是 input 命令的一些用法举例。 电源键命令： 1adb shell input keyevent 26 执行效果相当于按电源键。 菜单键命令： 1adb shell input keyevent 82 HOME 键命令： 1adb shell input keyevent 3 返回键命令： 1adb shell input keyevent 4 音量控制增加音量： 1adb shell input keyevent 24 降低音量： 1adb shell input keyevent 25 静音： 1adb shell input keyevent 164 媒体控制播放/暂停： 1adb shell input keyevent 85 停止播放： 1adb shell input keyevent 86 播放下一首： 1adb shell input keyevent 87 播放上一首： 1adb shell input keyevent 88 恢复播放： 1adb shell input keyevent 126 暂停播放： 1adb shell input keyevent 127 点亮/熄灭屏幕可以通过上文讲述过的模拟电源键来切换点亮和熄灭屏幕，但如果明确地想要点亮或者熄灭屏幕，那可以使用如下方法。 点亮屏幕： 1adb shell input keyevent 224 熄灭屏幕： 1adb shell input keyevent 223 滑动解锁如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 input swipe 来解锁。 命令（参数以机型 Nexus 5，向上滑动手势解锁举例）： 1adb shell input swipe 300 1000 300 500 参数 300 1000 300 500 分别表示起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标。 输入文本在焦点处于某文本框时，可以通过 input 命令来输入文本。 命令： 1adb shell input text hello 现在 hello 出现在文本框了。 查看日志Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。 Android 日志命令格式： 1[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ... 常用用法列举如下： 按级别过滤日志Android 的日志分为如下几个级别： V —— Verbose（最低，输出得最多） D —— Debug I —— Info W —— Warning E —— Error F —— Fatal S —— Silent（最高，啥也不输出） 按某级别过滤日志则会将该级别及以上的日志输出。 比如，命令： 1adb logcat *:W 会将 Warning、Error、Fatal 和 Silent 日志输出。 按 tag 和级别过滤日志比如，命令： 1adb logcat ActivityManager:I MyApp:D *:S 表示输出 tag ActivityManager 的 Info 以上级别日志，输出 tag MyApp 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。 日志格式可以用 adb logcat -v &lt;format&gt; 选项指定日志输出格式。 日志支持按以下几种 &lt;format&gt;： brief 默认格式。格式为： 1&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 1D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 process 格式为： 1&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt; 示例： 1D( 1785) Disconnected process message: 10, size: 0 (HeadsetStateMachine) tag 格式为： 1&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt; 示例： 1D/HeadsetStateMachine: Disconnected process message: 10, size: 0 raw 格式为： 1&lt;message&gt; 示例： 1Disconnected process message: 10, size: 0 time 格式为： 1&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 108-28 22:39:39.974 D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 threadtime 格式为： 1&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt; 示例： 108-28 22:39:39.974 1785 1832 D HeadsetStateMachine: Disconnected process message: 10, size: 0 long 格式为： 12[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ]&lt;message&gt; 示例： 12[ 08-28 22:39:39.974 1785: 1832 D/HeadsetStateMachine ]Disconnected process message: 10, size: 0 指定格式可与上面的过滤同时使用。比如： 1adb logcat -v long ActivityManager:I *:S 清空日志1adb logcat -c 内核日志命令： 1adb shell dmesg 输出示例： 1234567&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs&lt;4&gt;[14201.755954] Restarting tasks ... done.&lt;6&gt;[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC&lt;6&gt;[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC&lt;6&gt;[14201.872498] PM: Syncing filesystems ... done. 中括号里的 [14201.684016] 代表内核开始启动后的时间，单位为秒。 通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 Freeing init memory 那一行前面的时间就是。 查看设备信息型号命令： 1adb shell getprop ro.product.model 输出示例： 1Nexus 5 电池状况命令： 1adb shell dumpsys battery 输入示例： 123456789101112Current Battery Service state: AC powered: false USB powered: true Wireless powered: false status: 2 health: 2 present: true level: 44 scale: 100 voltage: 3872 temperature: 280 technology: Li-poly 其中 scale 代表最大电量，level 代表当前电量。上面的输出表示还剩下 44% 的电量。 屏幕分辨率命令： 1adb shell wm size 输出示例： 1Physical size: 1080x1920 该设备屏幕分辨率为 1080px * 1920px。 屏幕密度命令： 1adb shell wm density 输出示例： 1Physical density: 420 该设备屏幕密度为 420dpi。 显示屏参数命令： 1adb shell dumpsys window displays 输出示例： 1234WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays) Display: mDisplayId=0 init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731 deferred=false layoutNeeded=false 其中 mDisplayId 为 显示屏编号，init 是初始分辨率和屏幕密度，app 的高度比 init 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。 android_id命令： 1adb shell settings get secure android_id 输出示例： 151b6be48bac8c569 IMEI在 Android 4.4 及以下版本可通过如下命令获取 IMEI： 1adb shell dumpsys iphonesubinfo 输出示例： 123Phone Subscriber Info: Phone Type = GSM Device ID = 860955027785041 其中的 Device ID 就是 IMEI。 而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）： 123adb shellsuservice call iphonesubinfo 1 输出示例： 1234Result: Parcel( 0x00000000: 00000000 0000000f 00360038 00390030 '........8.6.0.9.' 0x00000010: 00350035 00320030 00370037 00350038 '5.5.0.2.7.7.8.5.' 0x00000020: 00340030 00000031 '0.4.1... ') 把里面的有效内容提取出来就是 IMEI 了，比如这里的是 860955027785041。 参考：adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop Android 系统版本命令： 1adb shell getprop ro.build.version.release 输出示例： 15.0.2 Mac 地址命令： 1adb shell cat /sys/class/net/wlan0/address 输出示例： 1f8:a9:d0:17:42:4d CPU 信息命令： 1adb shell cat /proc/cpuinfo 输出示例： 1234567891011121314151617181920212223Processor : ARMv7 Processor rev 0 (v7l)processor : 0BogoMIPS : 38.40processor : 1BogoMIPS : 38.40processor : 2BogoMIPS : 38.40processor : 3BogoMIPS : 38.40Features : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivtCPU implementer : 0x51CPU architecture: 7CPU variant : 0x2CPU part : 0x06fCPU revision : 0Hardware : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree)Revision : 000bSerial : 0000000000000000 这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是 Qualcomm MSM 8974，processor 的编号是 0 到 3，所以它是四核的，采用的架构是 ARMv7 Processor rev 0 (v71)。 内存信息命令： 1adb shell cat /proc/meminfo 输出示例： 12345678910111213141516171819202122232425262728293031323334353637MemTotal: 1027424 kBMemFree: 486564 kBBuffers: 15224 kBCached: 72464 kBSwapCached: 24152 kBActive: 110572 kBInactive: 259060 kBActive(anon): 79176 kBInactive(anon): 207736 kBActive(file): 31396 kBInactive(file): 51324 kBUnevictable: 3948 kBMlocked: 0 kBHighTotal: 409600 kBHighFree: 132612 kBLowTotal: 617824 kBLowFree: 353952 kBSwapTotal: 262140 kBSwapFree: 207572 kBDirty: 0 kBWriteback: 0 kBAnonPages: 265324 kBMapped: 47072 kBShmem: 1020 kBSlab: 57372 kBSReclaimable: 7692 kBSUnreclaim: 49680 kBKernelStack: 4512 kBPageTables: 5912 kBNFS_Unstable: 0 kBBounce: 0 kBWritebackTmp: 0 kBCommitLimit: 775852 kBCommitted_AS: 13520632 kBVmallocTotal: 385024 kBVmallocUsed: 61004 kBVmallocChunk: 209668 kB 其中，MemTotal 就是设备的总内存，MemFree 是当前空闲内存。 更多硬件与系统属性设备的更多硬件与系统属性可以通过如下命令查看： 1adb shell cat /system/build.prop 这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。 输出里还包括一些其它有用的信息，它们也可通过 adb shell getprop &lt;属性名&gt; 命令单独查看，列举一部分属性如下： 属性名 含义 ro.build.version.sdk SDK 版本 ro.build.version.release Android 系统版本 ro.build.version.security_patch Android 安全补丁程序级别 ro.product.model 型号 ro.product.brand 品牌 ro.product.name 设备名 ro.product.board 处理器型号 ro.product.cpu.abilist CPU 支持的 abi 列表 persist.sys.isUsbOtgEnabled 是否支持 OTG dalvik.vm.heapsize 每个应用程序的内存上限 ro.sf.lcd_density 屏幕密度 实用功能屏幕截图命令： 1adb shell screencap -p /sdcard/sc.png 然后将 png 文件导出到电脑： 1adb pull /sdcard/sc.png 可以使用 adb shell screencap -h 查看 screencap 命令的帮助信息，下面是两个有意义的参数及含义： 参数 含义 -p 指定保存文件为 png 格式 -d display-id 指定截图的显示屏编号（有多显示屏的情况下） 实测如果指定文件名以 .png 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。 录制屏幕录制屏幕以 mp4 格式保存到 /sdcard： 1adb shell screenrecord /sdcard/filename.mp4 需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。 如果需要导出到电脑： 1adb pull /sdcard/filename.mp4 可以使用 adb shell screenrecord --help 查看 screenrecord 命令的帮助信息，下面是常见参数及含义： 参数 含义 –size WIDTHxHEIGHT 视频的尺寸，比如 1280x720，默认是屏幕分辨率。 –bit-rate RATE 视频的比特率，默认是 4Mbps。 –time-limit TIME 录制时长，单位秒。 –verbose 输出更多信息。 重新挂载 system 分区为可写注：需要 root 权限。 /system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 /system 进行写操作，所以需要重新挂载它为可读写。 步骤： 进入 shell 并切换到 root 用户权限。 命令： 12adb shellsu 查看当前分区挂载情况。 命令： 1mount 输出示例： 12345678910111213141516171819202122232425rootfs / rootfs ro,relatime 0 0tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0proc /proc proc rw,relatime 0 0sysfs /sys sysfs rw,seclabel,relatime 0 0selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0debugfs /sys/kernel/debug debugfs rw,relatime 0 0none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0none /acct cgroup rw,relatime,cpuacct 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0none /dev/memcg cgroup rw,relatime,memory 0 0none /dev/cpuctl cgroup rw,relatime,cpu 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0/dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0 找到其中我们关注的带 /system 的那一行： 1/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0 重新挂载。 命令： 1mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system 这里的 /dev/block/platform/msm_sdcc.1/by-name/system 就是我们从上一步的输出里得到的文件路径。 如果输出没有提示错误的话，操作就成功了，可以对 /system 下的文件为所欲为了。 查看连接过的 WiFi 密码注：需要 root 权限。 命令： 123adb shellsucat /data/misc/wifi/*.conf 输出示例： 123456789101112131415161718network=&#123; ssid="TP-LINK_9DFC" scan_ssid=1 psk="123456789" key_mgmt=WPA-PSK group=CCMP TKIP auth_alg=OPEN sim_num=1 priority=13893&#125;network=&#123; ssid="TP-LINK_F11E" psk="987654321" key_mgmt=WPA-PSK sim_num=1 priority=17293&#125; ssid 即为我们在 WLAN 设置里看到的名称，psk 为密码，key_mgmt 为安全加密方式。 设置系统日期和时间注：需要 root 权限。 命令： 123adb shellsudate -s 20160823.131500 表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。 重启手机命令： 1adb reboot 检测设备是否已 root命令： 12adb shellsu 此时命令行提示符是 $ 则表示没有 root 权限，是 # 则表示已 root。 使用 Monkey 进行压力测试Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。 简单用法： 1adb shell monkey -p &lt;packagename&gt; -v 500 表示向 &lt;packagename&gt; 指定的应用程序发送 500 个伪随机事件。 Monkey 的详细用法参考 官方文档。 开启/关闭 WiFi注：需要 root 权限。 有时需要控制设备的 WiFi 状态，可以用以下指令完成。 开启 WiFi： 12adb rootadb shell svc wifi enable 关闭 WiFi： 12adb rootadb shell svc wifi disable 若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 Killed。 刷机相关命令重启到 Recovery 模式命令： 1adb reboot recovery 从 Recovery 重启到 Android命令： 1adb reboot 重启到 Fastboot 模式命令： 1adb reboot bootloader 通过 sideload 更新系统如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。 以 Recovery 模式下更新为例： 重启到 Recovery 模式。 命令： 1adb reboot recovery 在设备的 Recovery 界面上操作进入 Apply update-Apply from ADB。 注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 Apply update from ADB。 通过 adb 上传和更新系统。 命令： 1adb sideload &lt;path-to-update.zip&gt; 更多 adb shell 命令Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 adb shell 里可以调用。本文档前面的部分内容已经用到了 adb shell 命令。 查看进程命令： 1adb shell ps 输出示例： 12345678USER PID PPID VSIZE RSS WCHAN PC NAMEroot 1 0 8904 788 ffffffff 00000000 S /initroot 2 0 0 0 ffffffff 00000000 S kthreadd...u0_a71 7779 5926 1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classicu0_a58 7963 5926 1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure...shell 8750 217 10640 740 00000000 b6f28340 R ps 各列含义： 列名 含义 USER 所属用户 PID 进程 ID PPID 父进程 ID NAME 进程名 查看实时资源占用情况命令： 1adb shell top 输出示例： 1234567891011121314User 0%, System 6%, IOW 0%, IRQ 0%User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307 PID PR CPU% S #THR VSS RSS PCY UID Name 8763 0 3% R 1 10640K 1064K fg shell top 131 0 3% S 1 0K 0K fg root dhd_dpc 6144 0 0% S 115 1682004K 115916K fg system system_server 132 0 0% S 1 0K 0K fg root dhd_rxf 1731 0 0% S 6 20288K 788K fg root /system/bin/mpdecision 217 0 0% S 6 18008K 356K fg shell /sbin/adbd ... 7779 2 0% S 19 1538748K 48896K bg u0_a71 com.sohu.inputmethod.sogou:classic 7963 0 0% S 18 1561916K 59568K fg u0_a58 org.mazhuang.boottimemeasure ... 各列含义： 列名 含义 PID 进程 ID PR 优先级 CPU% 当前瞬间占用 CPU 百分比 S 进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程） #THR 线程数 VSS Virtual Set Size 虚拟耗用内存（包含共享库占用的内存） RSS Resident Set Size 实际使用物理内存（包含共享库占用的内存） PCY 调度策略优先级，SP_BACKGROUND/SPFOREGROUND UID 进程所有者的用户 ID NAME 进程名 top 命令还支持一些命令行参数，详细用法如下： 1234567Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ] -m num 最多显示多少个进程 -n num 刷新多少次后退出 -d num 刷新时间间隔（单位秒，默认值 5） -s col 按某列排序（可用 col 值：cpu, vss, rss, thr） -t 显示线程信息 -h 显示帮助文档 其它如下是其它常用命令的简单描述，前文已经专门讲过的命令不再额外说明： 命令 功能 cat 显示文件内容 cd 切换目录 chmod 改变文件的存取模式/访问权限 df 查看磁盘空间使用情况 grep 过滤输出 kill 杀死指定 PID 的进程 ls 列举目录内容 mount 挂载目录的查看和管理 mv 移动或重命名文件 ps 查看正在运行的进程 rm 删除文件 top 查看进程的资源占用情况 adb 的非官方实现 fb-adb - A better shell for Android devices (for Mac). 致谢感谢朋友们无私的分享与补充。 zxning linhua55 codeskyblue seasonyuu fan123199 参考链接 Android Debug Bridge ADB Shell Commands logcat Command-line Tool Android ADB命令大全 adb 命令行的使用记录 Android ADB命令大全(通过ADB命令查看wifi密码、MAC地址、设备信息、操作文件、查看文件、日志信息、卸载、启动和安装APK等) 那些做Android开发必须知道的ADB命令 adb shell top 像高手一样使用ADB命令行（2）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JAVAIO之压缩流（zip,Gzip）]]></title>
      <url>%2F2015%2F09%2F01%2F%E5%AD%A6%E4%B9%A0%2FJava%E5%8E%8B%E7%BC%A9%E6%B5%81Zip%E5%92%8CGZip%2F</url>
      <content type="text"><![CDATA[介绍 JAVAIO流是java的一个很重要的部分，清晰有很复杂，各种各样的流分管不同的功能。正确使用IO流可以让你的输入输出效率增加，这篇博客主要说一下压缩流的使用，使用JAVA内置API压缩解压缩文件。 ZIP压缩主要的用到的API是123ZipFileZipInputStreamZipOutputStream 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.Closeable;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.util.Enumeration;import java.util.zip.ZipEntry;import java.util.zip.ZipException;import java.util.zip.ZipFile;import java.util.zip.ZipInputStream;import java.util.zip.ZipOutputStream;/** * * @author chendong * * &lt;/br&gt;使用java内置APIZipFile完成对文件的压缩解压缩操作 * * &lt;/br&gt;文件中如果有中文名称加压后的文件会出现乱码，但是解压之后又ok了，可以使用中文 * * &lt;/br&gt;提供了大文件异步加压解压的方法，使用回调检测是否完成 * * &lt;/br&gt;提供小文件同步加压解压更加方便 * */public class ZipUtils &#123; /** * 用于大文件加压解压的回调监听 * * @author chendong * */ public interface OnZipOverListener &#123; void onZipOver(); &#125; public interface OnUnZipOverListener &#123; void onUnZipOver(); &#125; /** * 压缩 &lt;/br&gt;构造源文件 * * @param src * 源文件路径 * @param dest * 目标文件路径 * @throws FileNotFoundException */ public static void zip(String src, String dest, OnZipOverListener listener) &#123; File srcFile = new File(src); zip(srcFile, dest, listener); &#125; /** * 压缩 &lt;/br&gt;生成压缩输出文件流 * * @param srcFile * @param dest * @throws FileNotFoundException */ public static void zip(File srcFile, String dest, OnZipOverListener listener) &#123; ZipOutputStream destOs = null; try &#123; destOs = new ZipOutputStream(new FileOutputStream(dest)); zip(srcFile, destOs, ""); close(destOs); if (listener != null) listener.onZipOver(); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; close(destOs); &#125; &#125; /** * 压缩,使用递归 &lt;/br&gt;写文件 &lt;/br&gt;主要操作在这个函数中，使用递归如果是一个文件，将其写入流中否则进行递归 &lt;/br&gt;ZipEntry * 类是java.util.zip包下的一个类， ZipEntry 类用于表示 ZIP 文件条目。 利用这个类压缩和解压zip文件 * * @param srcFile * @param destOs * @param string * @throws IOException */ private static void zip(File srcFile, ZipOutputStream destOs, String base) &#123; BufferedInputStream bis = null; try &#123; if (srcFile.isDirectory()) &#123; /* 如果源文件是目录 */ File[] files = srcFile.listFiles(); destOs.putNextEntry(new ZipEntry(base + "/")); base = base.length() == 0 ? "" : base + "/"; for (int i = 0; i &lt; files.length; i++) &#123; zip(files[i], destOs, base + files[i].getName()); &#125; &#125; else &#123; /* 如果是文件 */ destOs.putNextEntry(new ZipEntry(base)); bis = new BufferedInputStream(new FileInputStream(srcFile)); byte[] buffer = new byte[1024]; int len = 0; while ((len = bis.read(buffer)) != -1) &#123; destOs.write(buffer, 0, len); &#125; close(bis); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; close(bis); &#125; &#125; /** * 解压 * * @param src * 源文件，需要是zip文件 * @param dest * 目标文件， */ public static void unzip(String src, String dest, OnUnZipOverListener listener) &#123; File destFile = new File(dest); /* 目标文件不存在，创建之 */ if (!destFile.exists()) &#123; destFile.mkdirs(); &#125; /* 构造源文件 */ File srcFile = new File(src); if (!srcFile.exists()) &#123; return; &#125; unzip(srcFile, dest, listener); &#125; /** * 解压 * * @param srcFile * @param destFile */ public static void unzip(File srcFile, String dest, OnUnZipOverListener listener) &#123; BufferedInputStream bis = null; BufferedOutputStream bos = null; try &#123; ZipFile srcZipFile = new ZipFile(srcFile); /* 获得zipentry的枚举 */ Enumeration e = srcZipFile.entries(); ZipEntry entry = null;// ZipInputStream zis = new ZipInputStream(// new FileInputStream(srcFile)); // while((entry=zis.getNextEntry())!=null)&#123; while (e.hasMoreElements()) &#123; entry = (ZipEntry) e.nextElement(); if (entry.toString().equals("/")) &#123; continue; &#125; bis = new BufferedInputStream(srcZipFile.getInputStream(entry)); /* 构建对应输出流 */ bos = new BufferedOutputStream(new FileOutputStream(dest + "/" + entry.getName())); int len = 0; byte[] buffer = new byte[1024]; while ((len = bis.read(buffer)) != -1) &#123; bos.write(buffer, 0, len); &#125; bos.flush(); close(bis); close(bos); &#125; if (listener != null) listener.onUnZipOver(); &#125; catch (ZipException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; close(bis); close(bos); &#125; &#125; /** * 压缩单个或者多个文件,但是不可以同时压缩文件和文件夹 * * @param src * 想要压缩的文件路径，不可以是文件夹 * @param dest * 目标路径，xx.zip */ public static void zipFile(String[] src, String dest, OnZipOverListener listener) &#123; File parent = new File(new File(dest).getParent() + "/temp"); if (!parent.exists()) &#123; parent.mkdirs(); &#125; BufferedInputStream bis = null; BufferedOutputStream bos = null; File file = null; try &#123; int len = 0; byte[] buffer = new byte[1024]; for (String path : src) &#123; file = new File(path); bis = new BufferedInputStream(new FileInputStream(file)); bos = new BufferedOutputStream(new FileOutputStream( parent.getAbsolutePath() + "/" + file.getName())); while ((len = bis.read(buffer)) != -1) &#123; bos.write(buffer, 0, len); &#125; bos.flush(); close(bos); close(bis); &#125; zip(parent, dest, listener); for (File ff : parent.listFiles()) &#123; ff.delete(); &#125; parent.delete(); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; close(bos); close(bis); &#125; &#125; private static void close(Closeable close) &#123; if (close != null) &#123; try &#123; close.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; GZIP压缩 这个没太搞懂，一直在弄加压解压有点烦了，改天再说吧，贴一下已经实现的简单功能。就是加压一个文件，本身GZIP就是一对一的，也就是说每次只能压缩一个文件，我们需要压缩多个问价的时候要使用tar先打包，看到网上有实现这个功能的，但是使用的阿帕奇的第三方库，就没去试,这部分的有点仓促，主要是烦了，写完这个我就去看点别的了，老看一个东西烦得慌，改天会在完善吧。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.Closeable;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.util.zip.GZIPInputStream;import java.util.zip.GZIPOutputStream;/** * * 使用java内置API完成文件的加压解压&lt;/br&gt; * 使用gzip压缩压缩效果更好，但是gzip压缩只能是一对一的，也就是说一个压缩包只能解压出一个文件，所以想压缩多个文件时就需要先使用tar压成一个包 * ，再用gzip压缩 * * @author chendong * */public class GZipUtils &#123; /** * gzip压缩，将一个文件压缩到制定包 * * @param src * @param dest */ public static void gzip(String src) &#123; File srcFile = new File(src); if (!srcFile.exists()) &#123; return; &#125; BufferedInputStream bis = null; GZIPOutputStream gos = null; File destFile = new File(src + ".gz"); try &#123; /* 获得输入流 */ bis = new BufferedInputStream(new FileInputStream(src)); /* 获得压缩输出流 */ gos = new GZIPOutputStream(new BufferedOutputStream( new FileOutputStream(destFile))); int len = 0; byte[] buffer = new byte[1024]; while ((len = bis.read(buffer)) != -1) &#123; gos.write(buffer, 0, len); &#125; gos.flush(); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; close(gos); close(bis); &#125; &#125; /** * 解压 * @param src * @param dest */ public static void ungzip(String src, String dest) &#123; File destFile = new File(dest); File srcFile = new File(src); GZIPInputStream gis = null; BufferedOutputStream bos = null; try &#123; if (!destFile.exists()) &#123; destFile.createNewFile(); &#125; if (!srcFile.exists()) &#123; return; &#125; bos = new BufferedOutputStream(new FileOutputStream(destFile)); gis = new GZIPInputStream(new FileInputStream(srcFile)); int len = 0; byte[] buffer = new byte[1024]; while ((len = gis.read(buffer)) != -1) &#123; bos.write(buffer, 0, len); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; close(bos); close(gis); &#125; &#125; public static void pack(File files[]) &#123; &#125; private static void close(Closeable close) &#123; if (close != null) &#123; try &#123; close.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[保存照片和视频到相册显示]]></title>
      <url>%2F2015%2F08%2F23%2FAndroid%E5%BC%80%E5%8F%91%2F%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%92%8C%E8%A7%86%E9%A2%91%E5%88%B0%E7%9B%B8%E5%86%8C%E6%98%BE%E7%A4%BA%2F</url>
      <content type="text"><![CDATA[照片和视频保存到本地的方法大致都是通过流的方式写入文件里面就可以达到保存到文件夹的目的，但是你保存到文件夹的资源却不一定能够在相册显示出来，只能翻看文件管理。怎么能够将保存到本地的照片视频显示在系统相册中，最常用的方式是发送广播扫描的方式来通知系统扫描文件夹，但是这种方式经常不起作用，根本原因在于，向系统发送广播时系统只会去扫描系统资源的相册，如果你保存的文件夹是自己建立的，那么你发广播时系统是不会扫描到的。解决这个问题，想要显示在相册需要将数据插入到ContentProvider中，因此对于非系统能够扫描到的相册我们使用手动插入的方式。 2. 保存到系统资源相册系统相册指的的是Camera、DCIM等等这些目录对应的相册，可能还有其他系统会自动扫描的相册，但是暂时没有去整理这些。对于系统相册来说，只需要发送广播进行扫描即可，数据会自动添加到ContentProvider中，当然如果不发送广播，在手机重启或者过一段时间之后，扫描操作仍会开启，因此绝对绝对不可以自己去进行插入操作，否则相册中会出现两张相同的照片。 12345678910111213/** * 针对系统文夹只需要扫描,不用插入内容提供者,不然会重复 * * @param context 上下文 * @param filePath 文件路径 */private static void scanFile(Context context, String filePath) &#123; if (!checkFile(filePath)) return; Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE); intent.setData(Uri.fromFile(new File(filePath))); context.sendBroadcast(intent);&#125; 3. 保存到非系统资源相册保存到非系统资源相册中时，我们就需要进行ContentProvider的插入更新，来达到可以在相册显示的目的。 3.1 初始化ContentValues公共字段照片和视频是有一些公共字段，写一个初始化公共字段的方法，简化MediaStore字段的写入操作。 12345678910111213141516171819/** * 插入时初始化公共字段 * * @param filePath 文件 * @param time ms * @return ContentValues */private static ContentValues initCommonContentValues(String filePath, long time) &#123; ContentValues values = new ContentValues(); File saveFile = new File(filePath); long timeMillis = getTimeWrap(time); values.put(MediaStore.MediaColumns.TITLE, saveFile.getName()); values.put(MediaStore.MediaColumns.DISPLAY_NAME, saveFile.getName()); values.put(MediaStore.MediaColumns.DATE_MODIFIED, timeMillis); values.put(MediaStore.MediaColumns.DATE_ADDED, timeMillis); values.put(MediaStore.MediaColumns.DATA, saveFile.getAbsolutePath()); values.put(MediaStore.MediaColumns.SIZE, saveFile.length()); return values;&#125; 3.2 插入照片资源保存照片到本地，并通知相册显示，需要注意的时间的单位必须是ms 123456789101112131415161718192021222324252627/** * 保存到照片到本地，并插入MediaStore以保证相册可以查看到 * 这是更优化的方法，防止读取的照片获取不到宽高 * * @param context 上下文 * @param filePath 文件路径 * @param createTime 创建时间 &lt;=0时为当前时间 ms * @param width 宽度 * @param height 高度 */public static void insertImageToMediaStore(Context context, String filePath, long createTime, int width, int height) &#123; if (!checkFile(filePath)) return; createTime = getTimeWrap(createTime); ContentValues values = initCommonContentValues(filePath, createTime); values.put(MediaStore.Images.ImageColumns.DATE_TAKEN, createTime); values.put(MediaStore.Images.ImageColumns.ORIENTATION, 0); values.put(MediaStore.Images.ImageColumns.ORIENTATION, 0); if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.JELLY_BEAN) &#123; if (width &gt; 0) values.put(MediaStore.Images.ImageColumns.WIDTH, 0); if (height &gt; 0) values.put(MediaStore.Images.ImageColumns.HEIGHT, 0); &#125; values.put(MediaStore.MediaColumns.MIME_TYPE, getPhotoMimeType(filePath)); context.getApplicationContext().getContentResolver() .insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);&#125; 3.3 插入视频资源保存视频到本地，并通知相册显示，需要注意的时间的单位必须是ms 123456789101112131415161718192021222324252627/** * 保存到视频到本地，并插入MediaStore以保证相册可以查看到 * 这是更优化的方法，防止读取的视频获取不到宽高 * * @param context 上下文 * @param filePath 文件路径 * @param createTime 创建时间 &lt;=0时为当前时间 ms * @param duration 视频长度 ms * @param width 宽度 * @param height 高度 */public static void insertVideoToMediaStore(Context context, String filePath, long createTime, int width, int height, long duration) &#123; if (!checkFile(filePath)) return; createTime = getTimeWrap(createTime); ContentValues values = initCommonContentValues(filePath, createTime); values.put(MediaStore.Video.VideoColumns.DATE_TAKEN, createTime); if (duration &gt; 0) values.put(MediaStore.Video.VideoColumns.DURATION, duration); if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.JELLY_BEAN) &#123; if (width &gt; 0) values.put(MediaStore.Video.VideoColumns.WIDTH, width); if (height &gt; 0) values.put(MediaStore.Video.VideoColumns.HEIGHT, height); &#125; values.put(MediaStore.MediaColumns.MIME_TYPE, getVideoMimeType(filePath)); context.getContentResolver().insert(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, values);&#125; 4. 注意在应用过程中发现，vivo手机和魅族手机部分机型只支持在文件管理中查看视频，使用本文描述的方法添加后没有效果，用微信保存视频试了一下同样不能在相册中将视频显示出来，应该是手机的原因，特此声明。 5.源码贴一下工具类源代码，多了一些辅助方法，比如获取mime_type的参数等方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174/** * CreateAt : 2017/5/24 * Describe : 相册更新通知帮助类 * 创建时间单位ms * 视频时长单位ms * * @author chendong */public class AlbumNotifyHelper &#123; public static final String TAG = AlbumNotifyHelper.class.getSimpleName(); /////////////////////////////////////////////////////////////////////////// // 下面是对外公开的重载的方法 /////////////////////////////////////////////////////////////////////////// public static void notifyScanDcim(Context context, String filePath) &#123; scanFile(context, filePath); &#125; public static void insertVideoToMediaStore(Context context, String filePath, long dateTaken, long duration) &#123; insertVideoToMediaStore(context, filePath, dateTaken, 0, 0, duration); &#125; public static void insertVideoToMediaStore(Context context, VideoUtil.VideoInfo videoInfo) &#123; insertVideoToMediaStore(context, videoInfo.originalVideoFilePath, videoInfo.dateTaken, videoInfo.width, videoInfo.height, videoInfo.duringTime); &#125; public static void insertImageToMediaStore(Context context, String filePath, long createTime) &#123; insertImageToMediaStore(context, filePath, createTime, 0, 0); &#125; /////////////////////////////////////////////////////////////////////////// // 扫描系统相册核心方法 /////////////////////////////////////////////////////////////////////////// /** * 针对系统文夹只需要扫描,不用插入内容提供者,不然会重复 * * @param context 上下文 * @param filePath 文件路径 */ public static void scanFile(Context context, String filePath) &#123; if (!checkFile(filePath)) return; Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE); intent.setData(Uri.fromFile(new File(filePath))); context.sendBroadcast(intent); &#125; /////////////////////////////////////////////////////////////////////////// // 非系统相册像MediaContent中插入数据，核心方法 /////////////////////////////////////////////////////////////////////////// /** * 针对非系统文件夹下的文件,使用该方法 * 插入时初始化公共字段 * * @param filePath 文件 * @param time ms * @return ContentValues */ private static ContentValues initCommonContentValues(String filePath, long time) &#123; ContentValues values = new ContentValues(); File saveFile = new File(filePath); long timeMillis = getTimeWrap(time); values.put(MediaStore.MediaColumns.TITLE, saveFile.getName()); values.put(MediaStore.MediaColumns.DISPLAY_NAME, saveFile.getName()); values.put(MediaStore.MediaColumns.DATE_MODIFIED, timeMillis); values.put(MediaStore.MediaColumns.DATE_ADDED, timeMillis); values.put(MediaStore.MediaColumns.DATA, saveFile.getAbsolutePath()); values.put(MediaStore.MediaColumns.SIZE, saveFile.length()); return values; &#125; /** * 保存到照片到本地，并插入MediaStore以保证相册可以查看到,这是更优化的方法，防止读取的照片获取不到宽高 * * @param context 上下文 * @param filePath 文件路径 * @param createTime 创建时间 &lt;=0时为当前时间 ms * @param width 宽度 * @param height 高度 */ public static void insertImageToMediaStore(Context context, String filePath, long createTime, int width, int height) &#123; if (!checkFile(filePath)) return; createTime = getTimeWrap(createTime); ContentValues values = initCommonContentValues(filePath, createTime); values.put(MediaStore.Images.ImageColumns.DATE_TAKEN, createTime); values.put(MediaStore.Images.ImageColumns.ORIENTATION, 0); values.put(MediaStore.Images.ImageColumns.ORIENTATION, 0); if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.JELLY_BEAN) &#123; if (width &gt; 0) values.put(MediaStore.Images.ImageColumns.WIDTH, 0); if (height &gt; 0) values.put(MediaStore.Images.ImageColumns.HEIGHT, 0); &#125; values.put(MediaStore.MediaColumns.MIME_TYPE, getPhotoMimeType(filePath)); context.getApplicationContext().getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values); &#125; /** * 保存到视频到本地，并插入MediaStore以保证相册可以查看到,这是更优化的方法，防止读取的视频获取不到宽高 * * @param context 上下文 * @param filePath 文件路径 * @param createTime 创建时间 &lt;=0时为当前时间 ms * @param duration 视频长度 ms * @param width 宽度 * @param height 高度 */ public static void insertVideoToMediaStore(Context context, String filePath, long createTime, int width, int height, long duration) &#123; if (!checkFile(filePath)) return; createTime = getTimeWrap(createTime); ContentValues values = initCommonContentValues(filePath, createTime); values.put(MediaStore.Video.VideoColumns.DATE_TAKEN, createTime); if (duration &gt; 0) values.put(MediaStore.Video.VideoColumns.DURATION, duration); if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.JELLY_BEAN) &#123; if (width &gt; 0) values.put(MediaStore.Video.VideoColumns.WIDTH, width); if (height &gt; 0) values.put(MediaStore.Video.VideoColumns.HEIGHT, height); &#125; values.put(MediaStore.MediaColumns.MIME_TYPE, getVideoMimeType(filePath)); context.getContentResolver().insert(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, values); &#125; // 是不是系统相册 private static boolean isSystemDcim(String path) &#123; return path.toLowerCase().contains(&quot;dcim&quot;) || path.toLowerCase().contains(&quot;camera&quot;); &#125; // 获取照片的mine_type private static String getPhotoMimeType(String path) &#123; String lowerPath = path.toLowerCase(); if (lowerPath.endsWith(&quot;jpg&quot;) || lowerPath.endsWith(&quot;jpeg&quot;)) &#123; return &quot;image/jpeg&quot;; &#125; else if (lowerPath.endsWith(&quot;png&quot;)) &#123; return &quot;image/png&quot;; &#125; else if (lowerPath.endsWith(&quot;gif&quot;)) &#123; return &quot;image/gif&quot;; &#125; return &quot;image/jpeg&quot;; &#125; // 获取video的mine_type,暂时只支持mp4,3gp private static String getVideoMimeType(String path) &#123; String lowerPath = path.toLowerCase(); if (lowerPath.endsWith(&quot;mp4&quot;) || lowerPath.endsWith(&quot;mpeg4&quot;)) &#123; return &quot;video/mp4&quot;; &#125; else if (lowerPath.endsWith(&quot;3gp&quot;)) &#123; return &quot;video/3gp&quot;; &#125; return &quot;video/mp4&quot;; &#125; // 获得转化后的时间 private static long getTimeWrap(long time) &#123; if (time &lt;= 0) &#123; return System.currentTimeMillis(); &#125; return time; &#125; // 检测文件存在 private static boolean checkFile(String filePath) &#123; boolean result = FileUtil.fileIsExist(filePath); Log.e(TAG, &quot;文件不存在 path = &quot; + filePath); return result; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义控件九宫格滑动解锁]]></title>
      <url>%2F2015%2F08%2F23%2FAndroid%E5%BC%80%E5%8F%91%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E4%B9%9D%E7%82%B9%E6%BB%91%E5%8A%A8%E8%A7%A3%E9%94%81%2F</url>
      <content type="text"><![CDATA[1. 前言 最近想给自己做的的app添加一个滑动解锁的功能，用的是乐视的手机，就模仿它的效果实现. 视频演示一下效果 GitHub 2. LockPoint实体 每个点是一个实体（LockPoint）用来存储这个点的所有信息，包括点的物理位置(x,y)和点的index位置(0-8) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class LockPoint &#123; // 点的位置 0-8 int index; // 点的x,y坐标 float x, y; // 构造方法，初始化一个点 LockPoint(int index, float x, float y) &#123; this.index = index; this.x = x; this.y = y; &#125; // 构造方法，从另一个点初始化 LockPoint(LockPoint p) &#123; this.x = p.x; this.y = p.y; this.index = p.index; &#125; // 默认构造方法，初始化为一个空的点 LockPoint() &#123; this.x = -1; this.y = -1; this.index = -1; &#125; // 判断该点是不是一个空的点 boolean isEmpty() &#123; return this.x == -1 &amp;&amp; this.y == -1; &#125; // 重新给位置赋值 void init(float x, float y) &#123; this.x = x; this.y = y; &#125; // 设置为另一点的值 void init(LockPoint p) &#123; this.x = p.x; this.y = p.y; this.index = p.index; &#125; // 判断一个位置是不是在该点触摸范围内,touchSensitiveRange为触摸有效半径 boolean isTouchIn(float judgeX, float judgeY) &#123; return judgeX &lt; x + touchSensitiveRange &amp;&amp; judgeX &gt; x - touchSensitiveRange &amp;&amp; judgeY &lt; y + touchSensitiveRange &amp;&amp; judgeY &gt; y - touchSensitiveRange; &#125; // 重写equals和hashCode @Override public boolean equals(Object o) &#123; LockPoint p = (LockPoint) o; return p.x == x &amp;&amp; p.y == y; &#125; @Override public int hashCode() &#123; return 2; &#125; String out(String tag) &#123; return tag + " : x = " + x + " , y = " + y; &#125; &#125; 3. 初始化 初始化九个点的位置，需要根据控件的大小动态计算，因此在onMeare()之后进行 需求是需要将九个点放在控件中间，来适应控件大小的变化，首先确定第一个点距离左边的距离startSpace，两个点之间的距离 =（控件宽度 - 2 * startSpace）／2 123456789101112int size = getMeasuredWidth(); // 将宽高设置为一样的，正方形 setMeasuredDimension(size, size); // 初始化屏幕中的九个点的位置和下标 initLockPointArray = new LockPoint[9]; // startSpace 为距离左边的距离，计算九个点的位置,保证九个点放在控件中间 if (startSpace == AUTO_START_SPACING) &#123; //默认是控件的1/4 startSpace = size / 4; &#125; // 计算每两个点之间的间隔 internalSpace = (size - 2 * startSpace) / 2; 初始化九个点的位置 12345678// 初始化九个点的位置 int index = 0; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; initLockPointArray[index] = new LockPoint(index, startSpace + j * internalSpace, startSpace + i * internalSpace); index++; &#125; &#125; onMeasure()完整代码 123456789101112131415161718192021222324252627282930// onMeasure之后初始化数据 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int size = getMeasuredWidth(); // 将宽高设置为一样的，正方形 setMeasuredDimension(size, size); // 初始化屏幕中的九个点的位置和下标 if (initLockPointArray == null) &#123; initLockPointArray = new LockPoint[9]; // startSpace 为距离左边的距离，计算九个点的位置放在控件中间 if (startSpace == AUTO_START_SPACING) &#123; startSpace = size / 4; &#125; // 计算每两个点之间的间隔 internalSpace = (size - 2 * startSpace) / 2; // 初始化九个点的位置 int index = 0; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; initLockPointArray[index] = new LockPoint(index, startSpace + j * internalSpace, startSpace + i * internalSpace); index++; &#125; &#125; // 为了在preview时能看到效果 if (isInEditMode()) &#123; historyPointList.addAll(Arrays.asList(initLockPointArray)); &#125; &#125; &#125; 4. onDraw 绘制过程大致分为三个步骤 绘制九个点，这是每次都需要绘制的 1234LockPoint tempPoint;for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; canvas.drawCircle(initLockPointArray[i].x, initLockPointArray[i].y, pointRadius, pointPaint);&#125; 绘制已经划过的点 123456// 绘制之前触过存储起来的的点,绘制第i个点和i+1个点之间的线 if (historyPointList.size() &gt; 0) &#123; for (int i = 0; i &lt; historyPointList.size() - 1; i++) &#123; canvas.drawLine(historyPointList.get(i).x, historyPointList.get(i).y, historyPointList.get(i + 1).x, historyPointList.get(i + 1).y, linePaint); &#125; &#125; 绘制触摸点和最后一个点的连线 123456// 画最后一个点和触摸的点之间的线 if (currentLockPoint != null &amp;&amp; currentLockPoint.x != -1 &amp;&amp; currentLockPoint.y != -1 &amp;&amp; touchPoint.x != -1 &amp;&amp; touchPoint.y != -1) &#123; canvas.drawLine(currentLockPoint.x, currentLockPoint.y, touchPoint.x, touchPoint.y, linePaint); &#125; 5. 事件处理 对用户touch事件进行处理 要记录当前触摸的点，用于绘制跟随手指的连线 检测触摸的点是不是在九个点中某个点的范围内，如果是的话该点要加入被触摸点的列表中 当手指抬起时，清除数据,恢复初始状态 12345678910111213141516171819202122232425262728293031323334353637@Override public boolean onTouchEvent(MotionEvent event) &#123; if (!isEnabled() || isEventOver) return false; int action = MotionEventCompat.getActionMasked(event); switch (action) &#123; // 重新初始化触摸点 case MotionEvent.ACTION_DOWN: touchPoint.init(event.getX(), event.getY()); break; // 移动时检测是否在触摸范围内 case MotionEvent.ACTION_MOVE: touchPoint.init(event.getX(), event.getY()); LockPoint tempPoint; for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; tempPoint = initLockPointArray[i]; if (!historyPointList.contains(tempPoint) &amp;&amp; tempPoint.isTouchIn(event.getX(), event.getY())) &#123; historyPointList.add(new LockPoint(tempPoint)); currentLockPoint.init(tempPoint); break; &#125; &#125; break; // 抬起时结束，重新初始化 case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: touchPoint.init(-1, -1); currentLockPoint.init(-1, -1); historyPointList.clear(); break; &#125; postInvalidate(); return true; &#125; 6. 优化-多点触控事件处理 用户在触摸屏幕时可能有多个手指在操作，上面的代码在单指时没有问题，兼容多点触控的思路是： 当用户触发down事件时，我们可以获取到一个pointerId，这个id唯一的标志了这个指头，后面发生的所有事件都使用用这个pointerId来获取，只处理这个指头的事件，避免事件的错乱。 当我们开始的时候标志的那个手指抬起来了怎么办呢，两个解决方法，第一个就是直接结束整个流程，相当于单指时手指抬起。第二个方法就是转移事件，当一个指头抬起时，从该事件中获取还没抬起的手指，更改标志的pointerId,事件就转移到了另一个手指上，我们关心就是新手指的触摸啦 关于对于事件进行处理的相关机制可以看Android事件机制，写的都是比较基本的东西，后面慢慢完善，不过理解获取多指的事件9⃣️绰绰有余啦 话不多说，上代码，比较需要注意的地方我都标注在注释中，方便查找 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 处理触摸事件，支持多点触摸 @Override public boolean onTouchEvent(MotionEvent event) &#123; // fast stop if (!isEnabled() || isEventOver) return false; // pointerIndex 是事件的在event中的下标 int pointerIndex; // 获取事件掩码 int action = MotionEventCompat.getActionMasked(event); switch (action) &#123; // 重新初始化触摸点 case MotionEvent.ACTION_DOWN: // pointerId 记录当前激活的pointerId activePointerId = event.getPointerId(0); // 根据pointerId查找事件在event中的位置 pointerIndex = event.findPointerIndex(activePointerId); // 根据位置获取到具体的事件的坐标，这里获得的坐标就是我们要记住的那个指头的坐标 touchPoint.init(event.getX(pointerIndex), event.getY(pointerIndex)); break; case MotionEvent.ACTION_MOVE: // 手指移动时还是根据激活的pointerId获取下标index,来进行后续操作，避免事件错乱 pointerIndex = event.findPointerIndex(activePointerId); // pointerIndex &lt; 0表示手指的事件获取不到了，结束响应事件 if (pointerIndex &lt; 0) &#123; Log.e(TAG, "Got ACTION_MOVE event but have an invalid active pointer id."); cancelLockDraw(); return false; &#125; // 根据移动的位置获取坐标，初始化touchPoint的值 touchPoint.init(event.getX(pointerIndex), event.getY(pointerIndex)); LockPoint tempPoint; // 检索触摸点有没有在九个点中的某一个的触摸范围内 for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; tempPoint = initLockPointArray[i]; if (!historyPointList.contains(tempPoint) &amp;&amp; tempPoint.isTouchIn(event.getX(pointerIndex), event.getY(pointerIndex))) &#123; LockPoint centerPoint = findCenterPoint(tempPoint); // 优化，查找两个点之间的点，后面会有介绍 if (!centerPoint.isEmpty()) &#123; activePoint(centerPoint); &#125; activePoint(tempPoint); break; &#125; &#125; break; case MotionEventCompat.ACTION_POINTER_UP: // 多指操作中 非 最后一个手指抬起时触发ACTION_POINTER_UP，此时要获取还在屏幕上的其他手指转移事件的对象 onSecondaryPointerUp(event); break; case MotionEvent.ACTION_UP: // 最后的手指抬起触发 ACTION_UP pointerIndex = event.findPointerIndex(activePointerId); if (pointerIndex &lt; 0) &#123; Log.e(TAG, "Got ACTION_UP event but don't have an active pointer id."); activePointerId = INVALID_POINTER; return false; &#125; // 发布绘制的结果，可能是监听回调之类的 publishResult(); // 置为-1 activePointerId = INVALID_POINTER; break; case MotionEvent.ACTION_CANCEL: // 类似up cancelLockDraw(); activePointerId = INVALID_POINTER; break; &#125; postInvalidate(); return true; &#125; 转移焦点的方法,在各种控件的源代码中随处可见，我也是拷贝出来直接用的，逻辑不是很复杂 123456789101112131415 /** * 当一个手机抬起时，转移焦点 * * @param ev 事件 */private void onSecondaryPointerUp(MotionEvent ev) &#123; final int pointerIndex = MotionEventCompat.getActionIndex(ev); final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex); if (pointerId == activePointerId) &#123; // This was our active pointer going up. Choose a new // active pointer and adjust accordingly. final int newPointerIndex = pointerIndex == 0 ? 1 : 0; activePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex); &#125; &#125; 发布结果 123456789101112131415161718192021222324/** * 发布绘制结果 */ private void publishResult() &#123; if (listener != null) &#123; isEventOver = true; StringBuilder sb = new StringBuilder(); for (LockPoint lockPoint : historyPointList) &#123; sb.append(lockPoint.index); &#125; String passWd = sb.toString(); boolean isFinish = listener.onFinish(LockView.this, passWd, passWd.length()); if (isFinish) &#123; // 输入合法 touchPoint.init(currentLockPoint); &#125; else &#123; // 输入不合法 cancelLockDraw(); isEventOver = false; &#125; &#125; else &#123; cancelLockDraw(); &#125; &#125; 回复初始状态,因为在多处调用了，贴一下 123456789/** * 结束绘制，恢复初始状态 */ private void cancelLockDraw() &#123; touchPoint.init(-1, -1); currentLockPoint.init(-1, -1); historyPointList.clear(); postInvalidate(); &#125; 7. 优化-自动添加两点之间连线上的点 当滑动时越过中间的点之间连接两端，自动查找和添加两点之间的点，手机上的滑动解锁也是这样的逻辑，不然会导致图形很繁琐，不美观而且不符合常见逻辑。也就是说如果当前激发的点和上一个激发的点之间有没有激发的点，那么自动给他激发。 首先如果两个点是相邻的或者是对角线上相邻，那么中间一定不会有空下来的点，需要排除这个情况 123456789101112131415161718/** * 检测相邻 * * @param p1 点1 * @param p2 点2 * @return p1和p2是否相邻，斜对角也算相邻 */ private boolean isAdjacentPoint(LockPoint p1, LockPoint p2) &#123; // internalSpace是初始化时两个点之间的距离，都是简单的计算和情况罗列 if ((p1.x == p2.x &amp;&amp; Math.abs(p1.y - p2.y) == internalSpace) || (p1.y == p2.y &amp;&amp; Math.abs(p1.x - p2.x) == internalSpace) || (Math.abs(p1.x - p2.x) == internalSpace &amp;&amp; Math.abs(p1.y - p2.y) == internalSpace)) &#123; Log.e(TAG, "相邻点，不处理"); return true; &#125; return false; &#125; 然后如何判断一个点位于首尾两个激发点的中间，思路是当这个点在两个点的连线上时且不是首尾两个点就是中间的点。判断的根据是斜率是不是相等，就是初中的数学问题啦。 12345678910111213/** * 判断c点是不是在p1-p2的直线上 * * @param p1 起始点 * @param p2 终止点 * @param c 判断的点 * @return 是否在该线上 */ private boolean isInLine(LockPoint p1, LockPoint p2, LockPoint c) &#123; float k1 = (p1.x - p2.x) * 1f / (p1.y - p2.y); float k2 = (p1.x - c.x) * 1f / (p1.y - c.y); return k1 == k2; &#125; 最后整合一下，去掉不必要的判断，在touch事件中调用 123456789101112131415161718192021222324252627282930313233/** * 检测当前激活的点和上一个激活点之间的是否有没有激发的点 * * @param activePoint 当前被激发的点 * @return 当前激活的点和上一个激活点之间的是否有没有激发的点，没有返回empty的&#123;@link LockPoint#isEmpty()&#125; */ private LockPoint findCenterPoint(LockPoint activePoint) &#123; LockPoint rstPoint = new LockPoint(); // 只有一个点不需要比较 if (historyPointList.size() &lt; 1) &#123; return rstPoint; &#125; LockPoint tempPoint; // 获取上个点 LockPoint preActivePoint = historyPointList.get(historyPointList.size() - 1); // 两个点是不是相邻的，是相邻的是坚决不会中间有点被空出来的 if (isAdjacentPoint(preActivePoint, activePoint)) return rstPoint; for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; tempPoint = initLockPointArray[i]; // 没有被触摸过 &amp;&amp; 不是首点 &amp;&amp; 不是尾点 if (!historyPointList.contains(tempPoint) &amp;&amp; !preActivePoint.equals(tempPoint) &amp;&amp; !activePoint.equals(tempPoint)) &#123; // 在连线上 if (isInLine(preActivePoint, activePoint, tempPoint)) &#123; Log.e(TAG, "点在线上 " + tempPoint.out("temp") + " " + preActivePoint.out("pre") + " " + activePoint.out("active")); rstPoint.init(tempPoint); break; &#125; &#125; &#125; return rstPoint; &#125; 在onTouchEvent中调用 123456LockPoint centerPoint = findCenterPoint(tempPoint); // 优化，查找两个点之间的点 if (!centerPoint.isEmpty()) &#123; activePoint(centerPoint); &#125; activePoint(tempPoint); 8. 优化-给被触摸的点添加动画 当手指触摸到一个点时，添加一个缩放动画来反馈触摸操作 思路时，当触摸到一个点时使用ValueAnimator开启动画，不断改变半径的值，在绘制时达到实现缩放的效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 开始缩放动画 */ private void startScaleAnimation() &#123; if (mScaleAnimator == null) &#123; mScaleAnimator = ValueAnimator.ofFloat(1f, scaleMax, 1f); mScaleAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float scale = (float) animation.getAnimatedValue(); // 不断改变半径的值 scalePointRadius = pointRadius * scale; postInvalidate(); &#125; &#125;); mScaleAnimator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; &#125; @Override public void onAnimationEnd(Animator animation) &#123; // 动画结束后初始化回标准半径的值 scalePointRadius = pointRadius; &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; &#125;); mScaleAnimator.setDuration(scaleAnimDuration); &#125; if (mScaleAnimator.isRunning()) mScaleAnimator.end(); mScaleAnimator.start(); &#125; 同时在onDraw()方法中对刚刚触摸的点要进行绘制,更改onDraw()方法中绘制九个点的部分，对刚刚触摸的点使用缩放后的半径绘制。 1234567891011// 绘制九个点，当动画在执行时被激活的点会被放大 LockPoint tempPoint; for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; tempPoint = initLockPointArray[i]; // 最后触摸的点 if (currentLockPoint != null &amp;&amp; currentLockPoint.equals(tempPoint)) &#123; canvas.drawCircle(tempPoint.x, tempPoint.y, scalePointRadius, pointPaint); &#125; else &#123; canvas.drawCircle(tempPoint.x, tempPoint.y, pointRadius, pointPaint); &#125; &#125; 9. 回调 使用监听将结果回调给使用者，在ACTION_UP时发布结果 12345678910111213141516171819202122232425262728293031323334353637public interface OnLockFinishListener &#123; /** * * @param lockView 控件 * @param passWd 密码 * @param passWsLength 密码长度 * @return 当返回true时，画面将会定格在绘制结束后的状态，比如当密码输入正确的时候 * 返回false时，画面会重新初始化回初始状态，比如密码重新二次输入确认或者密码错误的时候 */ boolean onFinish(LockView lockView, String passWd, int passWsLength); &#125; /** * 发布绘制结果 */ private void publishResult() &#123; if (listener != null) &#123; isEventOver = true; StringBuilder sb = new StringBuilder(); for (LockPoint lockPoint : historyPointList) &#123; sb.append(lockPoint.index); &#125; String passWd = sb.toString(); boolean isFinish = listener.onFinish(LockView.this, passWd, passWd.length()); if (isFinish) &#123; // 画面定格 touchPoint.init(currentLockPoint); &#125; else &#123; // 恢复初始化 cancelLockDraw(); isEventOver = false; &#125; &#125; else &#123; cancelLockDraw(); &#125; &#125; 10. 综上 还遗留了一个点，就是自动添加中间的点时应该也是有动画效果的，暂时还没做，有空补上吧，希望大家指正。 11. 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514/** * Project : CdLibsTest * Package : com.march.cdlibstest.widget * CreateAt : 2016/11/26 * Describe : 自定义控件实现九宫格滑动解锁 * * @author chendong */public class LockView extends View &#123; public static final String TAG = "LOCK_VIEW"; private static final int INVALID_POINTER = -1; private static final int AUTO_START_SPACING = -1; private static final int DEFAULT_MIN_POINT_NUM = 4; // 激活的触摸点id private int activePointerId = INVALID_POINTER; // 四边的间隔，默认是控件的1／4 private int startSpace; // 两点间隔 private int internalSpace; // 点的半径 private int pointRadius; // 动画scale的半径 private float scalePointRadius; // 触摸半径，在点的一定范围内触发 private int touchSensitiveRange; // 线宽度 private int lineWidth; // 点颜色 private int pointColor; // 线颜色 private int lineColor; // 缩放的大小 private float scaleMax; // 动画时间 private int scaleAnimDuration = 150; // 本次绘制结束，调用init()方法恢复初始化 private boolean isEventOver = false; class LockPoint &#123; // 点的位置 0-8 int index; // 点的x,y坐标 float x, y; // 构造方法，初始化一个点 LockPoint(int index, float x, float y) &#123; this.index = index; this.x = x; this.y = y; &#125; // 构造方法，从另一个点初始化 LockPoint(LockPoint p) &#123; this.x = p.x; this.y = p.y; this.index = p.index; &#125; // 默认构造方法，初始化为一个空的点 LockPoint() &#123; this.x = -1; this.y = -1; this.index = -1; &#125; // 判断该点是不是一个空的点 boolean isEmpty() &#123; return this.x == -1 &amp;&amp; this.y == -1; &#125; // 重新给位置赋值 void init(float x, float y) &#123; this.x = x; this.y = y; &#125; // 设置为另一点的值 void init(LockPoint p) &#123; this.x = p.x; this.y = p.y; this.index = p.index; &#125; // 判断一个位置是不是在该点触摸范围内,touchSensitiveRange为触摸有效半径 boolean isTouchIn(float judgeX, float judgeY) &#123; return judgeX &lt; x + touchSensitiveRange &amp;&amp; judgeX &gt; x - touchSensitiveRange &amp;&amp; judgeY &lt; y + touchSensitiveRange &amp;&amp; judgeY &gt; y - touchSensitiveRange; &#125; // 重写equals和hashCode @Override public boolean equals(Object o) &#123; LockPoint p = (LockPoint) o; return p.x == x &amp;&amp; p.y == y; &#125; @Override public int hashCode() &#123; return 2; &#125; String out(String tag) &#123; return tag + " : x = " + x + " , y = " + y; &#125; &#125; // 动画 private ValueAnimator mScaleAnimator; // 初始化的九个点 private LockPoint[] initLockPointArray; // 触摸过的点泪飙 private List&lt;LockPoint&gt; historyPointList; // 触摸的点 private LockPoint touchPoint; // 当前最后一个激活的点 private LockPoint currentLockPoint; // 画线 private Paint linePaint; // 画点 private Paint pointPaint; // 监听 private OnLockFinishListener listener; public interface OnLockFinishListener &#123; /** * * @param lockView 控件 * @param passWd 密码 * @param passWsLength 密码长度 * @return 当返回true时，画面将会定格在绘制结束后的状态 * 返回false时，画面会重新初始化回初始状态 */ boolean onFinish(LockView lockView, String passWd, int passWsLength); &#125; public LockView(Context context) &#123; this(context, null); &#125; public LockView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public LockView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.LockView); float density = getResources().getDisplayMetrics().density; pointRadius = (int) typedArray.getDimension(R.styleable.LockView_lock_pointRadius, (8 * density)); scalePointRadius = pointRadius; touchSensitiveRange = (int) typedArray.getDimension(R.styleable.LockView_lock_touchSensitiveRange, pointRadius * 3); startSpace = (int) typedArray.getDimension(R.styleable.LockView_lock_startSpace, AUTO_START_SPACING); lineWidth = (int) typedArray.getDimension(R.styleable.LockView_lock_lineWidth, (5 * density)); lineColor = typedArray.getColor(R.styleable.LockView_lock_lineColor, Color.WHITE); pointColor = typedArray.getColor(R.styleable.LockView_lock_pointColor, Color.WHITE); scaleAnimDuration = typedArray.getInt(R.styleable.LockView_lock_scaleAnimDuration, 180); scaleMax = typedArray.getFloat(R.styleable.LockView_lock_scaleMax, 2.5f); typedArray.recycle(); historyPointList = new ArrayList&lt;&gt;(); touchPoint = new LockPoint(); currentLockPoint = new LockPoint(); pointPaint = new Paint(); pointPaint.setAntiAlias(true); pointPaint.setColor(pointColor); pointPaint.setStyle(Paint.Style.FILL_AND_STROKE); linePaint = new Paint(); linePaint.setAntiAlias(true); linePaint.setStrokeWidth(lineWidth); linePaint.setColor(lineColor); linePaint.setStyle(Paint.Style.STROKE); &#125; public void setListener(OnLockFinishListener listener) &#123; this.listener = listener; &#125; /** * 开始缩放动画 */ private void startScaleAnimation() &#123; if (mScaleAnimator == null) &#123; mScaleAnimator = ValueAnimator.ofFloat(1f, scaleMax, 1f); mScaleAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float scale = (float) animation.getAnimatedValue(); scalePointRadius = pointRadius * scale; postInvalidate(); &#125; &#125;); mScaleAnimator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; &#125; @Override public void onAnimationEnd(Animator animation) &#123; scalePointRadius = pointRadius; &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; &#125;); mScaleAnimator.setDuration(scaleAnimDuration); &#125; if (mScaleAnimator.isRunning()) mScaleAnimator.end(); mScaleAnimator.start(); &#125; // 处理触摸事件，支持多点触摸 @Override public boolean onTouchEvent(MotionEvent event) &#123; // fast stop if (!isEnabled() || isEventOver) return false; // pointerIndex 是事件的在event中的下标 int pointerIndex; // 获取事件掩码 int action = MotionEventCompat.getActionMasked(event); switch (action) &#123; // 重新初始化触摸点 case MotionEvent.ACTION_DOWN: // pointerId 记录当前激活的pointerId activePointerId = event.getPointerId(0); // 根据pointerId查找事件在event中的位置 pointerIndex = event.findPointerIndex(activePointerId); // 根据位置获取到具体的事件的坐标，这里获得的坐标就是我们要记住的那个指头的坐标 touchPoint.init(event.getX(pointerIndex), event.getY(pointerIndex)); break; case MotionEvent.ACTION_MOVE: // 手指移动时还是根据激活的pointerId获取下标index,来进行后续操作，避免事件错乱 pointerIndex = event.findPointerIndex(activePointerId); // pointerIndex &lt; 0表示手指的事件获取不到了，结束响应事件 if (pointerIndex &lt; 0) &#123; Log.e(TAG, "Got ACTION_MOVE event but have an invalid active pointer id."); cancelLockDraw(); return false; &#125; // 根据移动的位置获取坐标，初始化touchPoint的值 touchPoint.init(event.getX(pointerIndex), event.getY(pointerIndex)); LockPoint tempPoint; // 检索触摸点有没有在九个点中的某一个的触摸范围内 for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; tempPoint = initLockPointArray[i]; if (!historyPointList.contains(tempPoint) &amp;&amp; tempPoint.isTouchIn(event.getX(pointerIndex), event.getY(pointerIndex))) &#123; LockPoint centerPoint = findCenterPoint(tempPoint); if (!centerPoint.isEmpty()) &#123; activePoint(centerPoint); &#125; activePoint(tempPoint); break; &#125; &#125; break; case MotionEventCompat.ACTION_POINTER_UP: // 多指操作中 非 最后一个手指抬起时触发ACTION_POINTER_UP，此时要获取还在屏幕上的其他手指转移事件的对象 onSecondaryPointerUp(event); break; case MotionEvent.ACTION_UP: // 最后的手指抬起触发 ACTION_UP pointerIndex = event.findPointerIndex(activePointerId); if (pointerIndex &lt; 0) &#123; Log.e(TAG, "Got ACTION_UP event but don't have an active pointer id."); activePointerId = INVALID_POINTER; return false; &#125; // 发布绘制的结果，可能是监听回调之类的 publishResult(); // 置为-1 activePointerId = INVALID_POINTER; break; case MotionEvent.ACTION_CANCEL: // 类似up cancelLockDraw(); activePointerId = INVALID_POINTER; break; &#125; postInvalidate(); return true; &#125; /** * 发布绘制结果 */ private void publishResult() &#123; if (listener != null) &#123; isEventOver = true; StringBuilder sb = new StringBuilder(); for (LockPoint lockPoint : historyPointList) &#123; sb.append(lockPoint.index); &#125; String passWd = sb.toString(); boolean isFinish = listener.onFinish(LockView.this, passWd, passWd.length()); if (isFinish) &#123; // 输入合法 touchPoint.init(currentLockPoint); &#125; else &#123; // 输入不合法 cancelLockDraw(); isEventOver = false; &#125; &#125; else &#123; cancelLockDraw(); &#125; &#125; /** * 当一个手机抬起时，转移焦点 * * @param ev 事件 */ private void onSecondaryPointerUp(MotionEvent ev) &#123; final int pointerIndex = MotionEventCompat.getActionIndex(ev); final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex); if (pointerId == activePointerId) &#123; // This was our active pointer going up. Choose a new // active pointer and adjust accordingly. final int newPointerIndex = pointerIndex == 0 ? 1 : 0; activePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex); &#125; &#125; /** * 检测当前激活的点和上一个激活点之间的是否有没有激发的点 * * @param activePoint 当前被激发的点 * @return 当前激活的点和上一个激活点之间的是否有没有激发的点，没有返回empty的&#123;@link LockPoint#isEmpty()&#125; */ private LockPoint findCenterPoint(LockPoint activePoint) &#123; LockPoint rstPoint = new LockPoint(); // 只有一个点不需要比较 if (historyPointList.size() &lt; 1) &#123; return rstPoint; &#125; LockPoint tempPoint; // 获取上个点 LockPoint preActivePoint = historyPointList.get(historyPointList.size() - 1); // 两个点是不是相邻的，是相邻的是坚决不会中间有点被空出来的 if (isAdjacentPoint(preActivePoint, activePoint)) return rstPoint; for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; tempPoint = initLockPointArray[i]; // 没有被触摸过 &amp;&amp; 不是首点 &amp;&amp; 不是尾点 if (!historyPointList.contains(tempPoint) &amp;&amp; !preActivePoint.equals(tempPoint) &amp;&amp; !activePoint.equals(tempPoint)) &#123; if (isInLine(preActivePoint, activePoint, tempPoint)) &#123; Log.e(TAG, "点在线上 " + tempPoint.out("temp") + " " + preActivePoint.out("pre") + " " + activePoint.out("active")); rstPoint.init(tempPoint); break; &#125; &#125; &#125; return rstPoint; &#125; /** * 检测相邻 * * @param p1 点1 * @param p2 点2 * @return p1和p2是否相邻，斜对角也算相邻 */ private boolean isAdjacentPoint(LockPoint p1, LockPoint p2) &#123; if ((p1.x == p2.x &amp;&amp; Math.abs(p1.y - p2.y) == internalSpace) || (p1.y == p2.y &amp;&amp; Math.abs(p1.x - p2.x) == internalSpace) || (Math.abs(p1.x - p2.x) == internalSpace &amp;&amp; Math.abs(p1.y - p2.y) == internalSpace)) &#123; Log.e(TAG, "相邻点，不处理"); return true; &#125; return false; &#125; /** * 判断c点是不是在p1-p2的直线上 * * @param p1 起始点 * @param p2 终止点 * @param c 判断的点 * @return 是否在该线上 */ private boolean isInLine(LockPoint p1, LockPoint p2, LockPoint c) &#123; float k1 = (p1.x - p2.x) * 1f / (p1.y - p2.y); float k2 = (p1.x - c.x) * 1f / (p1.y - c.y); return k1 == k2; &#125; /** * 激活该点，该点将会添加到选中点列表中，然后执行动画 * * @param tempPoint 被激活的点 */ private void activePoint(LockPoint tempPoint) &#123; historyPointList.add(new LockPoint(tempPoint)); currentLockPoint.init(tempPoint); startScaleAnimation(); postInvalidate(); &#125; public void init() &#123; isEventOver = false; cancelLockDraw(); &#125; /** * 结束绘制，恢复初始状态 */ private void cancelLockDraw() &#123; touchPoint.init(-1, -1); currentLockPoint.init(-1, -1); historyPointList.clear(); postInvalidate(); &#125; // onMeasure之后初始化数据 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int size = getMeasuredWidth(); // 将宽高设置为一样的，正方形 setMeasuredDimension(size, size); // 初始化屏幕中的九个点的位置和下标 if (initLockPointArray == null) &#123; initLockPointArray = new LockPoint[9]; // startSpace 为距离左边的距离，计算九个点的位置放在控件中间 if (startSpace == AUTO_START_SPACING) &#123; startSpace = size / 4; &#125; // 计算每两个点之间的间隔 internalSpace = (size - 2 * startSpace) / 2; // 初始化九个点的位置 int index = 0; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; initLockPointArray[index] = new LockPoint(index, startSpace + j * internalSpace, startSpace + i * internalSpace); index++; &#125; &#125; // 为了在preview时能看到效果 if (isInEditMode()) &#123; historyPointList.addAll(Arrays.asList(initLockPointArray)); &#125; &#125; &#125; private void log(Object... objs) &#123; StringBuilder sb = new StringBuilder(); for (Object obj : objs) &#123; sb.append(obj.toString()).append(" "); &#125; Log.e(TAG, sb.toString()); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // fast stop if (initLockPointArray == null) return; log(currentLockPoint.out("current"), touchPoint.out("touch")); // 画最后一个点和触摸的点之间的线 if (currentLockPoint != null &amp;&amp; currentLockPoint.x != -1 &amp;&amp; currentLockPoint.y != -1 &amp;&amp; touchPoint.x != -1 &amp;&amp; touchPoint.y != -1) &#123; canvas.drawLine(currentLockPoint.x, currentLockPoint.y, touchPoint.x, touchPoint.y, linePaint); &#125; // 绘制之前触过存储起来的的点 if (historyPointList.size() &gt; 0) &#123; for (int i = 0; i &lt; historyPointList.size() - 1; i++) &#123; canvas.drawLine(historyPointList.get(i).x, historyPointList.get(i).y, historyPointList.get(i + 1).x, historyPointList.get(i + 1).y, linePaint); &#125; &#125; // 绘制九个点，当动画在执行时被激活的点会被放大 LockPoint tempPoint; for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; tempPoint = initLockPointArray[i]; if (currentLockPoint != null &amp;&amp; currentLockPoint.equals(tempPoint)) &#123; canvas.drawCircle(tempPoint.x, tempPoint.y, scalePointRadius, pointPaint); &#125; else &#123; canvas.drawCircle(tempPoint.x, tempPoint.y, pointRadius, pointPaint); &#125; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[加密解密（DES,AES）]]></title>
      <url>%2F2015%2F08%2F15%2F%E5%AD%A6%E4%B9%A0%2FJava_AES%E5%92%8CDES%E5%8A%A0%E8%A7%A3%E5%AF%86%2F</url>
      <content type="text"><![CDATA[前言 加密解密的原理是个很麻烦的问题，我之前上过一门课叫密码学，最后也没怎么学懂，所以这里我们只是使用java代码实现加密解密的功能，而不是讨论他的原理。 DES简单介绍 DES(Data Encryption Standard)即数据加密标准，使用56bit密钥，将64bit的明文数据块加密为64bit密文。 DES使用56bit密钥加密，秘钥要求8个字节64bit，每个字节有一位是奇偶校验位。 DES加密强度小，容易被破解 DES加密代码实现123456789101112131415161718192021222324252627282930313233343536373839404142/** * DES加密解密 * @param data 需要加密的数据 * @param key 秘钥，必须是8个字节 * @param mode 加密或者解密模式 * Cipher.ENCRYPT_MODE * Cipher.DECRYPT_MODE * @return */ public static byte[] DESCrypt(byte[] data, byte[] key, int mode) &#123; byte[] result = null; if (data == null || key == null || data.length &lt;= 0 || key.length &lt;= 0) return null; //DES密码必须是8个字节，64bit长度 try &#123; //创建加密引擎 Cipher cipher = Cipher.getInstance("DES"); //指定8个字节密码 DESKeySpec desKeySpec = new DESKeySpec(key); //生成密码工厂 SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance("DES"); //生成密码 SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec); //设置模式，加密解密 cipher.init(mode, secretKey); //加密。设置字节数组作为待加密内容,返回值是最终加密结果 result = cipher.doFinal(data); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeySpecException e) &#123; e.printStackTrace(); &#125; catch (BadPaddingException e) &#123; e.printStackTrace(); &#125; catch (IllegalBlockSizeException e) &#123; e.printStackTrace(); &#125; return result; &#125; AES简单介绍 AES(Advanced Encryption Standard)，即为高级加密标准。在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。AES的区块长度固定为128 比特，密钥长度则可以是128，192或256比特； 低强度加密代码实现12345678910111213141516171819202122232425262728293031/** * AES低强度加密解密 * @param data * @param key * @param mode Cipher.ENCRYPT_MODE * Cipher.DECRYPT_MODE * @return */ public static byte[] AESCrypt(byte[] data,byte[] key,int mode)&#123; byte[] result = null; if (data == null || key == null || data.length &lt;= 0 || key.length &lt;= 0) return null; try &#123; Cipher cipher = Cipher.getInstance("AES"); SecretKeySpec secretKeySpec = new SecretKeySpec(key,"AES"); cipher.init(mode,secretKeySpec); result = cipher.doFinal(data); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (BadPaddingException e) &#123; e.printStackTrace(); &#125; catch (IllegalBlockSizeException e) &#123; e.printStackTrace(); &#125; return result; &#125; 高强度加密，使用iv参数1234567891011121314151617181920212223242526272829303132333435/** * AES高强度加密 * * @param data * @param key * @param iv 用于AES/CBC、PKCS5Padding这个带有加密模式的算法 * @param mode * @return */ public static byte[] AESCrypt(byte[] data, byte[] key, byte[] iv, int mode) &#123; byte[] result = null; if (data == null || key == null || data.length &lt;= 0 || key.length &lt;= 0) return null; try &#123; Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); SecretKeySpec secretKeySpec = new SecretKeySpec(key, "AES"); //准备iv参数，用于支持CBC或者ECB模式 IvParameterSpec ivParameterSpec = new IvParameterSpec(iv); cipher.init(mode, secretKeySpec, ivParameterSpec); result = cipher.doFinal(data); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (BadPaddingException e) &#123; e.printStackTrace(); &#125; catch (IllegalBlockSizeException e) &#123; e.printStackTrace(); &#125; catch (InvalidAlgorithmParameterException e) &#123; e.printStackTrace(); &#125; return result; &#125; 以上]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[加密解密（RSA）]]></title>
      <url>%2F2015%2F08%2F11%2F%E5%AD%A6%E4%B9%A0%2FJava_RSA%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%2F</url>
      <content type="text"><![CDATA[介绍 什么是对称加密，什么是非对称加密？ 加密解密使用同样的密钥，则是对称加密，使用不一样的密钥就是非对称加密，RSA属于非对称加密。 RSA中有公钥和私钥的概念，公钥加密私钥解密，私钥加密公钥解密，也可以使用RSA对消息进行签名 一些常量1234567891011121314151617181920212223242526272829/** * 加密算法RSA */ public static final String KEY_ALGORITHM = "RSA"; /** * 签名算法 */ public static final String SIGNATURE_ALGORITHM = "MD5withRSA"; /** * 获取公钥的key */ public static final String PUBLIC_KEY = "RSAPublicKey"; /** * 获取私钥的key */ public static final String PRIVATE_KEY = "RSAPrivateKey"; /** * RSA最大加密明文大小 */ private static final int MAX_ENCRYPT_BLOCK = 117; /** * RSA最大解密密文大小 */ private static final int MAX_DECRYPT_BLOCK = 128; 2.获取密钥对 这里使用了内置的方法获取生成的公钥私钥，返回的密钥已经经过了Base64编码的处理，是可见的字符串。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 /** * &lt;p&gt; * 生成密钥对(公钥和私钥) * &lt;/p&gt; * * @return * @throws Exception */ public static Map&lt;String, Object&gt; getKeyPair(int size) throws Exception &#123; KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(KEY_ALGORITHM); keyPairGen.initialize(size); KeyPair keyPair = keyPairGen.generateKeyPair(); RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); Map&lt;String, Object&gt; keyMap = new HashMap&lt;String, Object&gt;(2); keyMap.put(PUBLIC_KEY, publicKey); keyMap.put(PRIVATE_KEY, privateKey); return keyMap; &#125;/** * &lt;p&gt; * 获取私钥 * &lt;/p&gt; * * @param keyMap 密钥对 * @return 获取的key已经经过base64编码 * @throws Exception */ public static String getPrivateKey(Map&lt;String, Object&gt; keyMap) throws Exception &#123; Key key = (Key) keyMap.get(PRIVATE_KEY); // return Base64Utils.encode(key.getEncoded()); return Base64.encodeToString(key.getEncoded(), Base64.NO_WRAP); &#125; /** * &lt;p&gt; * 获取公钥 * &lt;/p&gt; * * @param keyMap 密钥对 * @return 获取的key已经经过base64编码 * @throws Exception */ public static String getPublicKey(Map&lt;String, Object&gt; keyMap) throws Exception &#123; Key key = (Key) keyMap.get(PUBLIC_KEY); // return Base64Utils.encode(key.getEncoded()); return Base64.encodeToString(key.getEncoded(), Base64.NO_WRAP); &#125;` 私钥加密123456789101112131415161718192021222324252627282930313233343536373839 /** * &lt;p&gt; * 私钥加密 * &lt;/p&gt; * * @param data 源数据 * @param privateKey 私钥(BASE64编码) * @return * @throws Exception */ public static byte[] encryptByPrivateKey(byte[] data, String privateKey) throws Exception &#123;// byte[] keyBytes = Base64Utils.decode(privateKey); byte[] keyBytes = Base64.decode(privateKey, Base64.NO_WRAP); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key privateK = keyFactory.generatePrivate(pkcs8KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, privateK); int inputLen = data.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段加密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) &#123; cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(data, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_ENCRYPT_BLOCK; &#125; byte[] encryptedData = out.toByteArray(); out.close(); return encryptedData; &#125; 公钥加密123456789101112131415161718192021222324252627282930313233343536373839/** * &lt;p&gt; * 公钥加密 * &lt;/p&gt; * * @param data 源数据 * @param publicKey 公钥(BASE64编码) * @return * @throws Exception */ public static byte[] encryptByPublicKey(byte[] data, String publicKey) throws Exception &#123; byte[] keyBytes = Base64.decode(publicKey, Base64.NO_WRAP); X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key publicK = keyFactory.generatePublic(x509KeySpec); // 对数据加密 Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, publicK); int inputLen = data.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段加密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) &#123; cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(data, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_ENCRYPT_BLOCK; &#125; byte[] encryptedData = out.toByteArray(); out.close(); return encryptedData; &#125; 公钥解密123456789101112131415161718192021222324252627282930313233343536373839/** * &lt;p&gt; * 公钥解密 * &lt;/p&gt; * * @param encryptedData 已加密数据 * @param publicKey 公钥(BASE64编码) * @return * @throws Exception */public static byte[] decryptByPublicKey(byte[] encryptedData, String publicKey) throws Exception &#123; byte[] keyBytes = Base64.decode(publicKey, Base64.NO_WRAP); X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key publicK = keyFactory.generatePublic(x509KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, publicK); int inputLen = encryptedData.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) &#123; cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; &#125; byte[] decryptedData = out.toByteArray(); out.close(); return decryptedData;&#125; 私钥解密1234567891011121314151617181920212223242526272829303132333435363738/** * &lt;P&gt; * 私钥解密 * &lt;/p&gt; * * @param encryptedData 已加密数据 * @param privateKey 私钥(BASE64编码) * @return * @throws Exception */ public static byte[] decryptByPrivateKey(byte[] encryptedData, String privateKey) throws Exception &#123; byte[] keyBytes = Base64.decode(privateKey, Base64.NO_WRAP); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key privateK = keyFactory.generatePrivate(pkcs8KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, privateK); int inputLen = encryptedData.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) &#123; cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; &#125; byte[] decryptedData = out.toByteArray(); out.close(); return decryptedData; &#125; 消息签名123456789101112131415161718192021/** * &lt;p&gt; * 用私钥对信息生成数字签名 * &lt;/p&gt; * * @param data 已加密数据 * @param privateKey 私钥(BASE64编码) * @return * @throws Exception */public static String sign(byte[] data, String privateKey) throws Exception &#123; byte[] keyBytes = Base64.decode(privateKey, Base64.NO_WRAP); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); PrivateKey privateK = keyFactory.generatePrivate(pkcs8KeySpec); Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM); signature.initSign(privateK); signature.update(data); return Base64.encodeToString(signature.sign(), Base64.NO_WRAP);&#125; 验证签名12345678910111213141516171819202122/** * &lt;p&gt; * 使用公钥校验数字签名 * &lt;/p&gt; * * @param data 已加密数据 * @param publicKey 公钥(BASE64编码) * @param sign 数字签名 * @return * @throws Exception */ public static boolean verifySign(byte[] data, String publicKey, String sign) throws Exception &#123; byte[] keyBytes = Base64.decode(publicKey, Base64.NO_WRAP); X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); PublicKey publicK = keyFactory.generatePublic(keySpec); Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM); signature.initVerify(publicK); signature.update(data); return signature.verify(Base64.decode(sign, Base64.NO_WRAP)); &#125; 抽取公共代码 可以发现有很多重复代码，这样写是为了更加清晰，代码抽取一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * * 使用私钥操作时 * @param data * @param key * @param mode * @return * @throws Exception */ public static byte[] UsePrivate(byte[] data, String key,int mode) throws Exception &#123; byte[] keyBytes = Base64.decode(key, Base64.NO_WRAP); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key privateK = keyFactory.generatePrivate(pkcs8KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(mode, privateK); int inputLen = data.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) &#123; cache = cipher.doFinal(data, offSet, MAX_DECRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(data, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; &#125; byte[] decryptedData = out.toByteArray(); out.close(); return decryptedData; &#125; /** * 使用公钥操作 * @param data * @param key * @param mode * @return * @throws Exception */ public static byte[] UsePublic(byte[] data, String key,int mode) throws Exception &#123; byte[] keyBytes = Base64.decode(key, Base64.NO_WRAP); X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key publicK = keyFactory.generatePublic(x509KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(mode, publicK); int inputLen = data.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) &#123; cache = cipher.doFinal(data, offSet, MAX_DECRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(data, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; &#125; byte[] decryptedData = out.toByteArray(); out.close(); return decryptedData; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python发送get/post/put/delete请求]]></title>
      <url>%2F2015%2F08%2F11%2F%E5%AD%A6%E4%B9%A0%2Fpython%E5%8F%91%E9%80%81get%3Apost%3Aput%3Adelete%E8%AF%B7%E6%B1%82%2F</url>
      <content type="text"><![CDATA[Get请求12345# 如果没有header可以不传request = urllib2.Request(reqUrl, reqHeader)# reqTimeOut为超时时间，不设置可以不传response = urllib2.urlopen(request, reqTimeOut)print respone.read() Post请求12345# 如果没有header可以不传request = urllib2.Request(reqUrl,reqHeader,postData)# reqTimeOut为超时时间，不设置可以不传response = urllib2.urlopen(request, reqTimeOut)print respone.read() Put请求123456# 如果没有header可以不传request = urllib2.Request(reqUrl,reqHeader,postData)# reqTimeOut为超时时间，不设置可以不传response = urllib2.urlopen(request, reqTimeOut)request.get_method = lambda: 'PUT'print respone.read() Delete请求123456# 如果没有header可以不传request = urllib2.Request(reqUrl,reqHeader,postData)# reqTimeOut为超时时间，不设置可以不传response = urllib2.urlopen(request, reqTimeOut)request.get_method = lambda: 'DELETE'print respone.read() debug12345//使用Handler打印日志httpHandler = urllib2.HTTPHandler(debuglevel=1)httpsHandler = urllib2.HTTPSHandler(debuglevel=1)opener = urllib2.build_opener(httpHandler, httpsHandler)urllib2.install_opener(opener) 总结 一个集合了几种请求的工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# -*-coding:utf-8 -*-import urllib2from httptst.Singleton import singleton__metaclass = type@singletonclass HttpHelper: def __init__(self): pass name = 'http helper' # header __reqHeader = &#123;&#125; # url __reqUrl = '' # time __reqTimeOut = 0 # 构建Get请求 def __buildGetRequest(self): if len(self.__reqHeader) == 0: request = urllib2.Request(self.__reqUrl) else: request = urllib2.Request(self.__reqUrl, headers=self.__reqHeader) return request # 构建post,put,delete请求 def __buildPostPutDeleteRequest(self, postData): if len(self.__reqHeader) == 0: request = urllib2.Request(self.__reqUrl, data=postData) else: request = urllib2.Request(self.__reqUrl, headers=self.__reqHeader, data=postData) return request # 添加header def headers(self, headers): self.__reqHeader = headers return self # 添加url def url(self, url): print url self.__reqUrl = url return self # 添加超时 def timeOut(self, time): self.__reqTimeOut = time return self # 是否debug def debug(self): httpHandler = urllib2.HTTPHandler(debuglevel=1) httpsHandler = urllib2.HTTPSHandler(debuglevel=1) opener = urllib2.build_opener(httpHandler, httpsHandler) urllib2.install_opener(opener) return self # 处理response def __handleResponse(self, request, func): try: if self.__reqTimeOut == 0: res = urllib2.urlopen(request) else: res = urllib2.urlopen(request, self.__reqTimeOut) func(res.read()) except urllib2.HTTPError, e: print e.code # get请求 def get(self, func): request = self.__buildGetRequest() self.__handleResponse(request, func) # post请求 def post(self, postData, func): request = self.__buildPostPutDeleteRequest(postData=postData) self.__handleResponse(request, func) # put请求 def put(self, putData, func): request = self.__buildPostPutDeleteRequest(postData=putData) request.get_method = lambda: 'PUT' self.__handleResponse(request, func) # delete请求 def delete(self, putData, func): request = self.__buildPostPutDeleteRequest(postData=putData) request.get_method = lambda: 'DELETE' self.__handleResponse(request, func) 测试1234567891011121314def getData(data): print datahttpHelper = HttpHelper()url_baidu = 'http://www.baidu.com'#简单的get请求httpHelper.url(url=url_baidu).get(func=getData)# post请求httpHelper.debug() \ .url(url=url_post_pics) \ .headers(headers=getHeader()) \ .post(postData=post_data_pics, func=getData)# post请求httpHelper.debug().url(url_post_invite_one).headers(getHeader()).post(post_data_invite_one,getData)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac下AS快捷键]]></title>
      <url>%2F2015%2F08%2F05%2F%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%2FMac%E4%B8%8BAS%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
      <content type="text"><![CDATA[整理代码1alt + command + L 跳到某一行1command + L 重命名变量1Fn + shift + F6 提取为方法1alt + command + M 提取为全局变量1alt + command + F(field) 搜索文件1234搜索java文件command + O搜索所有文件shift + command + O 打开项目设置1234打开ProjectStructurecmd + ;(分号)打开settingscmd + ,(逗号) 文本 查找/替换12345678文件查找cmd + F项目内查找shift + cmd + F文件替换cmd + R项目内替换shift + cmd + R 运行项目123control + R运行 freelinefn + shift + cmd + F10 代码大小写转换1shift + cmd + u 列选中1alt + 鼠标]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TabLayout的使用详解]]></title>
      <url>%2F2015%2F06%2F23%2FAndroid%E5%BC%80%E5%8F%91%2FTabLayout%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[1. 前言 TabLayout是用来实现tab导航的控件，放在android.support.design.widget包里面，使用它可以很简单有很完美的结合ViewPager或者FragmentManager实现tab导航，并且实现与ViewPager的联动等功能。 本文主要介绍了： TabLayout的基本特性。 如何与ViewPager联动。 如何自定义TabLayout的显示。 2. 基本使用和常见属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;android.support.design.widget.TabLayout android:id="@+id/fragment_discover_tably" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt; 1. tabModeapp:tabMode="fixed|scrollable" tabMode属性有两个取值:fixed时，所有的tab会居中显示，是不可滑动的，scrollable时，所有的tab会靠左显示，当tab数量很多时，就会呈现滑动的效果，这对适配小屏幕手机至关重要。2. 导航条的高度和颜色app:tabIndicatorHeight="3dp"app:tabIndicatorColor="#af00"3. tab的宽度限制当文字很少时仍旧不会小于tabMinWidth当文字过多时，也不会将tab撑的超过tabMaxWidthapp:tabMaxWidth="150dp"app:tabMinWidth="60dp"4. tab被选中或没有被选中时的颜色app:tabTextColor="@color/black"app:tabSelectedTextColor="@color/colorPrimary"5. 更改Tab上面的TextView的详细显示app:tabTextAppearance="@style/TabLayoutStyle"&lt;style name="TabLayoutStyle" parent="TextAppearance.Design.Tab"&gt; &lt;item name="android:textSize"&gt;16sp&lt;/item&gt; &lt;item name="android:textStyle"&gt;normal&lt;/item&gt;&lt;/style&gt;6. 背景app:tabBackground="@color/transparent"设置tab的背景颜色，默认TabLayout点击时是有光晕效果的，使用该属性可以去掉光晕效果。7. tab间隔默认tab左右两边是有padding的，使用以下属性可以去掉padding，只使用tabPadding是没有效果的，要具体到设置到哪个padding app:tabPadding="0dp"app:tabPaddingBottom="0dp"app:tabPaddingEnd="0dp"app:tabPaddingStart="0dp"app:tabPaddingTop="0dp" 3. 与ViewPager联动使用方法tabLy.setupWithViewPager(viewPager);，就可以了，但是需要注意的是写ViewPager时需要实现getTitle()方法，用来设置tab的标题。原先给Tab设置的标题将会被覆盖掉。 4. 自定义Tab显示默认的TabLayout是可以显示文字和Icon的，定制度不是很高，有时候很难达到想要的效果，不过好在TabLayout开放了setCustomView(childView)这个API来支持我们自定义TabLayout的UI，当然自定义显示之后也损失了切换时颜色切换等效果，需要我们自己来处理，这边我模仿adapter的方式写了一个辅助类，用来更简单的实现自定义Tab显示时的显示和状态切换，源码很简单，主要是使用模板方法的方式，由 子类决定 并且 只关注 如何加载数据和更改状态显示的操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139/** * Describe : TabLayout适配器,快速实现TabLayout自定义View数据加载 * @author chendong */public abstract class BaseTabLayoutAdapter&lt;T&gt; &#123; private Context mContext; // 自定义布局layout文件 private int mResId; // 数据源 private List&lt;T&gt; mDatas; // 全部的控件，用来切换时改变显示 private List&lt;TabLayoutViewHolder&gt; mTabLayoutViewHolders; // tabLayout private TabLayout mTabLayout; // 简化的tab点击事件 private OnTabSelectListener&lt;T&gt; mOnTabSelectListener; /** * Tab选中的接口 * * @param &lt;T&gt; */ public interface OnTabSelectListener&lt;T&gt; &#123; void onSelect(int pos, T data); &#125; protected BaseTabLayoutAdapter(Context context, List&lt;T&gt; datas, int resId) &#123; mDatas = datas; mContext = context; mResId = resId; mTabLayoutViewHolders = new ArrayList&lt;&gt;(); &#125; public void attachTabLayout(TabLayout tabLayout) &#123; attachTabLayout(tabLayout, 0); &#125; private void attachTabLayout(TabLayout tabLayout, int posSelect) &#123; mTabLayout = tabLayout; // 设置导航条高度=0 tabLayout.setSelectedTabIndicatorHeight(0); tabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; int position = tab.getPosition(); updateStatus(mTabLayoutViewHolders.get(position), mDatas.get(position), true); if (mOnTabSelectListener != null) &#123; mOnTabSelectListener.onSelect(position, mDatas.get(position)); &#125; &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; updateStatus(mTabLayoutViewHolders.get(tab.getPosition()), mDatas.get(tab.getPosition()), false); &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; updateStatus(mTabLayoutViewHolders.get(tab.getPosition()), mDatas.get(tab.getPosition()), true); &#125; &#125;); // 初始化view,默认初始化为全部不选中 View childView; TabLayoutViewHolder holder; TabLayout.Tab tab; for (int i = 0; i &lt; mDatas.size(); i++) &#123; childView = LayoutInflater.from(mContext).inflate(mResId, tabLayout, false); holder = new TabLayoutViewHolder(childView); mTabLayoutViewHolders.add(holder); updateStatus(mTabLayoutViewHolders.get(i), mDatas.get(i), false); tab = tabLayout.newTab().setCustomView(childView); tabLayout.addTab(tab); &#125; // 选中初始化选中的那个 TabLayout.Tab tabAt = tabLayout.getTabAt(posSelect); if (tabAt != null) tabAt.select(); &#125; /** * 抽象方法，更新控件状态显示 * @param holder view holder * @param data 数据 * @param isSelect 是否选中 */ public abstract void updateStatus(TabLayoutViewHolder holder, T data, boolean isSelect); public void setOnTabSelectListener(OnTabSelectListener&lt;T&gt; onTabSelectListener) &#123; mOnTabSelectListener = onTabSelectListener; &#125; /** * 公共holder，用来存储和快速获取控件 */ public static class TabLayoutViewHolder &#123; private View parentView; private SparseArray&lt;View&gt; mCacheViews; public View getParentView() &#123; return parentView; &#125; TabLayoutViewHolder(View parentView) &#123; this.parentView = parentView; mCacheViews = new SparseArray&lt;&gt;(); &#125; public &lt;V extends View&gt; V getView(int resId) &#123; V v = (V) mCacheViews.get(resId); if (v == null) &#123; v = (V) parentView.findViewById(resId); if (v != null) &#123; mCacheViews.put(resId, v); &#125; &#125; return v; &#125; &#125;&#125;// 如何使用？BaseTabLayoutAdapter&lt;BeautifyToolTabData&gt; baseTabLayoutAdapter = new BaseTabLayoutAdapter&lt;ModelData&gt;(getContext(), tabDatas, R.layout.kiwi_item_beautify_tably) &#123; @Override public void updateStatus(TabLayoutViewHolder holder, ModelData data, boolean isSelect) &#123; holder.&lt;TextView&gt;getView(R.id.tv_title).setText(data.getTitle()); holder.&lt;ImageView&gt;getView(R.id.iv_icon).setImageResource(isSelect ? data.getSelectRes() : data.getUnSelectRes()); &#125; &#125;;baseTabLayoutAdapter.setOnTabSelectListener(new BaseTabLayoutAdapter.OnTabSelectListener&lt;ModelData&gt;() &#123; @Override public void onSelect(int pos, ModelData data) &#123; // 选中事件 &#125; &#125;);baseTabLayoutAdapter.attachTabLayout(mTabLayout);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用传统Android组件实现高效数据加载]]></title>
      <url>%2F2015%2F05%2F14%2FAndroid%E5%BC%80%E5%8F%91%2FAndroid%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD(ContentProvider_Loader_Sqlite)%2F</url>
      <content type="text"><![CDATA[前言 本文主要介绍使用ContentProvider + Sqlite + Loader等Android的基本组件实现高内聚低耦合的数据加载的数据设计模式，这是一种传统而高效的数据加载，熟悉这种模式同时也是对ContentProvider的更好掌握。 优势 ContentProvider可以非常简单的调整数据源而不影响其他程序。外部程序不关心数据，只关心返回的Cursor.举个例子，ContentProvider指向的数据库可以随时改变不会影响使用者，同时ContentProvider也可以返回网络数据，使用者只要求结果是Cursor,但是对于数据来自哪里并不关心，这样就实现了数据读取和使用的分离。 提供数据安全保护与权限管理，ContentProvider使用授权机制，对数据在方便访问的同时进行了很好地保护。 强大的API支持，Google官方提供了强大的API. ##Loader特点： 与Activity管理同步，与Activity/Fragment生命周期同步，创建与销毁都会受到Activity/Fragment生命周期的管理。这就意味着我们不需要再去考虑何时去加载数据，使用Loader之后会结合Activity或者Fragment的生命周期自行进行加载和更新。 内部线程异步加载，我们也就不需要再去开启线程获取数据解析数据，大大减少了代码量。 数据源发生改变时实时更新，貌似我们自己的数据数据是无法自动更新的，不过不要紧，只需要一行简单的reStartLoader就可以手动重新加载一下。 数据分层 Loader 写操作 ContentProvider SQLite 定义关系类 定义一个关系类，声明表结构,Uri,授权 1234567891011121314151617181920212223242526public class WebContract &#123; public static final String Tb_History = &quot;tb_history&quot;; public static final String Tb_BookMark = &quot;tb_bookmark&quot;; public static final String Authority = &quot;com.march.db_browser&quot;; public static class History implements BaseColumns &#123; //content://com.march.db_browser/tb_history public static final Uri ContentUri = Uri.parse( &quot;content://&quot; + Authority).buildUpon().appendPath(Tb_History).build(); public static final String Link = &quot;link&quot;; public static final String Icon = &quot;icon&quot;; public static final String Title = &quot;title&quot;; public static final String Time = &quot;time&quot;; &#125; public static class BookMark implements BaseColumns &#123; //content://com.march.db_browser/tb_history public static final Uri ContentUri = Uri.parse( &quot;content://&quot; + Authority).buildUpon().appendPath(Tb_BookMark).build(); public static final String Link = &quot;link&quot;; public static final String Icon = &quot;icon&quot;; public static final String Title = &quot;title&quot;; public static final String Time = &quot;time&quot;; &#125;&#125; 继承ContentProvider 实现数据提供者，设定好Code作为表资源的唯一标示，使用UriMacher匹配 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class WebContentProvider extends ContentProvider &#123;/*为可以访问的数据库表资源定义代号，区分哪个表可以被访问*/private static final int CODE_BOOKMARK = 0x1;private static final int CODE_HISTORY = 0x2;/*使用UriMacher生成访问的Uri*/private static UriMatcher uriMatcher;/*使用静态代码块初始化UriMacher,添加*/static &#123;uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);uriMatcher.addURI(WebContract.Authority, WebContract.Tb_BookMark, CODE_BOOKMARK);uriMatcher.addURI(WebContract.Authority, WebContract.Tb_History, CODE_HISTORY);&#125;private MySqliteOpenHelper mySqliteOpenHelper;private SQLiteDatabase db;@Overridepublic boolean onCreate() &#123;mySqliteOpenHelper = new MySqliteOpenHelper(getContext(), "db_browser", 1);return false;&#125;@Overridepublic Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123;Cursor cursor = null;if (uri != null) &#123;int code = uriMatcher.match(uri);db = mySqliteOpenHelper.getWritableDatabase();switch (code) &#123;case CODE_BOOKMARK:cursor = db.query(WebContract.Tb_BookMark, null, null, null, null, null, null);break;case CODE_HISTORY:cursor = db.query(WebContract.Tb_History, null, null, null, null, null, null);break;&#125;&#125;if (cursor == null) &#123;Log.i("chendong", "cursor is null");&#125; // db.close();//读操作不能关闭连接，写操作需要关闭连接return cursor;&#125;@Overridepublic String getType(Uri uri) &#123;return null;&#125;@Overridepublic Uri insert(Uri uri, ContentValues values) &#123;Uri uri_return = null;if (uri != null) &#123;int code = uriMatcher.match(uri);db = mySqliteOpenHelper.getWritableDatabase();long id = -1;switch (code) &#123;case CODE_BOOKMARK:id = db.insert(WebContract.Tb_BookMark, null, values);break;case CODE_HISTORY:id = db.insert(WebContract.Tb_History, null, values);break;&#125;if (id != -1) &#123;uri_return = ContentUris.withAppendedId(uri, id);&#125;db.close();&#125;return uri_return;&#125;@Overridepublic int delete(Uri uri, String selection, String[] selectionArgs) &#123;// Implement this to handle requests to delete one or more rows.throw new UnsupportedOperationException("Not yet implemented");&#125;@Overridepublic int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123;// TODO: Implement this to handle requests to update one or more rows.throw new UnsupportedOperationException("Not yet implemented");&#125;&#125; 使用Loader加载数据``` adapter = new SimpleCursorAdapter(this, R.layout.item_listview, null, new String[]{WebContract.History.Title, WebContract.History.Link}, new int[]{R.id.item_listview_title, R.id.item_listview_url}, SimpleCursorAdapter.FLAG_REGISTER_CONTENT_OBSERVER); listView.setAdapter(adapter); getLoaderManager().initLoader(0x123, bundle, this); //这是实现的 implements LoaderManager.LoaderCallbacks&lt;Cursor&gt; 的方法 @Override public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) { int action = args.getInt(&quot;action&quot;); CursorLoader cursorLoader = null; Log.i(&quot;chendong&quot;, &quot;action is &quot; + action); if (action == 0) { //history cursorLoader = new CursorLoader(this, WebContract.History.ContentUri, null, null, null, null); } else { cursorLoader = new CursorLoader(this, WebContract.BookMark.ContentUri, null, null, null, null); } return cursorLoader; } @Override public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor data) { Log.i(&quot;chendong&quot;, &quot;get data &quot;); adapter.changeCursor(data); } @Override public void onLoaderReset(Loader&lt;Cursor&gt; loader) { } 使用 getLoaderManager().restartLoader(0x123, bundle, this); 重新加载数据]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android编码解码及其原理]]></title>
      <url>%2F2015%2F05%2F11%2FAndroid%E5%BC%80%E5%8F%91%2FAndroid%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[前言 本文用到ASCII表，Base64对照表请自行百度。 概念：编码解码就是使用特定的算法，将数据进行处理，形成数据的另外一种表现形式，编码后的数据可以使用解码算法还原出原始数据。 Base64简介 Base64算法可以将任意的字节数组数据通过算法生成只有（英文大小写，数字，+，/）共64种字符的字符串数据；相当于将任意内容转换为可见字符串表示。 也就是将不可见的数据转换为ASCII码数据，便于在Json和Xml中传递。 Base64Api1234567891011121314//将字节数组编码，返回为StringBase64.encodeToString(byte[] bs,int flag);//将字节数组编码，返回字节数组Base64.encode(byte[] bs,int flag);//将字节数组按指定位置部分编码，返回字符串Base64.encodeToString(byte[] bs,int offset,int lenth);//将字节数组按指定位置部分编码，返回字节数组Base64.encode(byte[] bs,int offset,int lenth);//将编码后的字符串解码返回字节数组Base64.decode(String str,int flag);//将编码后的字节数组解码返回字节数组Base64.decode(byte[],int flag);//将编码后的字节数组按指定位置部分解码，返回字节数组Base64.decode(byte[] bs,int offset,int len); flag常量1234567891011Base64.CRLF 这个参数意思是Win风格的换行符，意思就是使用CR LF这一对作为一行的结尾而不是Unix风格的LFBase64.DEFAULT 这个参数是默认，使用默认的方法来加密Base64.NO_PADDING 这个参数是略去加密字符串最后的”=”Base64.NO_WRAP 这个参数意思是略去所有的换行符（设置后CRLF就没用了）Base64.URL_SAFE 这个参数意思是加密时不使用对URL和文件名有特殊意义的字符来作为加密字符，具体就是以-和_取代+和///习惯上使用Base64.NO_WRAP，使用什么方式编码就需要使用什么方式解码。 Base64原理 Base64在编码时按照三个字节一组分组， 进行处理，每三个字节在编码之后被转换为4个字符。 每个字节有8个bit(也必须是要求有8bit，所以中文是不可以的),三个字节就有24个bit. 但是我们只有64 种字符选择，也就是Base64的字符最多只能用6bit来表示，再大就会超出64的范围，所以编码以后显示的字符开始两位是0. 那么原先24bit的数据要显示在现在每个字符只有6bit的表示方法上，很明显需要4个字符（3*8 == 4*6） 当数据长度在无法满足3的倍数的时候会在末尾添加“=“具体的转换方法直接说可能有点抽象， 字符串Base64编码过程 字符串String str = &quot;0Aa&quot;;首先，原先每个字符是2个字节16bit,对于英文来说前8个bit是0，也就是只有8个bit,现在是3个字符，3*8=24个bit需要显示。 转换 get 0 A a ASCII 48 65 97 二进制表示 00110000 01000001 01100001 现在拼凑成是这样的二进制串( 001100 000100 000101 100001)，将其转化为Base64可以显示的模式，需要每次取6位作为一个Base64字符,前两位补0 get 1 2 3 4 开始 001100 000100 000101 100001 转化 00001100 00000100 00000101 00100001 转为10进制 12 4 5 33 Base64字符 M E F h 二进制数组编码过程 这个例子已经很清晰的解释了Base64的编码过程，网上有人自己实现了Base64编码的类，android源码也不难，这是编码字符串看起来还是比较清晰的，我们也可以更本质一点 byte[] bs = new byte[]{1,10,20};这是一个byte数组，复习一下，1个byte是8个bit,可以表示的范围0-127之间，我们在调用Base64的函数时，本质也是在操作字节数组，同样的原理 byte 1 10 20 二进制表示 00000001 00001010 00010100 6位一组，二进制串000000 010000 101000 010100 get 1 2 3 4 开始 000000 010000 101000 010100 转化 00000000 00010000 00101000 00010100 转为10进制 0 16 40 20 Base64字符 A Q o U Hex编码简介 Hex就是16进制，本质上是将字节数组转化为16进制，然后用字符串的形式表现出来，我们知道16进制的取值范围就是在0-f之间，这样就可以将无法显示的字节数组数据显示出来。 原理方面比起Base64就简单很多了，一个8bit的数据，也就是（xxxx xxxx）,每4个bit可以转化为一个16进制表示，也就是8个bit会转化为（00-ff）之间的16进制数字。 Hex编码实现12345678910111213141516171819202122232425262728293031323334/** * 字节数组转换为字符串 * 一个字节形成两个字符，是原来数据长度的两倍 * * @param data * @return */ public static String toHex(byte[] data) &#123; String ret = null; //todo 将字节数组转换为字符串 if (data != null &amp;&amp; data.length &gt; 0) &#123; StringBuilder sb = new StringBuilder(); for (byte b : data) &#123; //分别获取高四位和低四位转换为字符 int h = (b &gt;&gt; 4) &amp; 0x0f; int l = b &amp; 0x0f; char ch, cl; if (h &gt; 9) &#123;//0x0a~0x0f ch = (char) ('A' + (h - 10)); &#125; else &#123;//0~9 ch = (char) ('0' + h); &#125; if (l &gt; 9) &#123;//0x0a~0x0f cl = (char) ('A' + (l - 10)); &#125; else &#123;//0~9 cl = (char) ('0' + l); &#125; sb.append(ch).append(cl); &#125; ret = sb.toString(); &#125; return ret; &#125; Hex编码原理分析 简单说一下，&amp;运算，两者都为1结果才是1，b&gt;&gt;4&amp;0xf取出高四位，b&amp;0x0f取出低四位，举个例子： 字节是 b = 1010 1111 b&gt;&gt;4 b = 00001010 b&gt;&gt;4&amp;0x0f 也就是 00001010&amp;00001111 —-&gt; 1010高四位取出来了，取得低四位原理一样。后面的操作就是根据数据的大小转换一下格式，因为拿到的数据是十进制的那么范围会在0-15之间，需要转换为16进制的0-f. Hex解码实现12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 将编码字符串解码为字节数组 * * @param data * @return */ public static byte[] fromHex(String data) &#123; byte[] ret = null; //todo 将字符串转换为字节数组 if (data != null) &#123; int len = data.length(); char[] chs = data.toCharArray(); ret = new byte[len/2]; int ih = 0,il=0,v=0,j=0; if (len &gt; 0 &amp;&amp; len % 2 == 0) &#123; for (int i = 0; i &lt; len - 1; i += 2,j++) &#123; char ch = chs[i]; char cl = chs[i+1]; if(ch&gt;=&apos;A&apos;&amp;&amp;ch&lt;=&apos;F&apos;)&#123; ih = 10 + (ch - &apos;A&apos;); &#125;else if(ch &gt;=&apos;a&apos;&amp;&amp;ch&lt;=&apos;f&apos;)&#123; ih = 10 + (ch - &apos;a&apos;); &#125;else if(ch&gt;&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123; ih = ch - &apos;0&apos;; &#125; if(cl&gt;=&apos;A&apos;)&#123; il = 10 + (cl - &apos;A&apos;); &#125;else if(cl &gt;=&apos;a&apos;)&#123; il = 10 + (cl - &apos;a&apos;); &#125;else if(cl&gt;&apos;0&apos;)&#123; il = cl - &apos;0&apos;; &#125; v = ((ih&amp;0x0f)&lt;&lt;4)|(il&amp;0x0f); ret[j] = (byte)v; &#125; &#125; &#125; return ret; &#125; Hex解码原理分析 相当于编码的逆运算，根据字符串每次取两位，转换成int，在进行移位将其拼成一个字节，怎么拼的？v = ((ih&amp;0x0f)&lt;&lt;4)|(il&amp;0x0f); 这一句，假设我们获得的字符串最后转化结果是10和5，也就是1010，0101。10&lt;&lt;4,结果是10100000，然后10100000 | 0101，|运算只要有1则为1，结果是10100101就完成了拼接工作。 总结 Base64和Hex是比较常见的编码方式，对比一下，Base64每3个字节转化为4个字节，每个字节浪费2bit,Hex编码，每个字节转化为两个字节，每个字节浪费4bit,所以说Base64更加节省空间，而且用起来简单得多。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习之安装WingIDE并破解]]></title>
      <url>%2F2015%2F05%2F05%2F%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%2FAndroid%E5%8A%A0%E5%BF%AB%E7%BC%96%E8%AF%91Freeline%2F</url>
      <content type="text"><![CDATA[buildscript { repositories { jcenter() maven { url “https://jitpack.io“ } maven { url “https://dl.bintray.com/chendongmarch/maven“ } } dependencies { classpath ‘com.android.tools.build:gradle:2.2.2’ classpath ‘com.antfortune.freeline:gradle:0.8.1’ // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files }} apply plugin: ‘com.antfortune.freeline’//阿里增量编译 freeline { hack true productFlavor ‘babyphoto’ applicationProxy false }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习之安装WingIDE并破解]]></title>
      <url>%2F2015%2F05%2F05%2F%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%2FPython%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%89%E8%A3%85WingIDE%E5%B9%B6%E7%A0%B4%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[相关下载 jar文件下载 破解使用 打开目录D:\package\Wing IDE 5.1\Wing IDE 5.1\bin\2.7下面有一个src.zip,使用我上传的zip包替换即可，亲测可用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android设计MetrailDesign]]></title>
      <url>%2F2015%2F03%2F09%2FAndroid%E5%BC%80%E5%8F%91%2FAndroid%E6%96%B0%E8%AE%BE%E8%AE%A1MetrailDesign%2F</url>
      <content type="text"><![CDATA[Theme123456789101112131415161718&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt;&lt;!--导航栏底色--&gt;&lt;item name="colorPrimary"&gt;@color/accent_material_dark&lt;/item&gt;&lt;!--状态栏底色--&gt;&lt;item name="colorPrimaryDark"&gt;@color/accent_material_light&lt;/item&gt;&lt;!--导航栏上的标题颜色--&gt;&lt;item name="android:textColorPrimary"&gt;@android:color/black&lt;/item&gt;&lt;!--Activity窗口的颜色--&gt;&lt;item name="android:windowBackground"&gt;@color/white&lt;/item&gt;&lt;!--按钮选中或者点击获得焦点后的颜色--&gt;&lt;item name="colorAccent"&gt;@color/accent_material_light&lt;/item&gt;&lt;!--和 colorAccent相反，正常状态下按钮的颜色,所有控价在没有获得焦点时的颜色--&gt;&lt;item name="colorControlNormal"&gt;#ff0000&lt;/item&gt;&lt;!--Button按钮正常状态颜色--&gt;&lt;item name="colorButtonNormal"&gt;@color/accent_material_light&lt;/item&gt;&lt;!--EditText 输入框中字体的颜色--&gt;&lt;item name="editTextColor"&gt;@android:color/white&lt;/item&gt;&lt;/style&gt; ##TextInputLayout XML文件123456789101112&lt;android.support.design.widget.TextInputLayout android:id="@+id/md_textinputlayout" android:layout_width="match_parent" android:layout_height="wrap_content" &gt; &lt;EditText android:id="@+id/md_edittext" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="请输入文本" /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; 代码显示错误信息,文本颜色的需要使用Theme修改1234567891011TextInputLayout tily1=(TextInputLayout) findViewById(R.id.tily1);tily1.setHint("新的Hint");tily1.getEditText().addTextChangedListener(new TextWatcher()); //在监听之中进行如下设置可以显示错误信息int num = 0;if (((num = s.toString().length()) &lt; 6) &amp;&amp; num != 0) &#123; textInputLayout.setErrorEnabled(true); textInputLayout.setError("长度不能小于6");&#125; else &#123; textInputLayout.setErrorEnabled(false);&#125; SnackBar代码1234567891011121314Snackbar snackbar = Snackbar.make(view, "SnackBar测试", Snackbar.LENGTH_SHORT) //点击事件中按钮的颜色 .setActionTextColor(Color.WHITE) //设置点击事件 .setAction("SnackBar", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.i("chendong", "点击了action"); &#125; &#125;);//修改背景颜色snackbar.getView().setBackgroundColor(Color.GRAY);snackbar.show();&#125; FloatingActionButton123456789101112&lt;android.support.design.widget.FloatingActionButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/ic_launcher" android:layout_alignParentRight="true" android:layout_alignParentBottom="true" android:layout_margin="10dp" android:onClick="ClickFloatButton" app:fabSize="normal" app:backgroundTint="#f00" app:elevation="5dp" /&gt; 属性 //上面的文件使用相对布局，可以使用相对锚点的设置定位fab app:layout_anchor=”@id/md_recyclerview”//锚点，基于哪个控件定位 app:layout_anchorGravity=”bottom|right|end”//相对锚点的位置 app:fabSize=”normal”//控件大小，只支持两种大小，mini,normal app:backgroundTint=”#f00”//改变背景颜色，不设置好像是黑的还是跟随主题 app:elevation=”5dp”//阴影12345678910111213141516171819202122232425## AppBarLayout - AppBarLayout本身是一个垂直的LinearLayout，被他包裹的控件将作为ActionBar展示```xml&lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt;&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/md_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:minHeight=&quot;?attr/actionBarSize&quot; android:background=&quot;?attr/colorPrimary&quot; android:layout_marginBottom=&quot;20dp&quot;&gt;&lt;/android.support.v7.widget.Toolbar&gt;&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:padding=&quot;10dp&quot; android:text=&quot;这是appbarlayout测试&quot; android:gravity=&quot;center_horizontal&quot; android:textSize=&quot;20sp&quot;/&gt;&lt;/android.support.design.widget.AppBarLayout&gt; CoordinatorLayout 这个（Coordinator）单词的意思是协调器，它是协调控件之间动画效果的一个布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;android.support.design.widget.CoordinatorLayoutxmlns:android="http://schemas.android.com/apk/res/android"xmlns:tools="http://schemas.android.com/tools"xmlns:app="http://schemas.android.com/apk/res-auto"android:layout_width="match_parent"android:layout_height="match_parent"tools:context="com.awesome.newfeatures.SecondActivity"&gt;&lt;android.support.design.widget.AppBarLayoutandroid:layout_width="match_parent"android:layout_height="wrap_content"&gt;&lt;android.support.v7.widget.Toolbarandroid:id="@+id/md_toolbar"android:layout_width="match_parent"android:layout_height="?attr/actionBarSize"android:minHeight="50dp"android:background="?attr/colorPrimary"android:layout_marginBottom="20dp" app:layout_scrollFlags="scroll|enterAlways"/&gt;&lt;android.support.design.widget.TabLayoutandroid:id="@+id/md_tablayout"android:layout_width="match_parent"android:layout_height="wrap_content"app:tabGravity="fill"app:tabTextColor="#f00"app:tabIndicatorColor="#00f"app:tabMode="fixed"app:tabIndicatorHeight="2dp"/&gt;&lt;/android.support.design.widget.AppBarLayout&gt;&lt;android.support.v7.widget.RecyclerViewandroid:id="@+id/md_recyclerview"android:layout_width="match_parent"android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior"/&gt;&lt;android.support.design.widget.FloatingActionButtonandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:src="@mipmap/ic_launcher"app:backgroundTint="#00f"app:elevation="5dp"android:layout_margin="16dp"app:layout_anchor="@id/md_recyclerview"app:layout_anchorGravity="bottom|right|end"android:onClick="Click"/&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; app:layout_behavior=”@string/appbar_scrolling_view_behavior”//在视图中可滑动的组件使用该属性标示，必须是RecyclerView或NestedScrollView 试验表明，开始使用后面两个属性并没起作用，后来发现需要固定toolbar高度才会起作用。 FloatingActionButton被包裹在CoordinatorLayout中时可以防止SnackBar跳出时遮挡Fab app:layout_scrollFlags=”scroll|enterAlways”//三种取值 属性选择 描述 scroll 所有需要滑动的视图需要定义该属性，不使用该属性的视图将会固定在屏幕顶端this flag should be set for all views that want to scroll off the screen - for views that do not use this flag, they’ll remain pinned to the top of the screen enterAlways 任意向下的操作会导致隐藏视图显示出来this flag ensures that any downward scroll will cause this view to become visible, enabling the ‘quick return’ pattern enterAlwaysCollapsed 这个flag定义的是何时进入（已经消失之后何时再次显示）。假设你定义了一个最小高度（minHeight）同时enterAlways也定义了，那么view将在到达这个最小高度的时候开始显示，并且从这个时候开始慢慢展开，当滚动到顶部的时候展开完。When your view has declared a minHeight and you use this flag, your View will only enter at its minimum height (i.e., ‘collapsed’), only re-expanding to its full height when the scrolling view has reached it’s top. exitUntilCollapsed 这个flag时定义何时退出，当你定义了一个minHeight，这个view将在滚动到达这个最小高度的时候消失。 this flag causes the view to scroll off until it is ‘collapsed’ (its minHeight) before exiting CollapsingToolbarLayout 使用CollapsingToolbarLayout结合CoordinatorLayout实现可缩放的ActionBar,在使用CoordinatorLayout一直实现不了列表滑动到顶端才显示的效果，使用CollapsingToolbarLayout可以实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;android.support.design.widget.CoordinatorLayoutxmlns:android="http://schemas.android.com/apk/res/android"xmlns:tools="http://schemas.android.com/tools"xmlns:app="http://schemas.android.com/apk/res-auto"android:layout_width="match_parent"android:layout_height="match_parent"tools:context="com.awesome.newfeatures.SecondActivity"&gt; //需要固定高度&lt;android.support.design.widget.AppBarLayoutandroid:id="@+id/appbar"android:layout_width="match_parent"android:layout_height="160dp"&gt;&lt;android.support.design.widget.CollapsingToolbarLayoutandroid:layout_width="match_parent"android:layout_height="match_parent"app:contentScrim="?attr/colorPrimary"app:layout_scrollFlags="scroll|exitUntilCollapsed"&gt;&lt;ImageViewandroid:id="@+id/backdrop"android:layout_width="match_parent"android:layout_height="match_parent"android:scaleType="centerCrop"android:src="@mipmap/ic_launcher"app:layout_collapseMode="parallax"/&gt;&lt;android.support.v7.widget.Toolbarandroid:id="@+id/md_toolbar"android:layout_width="match_parent"android:layout_height="?attr/actionBarSize"app:layout_collapseMode="pin"/&gt;&lt;/android.support.design.widget.CollapsingToolbarLayout&gt;&lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerViewandroid:id="@+id/md_recyclerview"android:layout_width="match_parent"android:layout_height="wrap_content"app:layout_behavior="@string/appbar_scrolling_view_behavior"/&gt; &lt;android.support.design.widget.FloatingActionButtonandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:src="@mipmap/ic_launcher"app:backgroundTint="#00f"app:elevation="5dp"android:layout_margin="16dp"app:layout_anchor="@id/md_recyclerview"app:layout_anchorGravity="bottom|right|end"android:onClick="Click"/&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; AppBarLayout高度需要固定 CollapsingToolbarLayout设置app:layout_scrollFlags 1234567- 23.1.0以后新增一个snap可以在拉动到底部时产生缩放效果- app:layout_scrollFlags=&quot;scroll|enterAlways&quot;- app:layout_scrollFlags=&quot;scroll|enterAlwaysCollapsed&quot;- 不论ToolBar是否设置pin模式，将会全部滚出屏幕，任意下拉动画会使隐藏的视图显示出来- app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;- //设置为pin模式的固定在顶端，下拉到顶部才显示出隐藏视图- app:layout_collapseMode=&quot;parallax&quot;//需要固定的视图使用pin模式，需要滑动的视图使用parallax模式 一些属性setTitle(CharSequence)//设置固定在顶端时显示的titlesetContentScrim(Drawable)app:contentScrim=”?attr/colorPrimary”//修改固定在顶端的背景颜色setStatusBarScrim(Drawable)//状态栏背景，5.0以上有效app:layout_collapseParallaxMultiplier=”0.6”//滑动的视觉差，产生的效果是提前将折叠的视图隐藏掉了app:layout_collapseMode=”parallax|pin”//滑动模式，缩放或者固定collapsingToolbarLayout.setTitle(&quot;title&quot;);//设置标题，将会自动进行缩放//设置颜色后将会自动进行颜色过渡collapsingToolbarLayout.setExpandedTitleColor(Color.WHITE);collapsingToolbarLayout.setCollapsedTitleTextColor(Color.GREEN); DrawerLayout+NavigationView 结合之前学的总结在一个布局中，首先DrawerLayout需要有两个子view，上面的一个代表content,下面的NavigationView代表菜单导航，当然你可以替换成自己的布局，用来做其他的事情。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 &lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/md_DrawerLayout" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true" tools:context=".MainActivity" &gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_width="match_parent" android:layout_height="wrap_content" &gt; &lt;android.support.design.widget.AppBarLayout android:id="@+id/appbar" android:layout_width="match_parent" android:layout_height="160dp" &gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id="@+id/md_CollapsingToolbarLayout" android:layout_width="match_parent" android:layout_height="match_parent" app:contentScrim="?attr/colorPrimary" app:layout_scrollFlags="scroll|exitUntilCollapsed" &gt; &lt;ImageView android:id="@+id/backdrop" android:layout_width="match_parent" android:layout_height="match_parent" android:scaleType="centerCrop" android:src="@mipmap/ic_launcher" app:layout_collapseMode="parallax" app:layout_collapseParallaxMultiplier="0.3" /&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/md_toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" app:layout_collapseMode="pin" /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/md_recyclerview" android:layout_width="match_parent" android:layout_height="wrap_content"app:layout_behavior="@string/appbar_scrolling_view_behavior" /&gt; &lt;android.support.design.widget.FloatingActionButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/ic_launcher" app:backgroundTint="#00f" app:elevation="5dp" android:layout_margin="16dp" app:layout_anchor="@id/md_recyclerview" app:layout_anchorGravity="bottom|right|end" android:onClick="Click" /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; &lt;android.support.design.widget.NavigationView android:id="@+id/md_NavigationView" android:layout_width="wrap_content" android:layout_height="match_parent" android:layout_gravity="start" app:headerLayout="@layout/header" app:menu="@menu/drawer" /&gt; &lt;/android.support.v4.widget.DrawerLayout&gt; 几个属性1234567891011121314关于NavigationView中item的字体颜色和icon选中状态颜色是去当前主题theme中的&lt;--正常状态下字体颜色和icon颜色--&gt;&lt;item name=&quot;android:textColorPrimary&quot;&gt;@android:color/darker_gray&lt;/item&gt;&lt;--选中状态icon的颜色和字体颜色--&gt;&lt;item name=&quot;colorPrimary&quot;&gt;@color/accent_material_light&lt;/item&gt;当然你可以通过如下方法或者属性来改变这一状态：setItemBackgroundResource(int)app:itemBackground`//给menu设置背景资源setItemIconTintList(ColorStateList)app:itemIconTint`//给menu的icon设置颜色，对应的属性setItemTextColor(ColorStateList)app:itemTextColor`//给menu的item设置字体颜色，对应的属性app:headerLayout=&quot;@layout/header&quot;//NavigationView的头部布局app:menu=&quot;@menu/drawer&quot;`//NavigationView的菜单文件 代码12345678910111213141516171819mDrawerLayout = (DrawerLayout) findViewById(R.id.md_DrawerLayout);//这个组件将会展示一个图标在左上角，它是一个DrawerListener的子类，使用它可以简单地创建一个抽屉的控制图标，v4包下的该组件可以设置导航图标，但是已经过时，这里使用v7包下的组件，但是没有了设置图标的参数，如果想自定义可以使用自定义的图标，在实现DrawerListener时做处理ActionBarDrawerToggle mDrawerToggle = new ActionBarDrawerToggle(this, mDrawerLayout, toolbar, R.string.close, R.string.open);//没有找到合适的方法修改图标，这个方法没有效果 mDrawerToggle.setHomeAsUpIndicator(R.mipmap.ic_launcher); //初始化状态 mDrawerToggle.syncState(); mDrawerLayout.setDrawerListener(mDrawerToggle); //设置导航栏NavigationView的点击事件 final NavigationView mNavigationView = (NavigationView) findViewById(R.id.md_NavigationView); mNavigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(MenuItem menuItem) &#123; //使用该方法可以选中Item，但是出现了一个问题，点击时有时会造成选中无法取消，试过一个解决办法是获得Menu的所有Item设置不选中可以解决这个问题。 menuItem.setChecked(true); mDrawerLayout.closeDrawers();//关闭抽屉 return true; &#125; &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android V7V4包新控件]]></title>
      <url>%2F2015%2F03%2F03%2FAndroid%E5%BC%80%E5%8F%91%2FAndroid%E6%96%B0%E6%8E%A7%E4%BB%B6V4V7%2F</url>
      <content type="text"><![CDATA[AlertDialogv7风格的Dialog相对原来的版本去掉了跳跃弹出的动画，下方按钮去掉了边框，聚集在了右侧，显示时去掉了分隔线。 ToolBar取代原先的ActionBar实现相对完美的定制 xml文件12345678&lt;android.support.v7.widget.Toolbarandroid:id="@+id/md_toolbar"android:layout_width="match_parent"android:layout_height="?attr/actionBarSize"android:minHeight="50dp"android:background="?attr/colorPrimary"android:layout_marginBottom="20dp" &gt; 代码123456789101112131415161718192021 //隐藏系统默认title,我当时修改了theme用的noactionbar的Theme所以这行代码并没用getSupportActionBar().setDisplayShowTitleEnabled(false);Toolbar toolbar = (Toolbar) findViewById(R.id.md_toolbar);//标题toolbar.setTitle("测试");//副标题，显示在标题下方toolbar.setSubtitle("副标题");//logo,显示在标题左侧toolbar.setLogo(R.mipmap.ic_launcher); //导航图标，显示在最左侧，可以使用该图标调出菜单toolbar.setNavigationIcon(android.R.drawable.ic_input_delete);//这个并没有用，设置菜单时重写onCreateOptionMenu即可//toolbar.inflateMenu(R.menu.menu_main);setSupportActionBar(toolbar);toolbar.setOnMenuItemClickListener(new OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem item) &#123;Toast.makeText(MainActivity.this, "点击了" + item.getItemId(), Toast.LENGTH_SHORT).show(); return false; &#125;&#125;); 题外话,如何创建菜单项12345678910111213141516171819202122232425262728293031323334//重写该方法，菜单将会显示在toobar上@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.menu_main, menu); //获取toolbar上的菜单view,也可以在上面的setOnMenuItemClickListener实现更加简单，这里只是一个演示。 MenuItem item = menu.findItem(R.id.action_share); //强转为你需要的view View actionView = item.getActionView(); return super.onCreateOptionsMenu(menu);&#125;//菜单文件，为没有接触过的小伙伴准备的额,相关属性请自行查文档//res/menu/menu_main.xml&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;xmlns:tools=&quot;http://schemas.android.com/tools&quot;tools:context=&quot;.MainActivity&quot;&gt;&lt;itemandroid:id=&quot;@+id/ab_search&quot;android:orderInCategory=&quot;80&quot;android:title=&quot;action_search&quot; app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot;/&gt;&lt;itemandroid:id=&quot;@+id/action_share&quot;android:orderInCategory=&quot;90&quot;android:title=&quot;action_share&quot; app:actionProviderClass=&quot;android.support.v7.widget.ShareActionProvider&quot;app:showAsAction=&quot;ifRoom&quot;/&gt;&lt;itemandroid:id=&quot;@+id/action_settings&quot;android:orderInCategory=&quot;100&quot;android:title=&quot;action_settings&quot;app:showAsAction=&quot;never&quot;/&gt;&lt;/menu&gt; LinearLayoutCompat 在控件中间添加分隔线 1234567891011&lt;android.support.v7.widget.LinearLayoutCompatandroid:layout_width="match_parent"android:layout_height="wrap_content"android:layout_gravity="center|center_horizontal"android:orientation="vertical"app:divider="@drawable/line"app:dividerPadding="4dp"app:showDividers="middle"&gt;.....&lt;/android.support.v7.widget.LinearLayoutCompat&gt; app:divider=”@drawable/line” 给分隔线设置颜色，这里你需要在drawable在定义shape资源，否则将没有效果。 app:dividerPadding=”25dp” 给分隔线设置距离左右边距的距离。 app:showDividers=”middle|beginning|end” 分隔线显示的位置，有四种参数值：middle 每个item之间，beginning最顶端显示分隔线，end 最底端显示分隔线，none不显示间隔线。 ListPopupWindow123456789101112131415161718192021222324public void showListPopup(View view) &#123; String items[] = &#123;"item1", "item2", "item3", "item4", "item5"&#125;; final ListPopupWindow listPopupWindow = new ListPopupWindow(this); //设置ListView类型的适配器 listPopupWindow.setAdapter(new ArrayAdapter&lt;String&gt;(SwipeRefreshActivity.this, android.R.layout.simple_list_item_1, items)); //给每个item设置监听事件 listPopupWindow.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; Toast.makeText(SwipeRefreshActivity.this, "the position is" + position, Toast.LENGTH_SHORT).show(); //listPopupWindow.dismiss(); &#125; &#125;); //设置ListPopupWindow的锚点,也就是弹出框的位置是相对当前参数View的位置来显示， listPopupWindow.setAnchorView(view); //ListPopupWindow 距锚点的距离，也就是相对锚点View的位置 listPopupWindow.setHorizontalOffset(100); listPopupWindow.setVerticalOffset(100); //设置对话框的宽高 listPopupWindow.setWidth(300); listPopupWindow.setHeight(600); listPopupWindow.setModal(false); listPopupWindow.show(); &#125; PopupMenu12345678910111213141516public void showPopupMenu(View view) &#123;//参数View 是设置当前菜单显示的相对于View组件位置，具体位置系统会处理PopupMenu popupMenu = new PopupMenu(this, view);//加载menu布局popupMenu.getMenuInflater().inflate(R.menu.menu_main, popupMenu.getMenu());//设置menu中的item点击事件popupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() &#123;@Overridepublic boolean onMenuItemClick(MenuItem item) &#123;return false;&#125;&#125;);//设置popupWindow消失的点击事件popupMenu.setOnDismissListener(this);popupMenu.show();&#125; 新风格Spinner12345&lt;Spinner android:id="@+id/spinner" style="@android:style/Widget.Holo.Light.Spinner" android:layout_width="wrap_content" android:layout_height="wrap_content"&gt;&lt;/Spinner&gt; v4 SwipeRefreshLayout SwipeRefreshLayout继承自ViewGroup,理论上可以完成任何View的刷新 代码12345678final SwipeRefreshLayout swipeRefreshLayout = (SwipeRefreshLayout) findViewById(R.id.md_SwipeRefreshLayout);//设置进度条的颜色swipeRefreshLayout.setColorSchemeColors(Color.RED, Color.BLUE, Color.GREEN);//设置圆形进度条大小swipeRefreshLayout.setSize(SwipeRefreshLayout.LARGE);//设置进度条背景颜色 swipeRefreshLayout.setProgressBackgroundColorSchemeColor(Color.WHITE);//设置下拉多少距离之后开始刷新数据，不要设置的太大，不然怎么拉都不刷新swipeRefreshLayout.setDistanceToTriggerSync(5);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[软件设计原则]]></title>
      <url>%2F2015%2F02%2F12%2F%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
      <content type="text"><![CDATA[前言 类是不稳定的，，但是抽象相对稳定，依赖于抽象将获得更加稳定的类结构。 设计原则单一指责 每个类只负责单一的功能，避免修改一个功能完成另一个功能的错误出现。 里氏替换/抽象类原则 子类实现父类的抽象方法 子类不要修改父类的非抽象方法 子类实现抽象方法时前置条件（参数）应该更加宽松 子类重写父类的方法后置条件（返回值）应该更加严格 依赖倒置 高层模块不应该依赖于底层模块，二者都应该依赖于抽象 抽象不能依赖于细节，细节要依赖抽象 多用抽象的接口描述动作。抽象难以扩展或者扩展复杂的的动作，降低动作执行者和动作承受者之间的关联 迪米特法则/最少知道原则 每个类对自己依赖的类知道的越少越好，被依赖的类开放公开的方法却封装内部复杂的逻辑 开闭原则 对扩展是开放的对修改是封闭的 使用增加软件实体的方法来扩展功能而不要使用修改代码的方式 接口隔离原则 一个类对另一个类的依赖应该建立在最小的接口上，也就是不要强迫子类实现他不需要的功能，如果需要这么做那么说明这个接口最小接口需要拆分]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Dialog总结]]></title>
      <url>%2F2015%2F01%2F22%2FAndroid%E5%BC%80%E5%8F%91%2FAndroidDialog%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[ProgressDialog ProgressDialog是AlertDialog的子类 12345678910111213141516171819202122//简单的使用方法，只是用来提示用户等待,ProgressDialog dialog ＝ ProgressDialog.show(context,"title","message");//设置更多参数的用法ProgressDialog mWaitDialog = new ProgressDialog(self);mWaitDialog.setMessage("请稍候");mWaitDialog.setTitle("标题");//设置按钮，DialogInterface.BUTTON_NEGATIVE可以设置按钮的属性，不携带该参数方法已经过时mWaitDialog.setButton(DialogInterface.BUTTON_NEGATIVE, "返回", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; dialog.dismiss(); finish();&#125;);mWaitDialog.setIndeterminate(false);mWaitDialog.setCancelable(false);mWaitDialog.setCanceledOnTouchOutside(false);mWaitDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);mWaitDialog.setProgress(0);mWaitDialog.setMax(100);mWaitDialog.show();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android开发问题常见问题]]></title>
      <url>%2F2015%2F01%2F18%2FAndroid%E5%BC%80%E5%8F%91%2FAndroid%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[方法数量超出限制 使用分包策略 出现exit value 3之类的错误通常是方法数目超出限制了，建议使用分包机制，但这不是解决问题的方法,最重要的还是准确选择类库，精简方法数。 1234567891011121314//引入分包compile 'com.android.support:multidex:1.0.1'／／添加允许多方法defaultConfig &#123; multiDexEnabled true &#125;／／在Application添加分包初始化@Overrideprotected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); MultiDex.install(this); ｝ 方法数统计 推荐一个插件，可以计算每个包下面的方法数目 在app.gradle文件头添加以下插件，会在app/build/outputs/dexcount/debug.txt文件里生成每个包下面的方法数，如下：apply plugin: ‘com.getkeepsafe.dexcount’ 123456789101112methods fields package/class name8 0 &lt;unnamed&gt;21186 8027 android6 0 android.accessibilityservice34 0 android.animation556 33 android.app3 0 android.app.usage2 0 android.appwidget488 50 android.content42 43 android.content.pm106 6 android.content.res79 0 android.database 签名问题12345678910111213141516171819202122//正式签名相关信息signingConfigs &#123; myConfig &#123; storeFile file("相对或者绝对路径") storePassword "sangular123" keyAlias "sangular" keyPassword "sangular123" &#125;&#125;buildTypes &#123; //release版本的正式签名 release &#123; //minifyEnabled true 打包发布时会使用该代码 //proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig signingConfigs.myConfig &#125; //debug版本也用正式签名调试，这样可以在debug版本下使用第三方登陆等功能 debug &#123; signingConfig signingConfigs.myConfig ｝&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见排序及搜索算法总结]]></title>
      <url>%2F2015%2F01%2F01%2F%E5%AD%A6%E4%B9%A0%2FJava%E6%8E%92%E5%BA%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[排序冒泡排序12345678910111213//冒泡:0 ~ n-1 0 ~ n-1-i//冒泡排序:两两比较,比较n-1趟,每一趟比较n-i-1次public static void BubbleSort(int a[])&#123; int n = a.length; for(int i = 0; i &lt; n - 1; i++) //比较n-1趟 for(int j = 0; j &lt; n - 1 - i; j++)&#123;//比较n-i-1次! if(a[j+1] &lt; a[j])&#123; a[j+1] = a[j+1] ^ a[j]; a[j] = a[j] ^ a[j+1]; a[j+1] = a[j] ^ a[j+1]; &#125; &#125;&#125; 选择排序123456789101112131415161718//选择排序:遍历前n-1个元素,与 i+1 直到 n 个元素比较,记录小数下标public static void SelectSort(int a[])&#123; int n = a.length; for(int i = 0; i &lt; n - 1; i++)&#123; int min = i; for(int j = i + 1; j &lt; n; j++)&#123; if(a[min] &gt; a[j])&#123; min = j; &#125; &#125; if(min != i)&#123; a[i] = a[i] ^ a[min]; a[min] = a[min] ^ a[i]; a[i] = a[min] ^ a[i]; &#125; &#125;&#125; 插入排序1234567891011121314//插入排序:左边为有序区域,遍历第一个直到第n个,与前i个比较 public static void InsertSort(int a[])&#123; int n = a.length; for(int i = 1;i &lt; n; i++) for(int j = i; j &gt; 0; j--)&#123; if(a[j] &lt; a[j-1])&#123; a[j] = a[j] ^ a[j-1]; a[j-1] = a[j-1] ^ a[j]; a[j] = a[j-1] ^ a[j]; &#125; else break; &#125; &#125; 快速排序1234567891011121314151617181920212223public static void quicksort(int n[], int left, int right) &#123; int dp; if (left &lt; right) &#123; dp = partition(n, left, right); quicksort(n, left, dp - 1); quicksort(n, dp + 1, right); &#125; &#125;public static int partition(int n[], int left, int right) &#123; int pivot = n[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; n[right] &gt;= pivot) right--; if (left &lt; right) n[left++] = n[right]; while (left &lt; right &amp;&amp; n[left] &lt;= pivot) left++; if (left &lt; right) n[right--] = n[left]; &#125; n[left] = pivot; return left;&#125; 搜索二分法搜索123456789101112131415161718public static int HalfSearch(int a[],int target)&#123; int bottom = 0; int top = a.length - 1; int middle = (top + bottom) / 2; while(bottom &lt;= top)&#123; if(a[middle] &gt; target)&#123; top = middle - 1; &#125; else if(a[middle] &lt; target)&#123; bottom = middle + 1; &#125; else &#123; return middle; &#125; middle = (top + bottom) / 2; &#125; return -1; &#125;]]></content>
    </entry>

    
  
  
</search>
