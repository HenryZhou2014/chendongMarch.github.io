<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Rxjava2.x开发-n-Backpressure-todo]]></title>
    <url>%2Farticle%2F2a4b463b%2F</url>
    <content type="text"><![CDATA[本文主要记录总结背压的相关知识。 当上游发送的事件的速度很快，下游处理事件的速度很慢，就会出现背压，这很好理解，就好比一条水管，上游水流量太大，下游水流量太小，上游送过来的水下游不能及时输出，就会产生压力，这就是背压。 背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略 本来想写一段程序触发一下 MissingBackpressureException ，结果没成功。 在 RxJava2.x 中 Observable 是默认不支持背压的，而 Flowable 是支持背压的。]]></content>
      <categories>
        <category>Android</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava2.x</tag>
        <tag>Library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rxjava2.x开发-4-操作符-创建]]></title>
    <url>%2Farticle%2F6cad82c9%2F</url>
    <content type="text"><![CDATA[本文主要总结 RxJava2.x 关于创建操作相关操作符的用法。 CreateCreate 是最基本的创建操作符，他用来创建一个标准的被观察者，然后恰当的调用观察者的 onNext，onError 和 onCompleted 方法。 一个形式正确的有限 Observable 必须尝试调用观察者的 onCompleted 正好一次或者它的 onError 正好一次，而且此后不能再调用观察者的任何其它方法。 好的做法是在数据发射之前判断观察者的状态，在没有观察者时不进行事件发送和计算操作。Create 操作符不在任何线程调度器上执行。 123456789Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; if(!e.isDisposed()) &#123; e.onNext(1); e.onComplete(); &#125; &#125;&#125;); JustJust 类似于 From，但是 From 会将数组或 Iterable 的数据取出然后逐个发射，而 Just 只是简单的原样发射，将数组或 Iterable 当做单个数据，如下情况，将会直接发送一个 List 出去，而不是里面的数字 0; 123List&lt;Integer&gt; integers = new ArrayList&lt;&gt;();integers.add(0);Observable.just(integers); Just 它最多接受 10 个参数，返回一个按参数列表顺序发射这些数据的 Observable。从 RxJava2.x 开始，使用 just 不允许传递 null，否则会出现异常(NPE) 12345678Observable.just(0);Observable.just(0, 1);Observable.just(0, 1, 2, 3, 4, 5, 6, 7, 8, 9) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer o) throws Exception &#123; &#125; &#125;); From在 RxJava1.x 时，只有一个 From 操作符，接受不同类型的参数，但是在 RxJava2.x 对这个操作符进行了细分。 fromIterable 和 fromArrayfrom 操作符可以转换 数组 和 Iterable，产生的 Observable 会发射 数组 和 Iterable 的每一项数据。 123List&lt;Integer&gt; integers = new ArrayList&lt;&gt;();integers.add(0);Observable.fromIterable(integers); 123int[] array = new int[]&#123;1,2,3&#125;;Observable.fromArray(array);Observable.fromArray(1,2,3); fromCallable 和 fromFuturetodo… Callable 和 Future 都是 java.util.concurrent 包里面的类，具体使用方法暂时不清楚，后面补充。 fromCallable() 返回的是 onNext 传递的数据，fromCallable() 获取要发送的数据的代码只会在有 Observer 订阅之后执行，且获取数据的代码可以在子线程中执行。 123456Observable.fromCallable(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; return 100 + 2; &#125;&#125;); 1234public static &lt;T&gt; Observable&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future)public static &lt;T&gt; Observable&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future, long timeout, TimeUnit unit)public static &lt;T&gt; Observable&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future, long timeout, TimeUnit unit)public static &lt;T&gt; Observable&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future, long timeout, TimeUnit unit, Scheduler scheduler) fromPublishertodo…暂时不是很清楚它的用法， 但是 Flowable 实现了 Publisher 接口，可以使用该方法将 Flowable 转换为 Observable 123456Flowable&lt;Integer&gt; integerFlowable = Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull FlowableEmitter&lt;Integer&gt; e) throws Exception &#123; &#125;&#125;, BackpressureStrategy.BUFFER);Observable.fromPublisher(integerFlowable); Defer直到有观察者订阅时才创建 Observable，并且为每个观察者创建一个新的Observable。 Defer 操作符会一直等待直到有观察者订阅它，然后它使用 Observable 工厂方法生成一个 Observable。它对每个观察者都这样做，因此尽管每个订阅者都以为自己订阅的是同一个 Observable，事实上每个订阅者获取的是它们自己的单独的数据序列。 123456789101112131415Observable&lt;Object&gt; defer = Observable.defer(new Callable&lt;ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; call() throws Exception &#123; return Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exceptio RxHelper.log("发射数据 --&gt; " + hashCode()); e.onNext(1); e.onComplete(); &#125; &#125;); &#125;&#125;);defer.subscribe(new MyObserver&lt;&gt;());defer.subscribe(new MyObserver&lt;&gt;()); Empty/Never/Throwempty 创建一个不发射任何数据但是正常终止的 Observable; never 创建一个不发射数据也不终止的 Observable; throw 创建一个不发射数据以一个错误终止的 Observable; 1234567891011Observable.empty();Observable.never();Observable.error(new Callable&lt;Throwable&gt;() &#123; @Override public Throwable call() throws Exception &#123; return new RuntimeException("test"); &#125;&#125;);Observable.error(new RuntimeException("test")); Interval 和 Range默认在 computation 调度器上执行，你也可以传递一个可选的Scheduler 参数来指定调度器。 intervalinterval 返回一个以固定时间间隔发送无限递增的 Long 型数列的 Observable。 12345678public static Observable&lt;Long&gt; interval(long period, TimeUnit unit)public static Observable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit)public static Observable&lt;Long&gt; interval(long period, TimeUnit unit, Scheduler scheduler)public static Observable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler)// 延迟 1s，间隔 100ms，发送无限增长的 Long 型数列Observable.interval(1, 100, TimeUnit.MILLISECONDS) .subscribe(new MyObserver&lt;Long&gt;("interval")); intervalRangeintervalRange 类似于 interval，但是它可以指定起始数值，而且不再是一个无限数列，需要注意的是，假设起始值为 start = a，count = b，即为从 start 开始，发送 count 个数据，那么发送的区间是 [a,a+b)，左闭右开，例如 start = 100，count = 120，区间是 [100,220)，即 100 ～ 219，另外 count 不能为负数，否则会异常。 123456public static Observable&lt;Long&gt; intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit)public static Observable&lt;Long&gt; intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler)// 延迟 1s，间隔 100ms，发送从100 开始的递增数列，发送的区间是 [100,100+120)Observable.intervalRange(100, 120, 1, 100, TimeUnit.MILLISECONDS) .subscribe(new MyObserver&lt;Long&gt;("intervalRange")); range 和 rangeLong从 start 开始发送 count 个数据，区间为 [start,start+count) 123Observable.range(100,50).subscribe(new MyObserver&lt;Integer&gt;("range"));Observable.rangeLong(100,50).subscribe(new MyObserver&lt;Long&gt;("rangeLong")); Repeatrepeat 默认在 trampoline 调度器执行。 repeat重复发送 Observable 的数据，如果不指定数目，将会无限发送。 12345Observable.just(1).repeat(10) .subscribe(new MyObserver&lt;Integer&gt;("repeat1")); Observable.just(1).repeat() .subscribe(new MyObserver&lt;Integer&gt;("repeat2")); repeatWhentodo…对这个运算符不是很清楚它的作用 它不是缓存和重放原始 Observable 的数据序列，而是有条件的重新订阅和发射原来的 Observable。 将原始 Observable 的终止通知（完成或错误）当做一个 void 数据传递给一个通知处理器，它以此来决定是否要重新订阅和发射原来的 Observable。这个通知处理器就像一个 Observable 操作符，接受一个发射 void 通知的 Observable 为输入，返回一个发射 void 数据（意思是，重新订阅和发射原始 Observable）或者直接终止（意思是，使用 repeatWhen 终止发射数据）的Observable。 123456789Observable.just(1,2,4).repeatWhen(new Function&lt;Observable&lt;Object&gt;, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(@NonNull Observable&lt;Object&gt; objectObservable) throws Exception &#123; RxHelper.log("apply"); return objectObservable; &#125;&#125;) .subscribeOn(Schedulers.computation()) .subscribe(new MyObserver&lt;Integer&gt;("repeatWhen")); Start发送事件之前先发送某些事件。 12345678910111213141516171819202122// 接收单个值Observable.just(1, 2, 4).startWith(100) .subscribe(new MyObserver&lt;Integer&gt;("startWith1"));// 接收 iterableList&lt;Integer&gt; ints = new ArrayList&lt;&gt;();ints.add(100);ints.add(200);Observable.just(1, 2, 4).startWith(ints) .subscribe(new MyObserver&lt;Integer&gt;("startWith2"));// 接收 arrayObservable.just(1, 2, 4).startWithArray(100, 200) .subscribe(new MyObserver&lt;Integer&gt;("startWith3"));// 接收 arrayInteger[] intArray = new Integer[]&#123;100, 200&#125;;Observable.just(1, 2, 4).startWithArray(intArray) .subscribe(new MyObserver&lt;Integer&gt;("startWith4"));// 接收 observableObservable.just(1, 2, 4).startWith(Observable.just(100, 200)) .subscribe(new MyObserver&lt;Integer&gt;("startWith5")); Timer在一定时间之后发送一个特殊值 0，timer 操作符默认在 computation 线程执行。 1234public static Observable&lt;Long&gt; timer(long delay, TimeUnit unit)public static Observable&lt;Long&gt; timer(long delay, TimeUnit unit, Scheduler scheduler)Observable.timer(10, TimeUnit.MILLISECONDS).subscribe(new MyObserver&lt;Long&gt;("timer"));]]></content>
      <categories>
        <category>Android</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava2.x</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 选择器]]></title>
    <url>%2Farticle%2Fd318b1f4%2F</url>
    <content type="text"><![CDATA[选择器是声明这个样式被应用在哪个标签上面的规则。 基本选择器 标记 描述 含义 * 通用选择器 匹配所有元素 E 标签选择器 匹配所有使用E标签的元素 .info class选择器 匹配所有class属性中包含info的元素 #footer id选择器 匹配所有id属性等于footer的元素 实例 1234567* &#123; margin:0; padding:0; &#125;p &#123; font-size:2em; &#125;.info &#123; background:#ff0; &#125;p.info &#123; background:#ff0; &#125;p.info.error &#123; color:#900; font-weight:bold; &#125;#info &#123; background:#ff0; &#125;p#info &#123; background:#ff0; &#125; 多元素选择器 标记 描述 含义 E,F 多元素选择器 同时匹配所有E元素或F元素，E和F之间用逗号分隔 E F 后代元素选择器 匹配所有属于E元素后代的F元素，E和F之间用空格分隔 E &gt; F 子元素选择器 匹配所有E元素的子元素F E + F 毗邻元素选择器 匹配所有紧随E元素之后的同级元素F 示例 12345div p &#123; color:#f00; &#125;#nav li &#123; display:inline; &#125;#nav a &#123; font-weight:bold; &#125;div &gt; strong &#123; color:#f00; &#125;p + p &#123; color:#f00; &#125; 属性选择器 (css2.1) 标记 描述 E[attr] 匹配所有具有attr属性的E元素，不考虑它的值。(注意：E在此处可以省略，比如”[title]”，以下同。) E[attr=val] 匹配所有attr属性等于”val”的E元素 E[attr~=val] 匹配所有attr属性具有多个空格分隔的值、其中一个值等于”val”的E元素 E[attr&vert;=val] 匹配所有att属性具有多个连字号分隔的值、其中一个值以”val”开头的E元素，主要用于lang属性，比如”en”、”en-us”、”en-gb”等等 示例 12345p[title] &#123; color:#f00; &#125;div[class=error] &#123; color:#f00; &#125;td[headers~=col1] &#123; color:#f00; &#125;p[lang|=en] &#123; color:#f00; &#125;blockquote[class=quote][cite] &#123; color:#f00; &#125; 伪类(css2.1) 标记 描述 E:first-child 匹配父元素的第一个子元素 E:link 匹配所有未被点击的链接 E:visited 匹配所有已被点击的链接 E:active 匹配鼠标已经其上按下、还没有释放的E元素 E:hover 匹配鼠标悬停其上的E元素 E:focus 匹配获得当前焦点的E元素 E:lang(c) 匹配lang属性等于c的E元素 示例 1234p:first-child &#123; font-style:italic; &#125;input[type=text]:focus &#123; color:#000; background:#ffe; &#125;input[type=text]:focus:hover &#123; background:#fff; &#125;q:lang(sv) &#123; quotes: "\201D" "\201D" "\2019" "\2019"; &#125; 伪元素(css2.1) 标记 描述 E:first-line 匹配E元素的第一行 E:first-letter 匹配E元素的第一个字母 E:before 在E元素之前插入生成的内容 E:after 在E元素之后插入生成的内容 示例 1234p:first-line &#123; font-weight:bold; color;#600; &#125;.preamble:first-letter &#123; font-size:1.5em; font-weight:bold; &#125;.cbb:before &#123; content:""; display:block; height:17px; width:18px; background:url(top.png) no-repeat 0 0; margin:0 0 0 -18px; &#125;a:link:after &#123; content: " (" attr(href) ") "; &#125; 同级元素通用选择器(css3) 标记 描述 E ~ F 匹配任何在E元素之后的同级F元素 示例 1p ~ ul &#123; background:#ff0; &#125; 属性选择器(css3) 标记 描述 E[attr\^=”val”] 属性attr的值以”val”开头的元素 E[attr$=”val”] 属性attr的值以”val”结尾的元素 E[attr*=”val”] 属性attr的值包含”val”字符串的元素 示例 1div[id^="nav"] &#123; background:#ff0; &#125; 与用户界面有关的伪类(css3) 标记 描述 E:enabled 匹配表单中激活的元素 E:disabled 匹配表单中禁用的元素 E:checked 匹配表单中被选中的radio 或checkbox 元素 E:selection 匹配用户当前选中的元素 示例 1input[type="text"]:disabled &#123; background:#ddd; &#125; 结构性伪类(css3) 标记 描述 E:root 匹配文档的根元素，对于HTML文档，就是HTML元素 E:nth-child(n) 匹配其父元素的第n个子元素，第一个编号为1 E:nth-last-child(n) 匹配其父元素的倒数第n个子元素，第一个编号为1 E:nth-of-type(n) 与:nth-child()作用类似，但是仅匹配使用同种标签的元素 E:nth-last-of-type(n) 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素 E:last-child 匹配父元素的最后一个子元素，等同于:nth-last-child(1) E:first-of-type 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1) E:last-of-type 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1) E:only-child 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1) E:only-of-type 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1) E:empty 匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素 示例 12345678910p:nth-child(3) &#123; color:#f00; &#125;p:nth-child(odd) &#123; color:#f00; &#125;p:nth-child(even) &#123; color:#f00; &#125;p:nth-child(3n+0) &#123; color:#f00; &#125;p:nth-child(3n) &#123; color:#f00; &#125;tr:nth-child(2n+11) &#123; background:#ff0; &#125;tr:nth-last-child(2) &#123; background:#ff0; &#125;p:last-child &#123; background:#ff0; &#125;p:only-child &#123; background:#ff0; &#125;p:empty &#123; background:#ff0; &#125; 反选伪类(css3) 标记 描述 E:not(s) 匹配不符合当前选择器的任何元素 示例 1:not(p) &#123; border:1px solid #ccc; &#125; :target 伪类(css3) 标记 描述 E:target 匹配文档中特定”id”点击后的效果]]></content>
      <categories>
        <category>Study</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速接入微信微博QQ原生登录分享]]></title>
    <url>%2Farticle%2F3067853428%2F</url>
    <content type="text"><![CDATA[SocialSdk SocialSdk 提供微博、微信、QQ的登陆分享功能支持，使用 微博、QQ、微信 原生 SDK 接入，持续优化中… 由于项目中想要接入的平台因人而异，第三方 SDK 更新也比较频繁，因此没有对类库进行发布操作，下载之后直接依赖 module 即可，开放源码，这样也方便问题修复。 SocialSdk 主要对外开放三个类文件 SocialSdk，ShareManager，LoginManager。SocialSdk 用来完成基本配置的初始化操作，ShareManager 用来进行分享操作，LoginManager 用来进行登录操作。 123LoginManager.login(mActivity, LoginManager.TARGET_QQ, mOnLoginListener); ShareManager.share(mActivity, ShareManager.TARGET_QQ_FRIENDS, imageObj, mOnShareListener); SocialSdk GitHub 地址 GitHub 上面只是提供了一个 module，我是在另外一个工程中进行测试，因为登录功能需要成为微信开发者，需要交钱，所以当前工程并没有测试代码，后面会补充，建议下载 module 依赖到自己工程中使用。 使用详细说明的博客地址 初始化你需要在使用 SDK 之前进行初始化操作，建议放在 Applicaton 中进行。 1234567891011121314151617String qqAppId = getString(R.string.QQ_APPID);String wxAppId = getString(R.string.WEICHAT_APPID);String wxSecretKey = getString(R.string.WEICHAT_APPKEY);String sinaAppId = getString(R.string.SINA_APPKEY);SocialSdkConfig config = new SocialSdkConfig(this) // 配置qq .qq(qqAppId) // 配置wx .wechat(wxAppId, wxSecretKey) // 配置sina .sina(sinaAppId) // 配置Sina的RedirectUrl，有默认值，如果是官网默认的不需要设置 .sinaRedirectUrl("http://open.manfenmm.cxxxxxxx") // 配置Sina授权scope,有默认值，默认值 all .sinaScope(SocialConstants.SCOPE);SocialSdk.init(config); 登录功能 快速唤醒登录 LoginManager.login(mActivity, LoginManager.TARGET_QQ, mOnLoginListener); 登陆功能支持三个平台，qq，微信，微博；分别对应 类型 是： 1234// 3个平台LoginManager.TARGET_QQ;LoginManager.TARGET_WECHAT;LoginManager.TARGET_SINA; 使用 OnLoginListener 监听登录返回结果，返回的 LoginResult 中主要包括登录类型，基本用户信息，令牌信息 3 部分。 123456789101112131415161718192021222324252627282930313233public class LoginResult &#123; // 登陆的类型，对应 LoginManager.TARGET_QQ 等。。。 private int type; // 返回的基本用户信息 // 针对登录类型可强转为 WbUser,WxUser,QQUser 来获取更加丰富的信息 private BaseUser mBaseUser; // 本次登陆的 token 信息，openid,unionid,token,expires_in private BaseAccessToken mBaseToken;&#125;// 登陆结果监听mOnLoginListener = new OnLoginListener() &#123; @Override public void onLoginSucceed(LoginResult loginResult) &#123; Log.e(TAG, loginResult.toString()); &#125; @Override public void onCancel() &#123; toast("登录取消"); &#125; @Override public void onException(PlatformException e) &#123; toast("登录失败 " + e.toString()); &#125;&#125;;// 3个平台LoginManager.TARGET_QQ;LoginManager.TARGET_WECHAT;LoginManager.TARGET_SINA;// 唤醒登陆LoginManager.login(mActivity, LoginManager.TARGET_QQ, mOnLoginListener); 分享功能 快速使用分享功能 ShareManager.share(mActivity, ShareManager.TARGET_QQ_FRIENDS, imageObj, mOnShareListener); 分享支持 8 种类型的数据；如果某个平台不兼容某种类型的分享，将会使用 web 分享的方式代替；比如微信不支持 app 分享，分享出去之后时 web 分享的模式。支持的 8 种类型分别是： 开启渠道对用的 app。 分享文字。 分享图片( jpg , png , gif )。 分享 app。 分享 web。 分享 music。 分享 video。 分享 voice，(sina 专有，其他平台使用 web 分享) 分享渠道12345678// 支持的分享渠道ShareManager.TARGET_QQ_FRIENDS ; // qq好友ShareManager.TARGET_QQ_ZONE ; // qq空间ShareManager.TARGET_WECHAT_FRIENDS ; // 微信好友ShareManager.TARGET_WECHAT_ZONE ; // 微信朋友圈ShareManager.TARGET_WECHAT_FAVORITE; // 微信收藏ShareManager.TARGET_SINA ; // 新浪微博ShareManager.TARGET_SINA_OPENAPI ; // 新浪微博openApi分享，使用该方法分享图片时微博后面会带一个小尾巴，可以点击进入官微 创建分享数据分享时，我们首先要构造分享用的数据，ShareMediaObj 对象提供了多种静态方法用来快速创建对应分享的类型的对象。 1234567891011121314151617181920212223242526272829// 测试用的路径localImagePath = new File(Environment.getExternalStorageDirectory(), "1.jpg").getAbsolutePath();localVideoPath = new File(Environment.getExternalStorageDirectory(), "video.mp4").getAbsolutePath();localGifPath = new File(Environment.getExternalStorageDirectory(), "3.gif").getAbsolutePath();netVideoPath = "http://7xtjec.com1.z0.glb.clouddn.com/export.mp4";netImagePath = "http://7xtjec.com1.z0.glb.clouddn.com/token.png";netMusicPath = "http://7xtjec.com1.z0.glb.clouddn.com/test_music.mp3";netMusicPath = "http://mp3.haoduoge.com/sSocialSdkConfig/2017-05-19/1495207225.mp3";targetUrl = "http://bbs.csdn.net/topics/391545021";// 打开渠道对应appShareMediaObj shareMediaObj = ShareMediaObj.buildOpenAppObj();// 分享文字ShareMediaObj textObj = ShareMediaObj.buildTextObj("分享文字", "summary");// 分享图片ShareMediaObj imageObj = ShareMediaObj.buildImageObj("分享图片", "summary", localImagePath);// 分享gifShareMediaObj imageGifObj = ShareMediaObj.buildImageObj("分享图片", "summary", localGifPath);// 分享appShareMediaObj appObj = ShareMediaObj.buildAppObj("分享app", "summary", localImagePath, targetUrl);// 分享webShareMediaObj webObj = ShareMediaObj.buildWebObj("分享web", "summary", localImagePath, targetUrl);// 分享视频ShareMediaObj videoObj = ShareMediaObj.buildVideoObj("分享视频", "summary", localImagePath, targetUrl, localVideoPath, 10);// 分享音乐ShareMediaObj musicObj = ShareMediaObj.buildMusicObj("分享音乐", "summary", localImagePath, targetUrl, netMusicPath, 10);// 分享声音，微博特有，其他平台以web方式分享ShareMediaObj voiceObj = ShareMediaObj.buildVoiceObj("分享声音", "summary", localImagePath, targetUrl, netMusicPath, 10); 分享监听分享结果，使用 OnShareListener 进行检测。OnShareListener 提供了丰富的方法来支持分享的各个阶段，关于分享对象重构的操作，在下一部分说明。 1234567891011121314151617181920212223public class SimpleShareListener implements OnShareListener&#123; @Override public void onStart(int shareTarget, ShareMediaObj obj) &#123; // 分享开始 &#125; @Override public ShareMediaObj onPrepareInBackground(int shareTarget, ShareMediaObj obj) &#123; // 重构分享对象，不需要时返回 null 即可 return null; &#125; @Override public void onSuccess() &#123; // 分享成功 &#125; @Override public void onFailure(SocialException e) &#123; // 分享失败 &#125; @Override public void onCancel() &#123; // 分享取消 &#125;&#125; 发起分享1234567891011// 支持的分享渠道ShareManager.TARGET_QQ_FRIENDS ; // qq好友ShareManager.TARGET_QQ_ZONE ; // qq空间ShareManager.TARGET_WECHAT_FRIENDS ; // 微信好友ShareManager.TARGET_WECHAT_ZONE ; // 微信朋友圈ShareManager.TARGET_WECHAT_FAVORITE; // 微信收藏ShareManager.TARGET_SINA ; // 新浪微博ShareManager.TARGET_SINA_OPENAPI ; // 新浪微博openApi分享，使用该方法分享图片时微博后面会带一个小尾巴，可以点击进入官微// 唤醒分享ShareManager.share(mActivity, ShareManager.TARGET_QQ_FRIENDS, imageObj, mOnShareListener); 重写分享对象关于重写分享对象，其实是在分享之前对需要分享的 ShareMediaObj 进行处理返回新的 ShareMediaObj 的操作，比如可以用来解决网络图片无法分享，我们需要将它下载到本地，在进行分享，又比如图片分享出去之前加上 app 水印等操作。 主要是重写 OnShareListener 的 onPrepareInBackground 方法，这个方法会在分享之前首先执行，如果返回不是 null，将会使用新创建的 ShareMediaObj 进行分享，另外由于考虑到可能进行耗时操作，这个方法是在子线程执行的。 12345@Overridepublic ShareMediaObj onPrepareInBackground(int shareTarget,ShareMediaObj obj) &#123; // 重构分享对象，不需要时返回 null 即可 return null;&#125; 看一个基本的实例，其中 ShareObjHelper.prepareThumbImagePath(obj); 是 SDK 内部下载文件的一个方法的封装，用来将网络图下载到本地然后更新 ShareMediaObj 指向的图片地址，你可以直接使用它。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class MyShareListener extends SimpleShareListener &#123; public static final String TAG = MyShareListener.class.getSimpleName(); private Context mContext; private LoadingDialog mLoadingDialog; public MyShareListener(Context context) &#123; mContext = context; mLoadingDialog = new LoadingDialog(mContext); &#125; @Override public void onStart(int shareTarget, ShareMediaObj obj) &#123; if (mLoadingDialog != null) mLoadingDialog.show(); &#125; @Override public ShareMediaObj onPrepareInBackground(int shareTarget, ShareMediaObj obj) throws Exception&#123; // 网络路径，先进行文件下载进行文件下载 ShareObjHelper.prepareThumbImagePath(obj); // 分享照片且不是gif时加水印 if (obj.getShareObjType() == ShareMediaObj.SHARE_TYPE_IMAGE &amp;&amp; !FileHelper.isGifFile(obj.getThumbImagePath())) &#123; File thumbImageFile = new File(obj.getThumbImagePath()); File saveFile = new File(Constants.THUMB_IMAGE_PATH, thumbImageFile.getName()); if (!FileUtil.fileIsExist(saveFile.getAbsolutePath())) &#123; ImageUtils.drawWaterMarkSync(mContext, obj.getThumbImagePath(), saveFile.getAbsolutePath(), false, false); &#125; obj.setThumbImagePath(saveFile.getAbsolutePath()); &#125; return obj; &#125; @Override public void onSuccess() &#123; ToastUtil.show("分享成功"); &#125; @Override public void onFailure(SocialException e) &#123; switch (e.getErrorCode()) &#123; case SocialException.CODE_NOT_INSTALL: ToastUtil.show("应用未安装"); break; &#125; L.e(TAG, "分享失败" + e.toString()); &#125; @Override public void onCancel() &#123; ToastUtil.show("分享取消"); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Contribute</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS]]></title>
    <url>%2Farticle%2F5b70625a%2F</url>
    <content type="text"><![CDATA[CSS 指层叠样式表 (Cascading Style Sheets) 解决内容与表现分离的问题。 开始12345678910111213141516171819202122232425262728293031323334body&#123; background-color:#d0e4fe;&#125;h1&#123; color:orange; text-align:center;&#125;p&#123; font-family:"Times New Roman"; font-size:20px;&#125;四个值: 第一个值为左上角，第二个值为右上角，第三个值为右下角，第四个值为左下角。三个值: 第一个值为左上角, 第二个值为右上角和左下角，第三个值为右下角两个值: 第一个值为左上角与右下角，第二个值为右上角与左下角一个值: 四个圆角值相同``` ## 插入样式表向 `html` 文档中插入样式表，样式表中不能包含任何的 `html` 标签。如果某些属性在不同的样式表中被同样的选择器定义，那么属性值将从更具体的样式表中被继承过来。多重样式层叠优先级如下，同一优先级内同样的样式后面定义的具有更高的优先级&gt; 内联样式 &gt; 内部样式表 &gt; 外部样式表 &gt; 浏览器缺省设置### 外部样式表浏览器会从文件 `mystyle.css` 中读到样式声明，并根据它来格式文档，外部样式表可以在任何文本编辑器中进行编辑，外部样式表应该以 `.css` 扩展名进行保存。```html&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="mystyle.css"&gt;&lt;/head&gt; 内部样式表当单个文档需要特殊的样式时，就应该使用内部样式表。 123456&lt;head&gt;&lt;style&gt; hr &#123;color:red;&#125; p &#123;margin-left:20px;&#125; body &#123;background-image:url("images/back40.gif");&#125;&lt;/style&gt; 内联样式由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势。例如当样式仅需要在一个元素上应用一次时，可以使用内联样式。要使用内联样式，你需要在相关的标签内使用样式style 属性。style 属性可以包含任何 CSS 属性。 1&lt;p style="color:red;margin-left:20px"&gt;This is a paragraph.&lt;/p&gt; CSS 背景 Property 描述 background 简写属性，作用是将背景属性设置在一个声明中。 background-attachment 背景图像是否固定或者随着页面的其余部分滚动。 background-color 设置元素的背景颜色。 background-image 把图像设置为背景。 background-position 设置背景图像的起始位置。 background-repeat 设置背景图像是否及如何重复。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758591. 背景颜色(background-color)定义颜色的三种方式- 十六进制："#123456"- RGB颜色：rgb(255,0,0)- 颜色名称：red,greenbody &#123;background-color:#b0c4de;&#125;---2. 背景图像(background-image)默认情况下，背景图像进行平铺重复显示，以覆盖整个元素实体.body &#123;background-image:url('paper.gif');&#125;---3. 背景图像平铺方式(background-repeat)默认情况下，图像会水平和垂直平铺，使用background-repeat指定平铺方式水平方向平铺 background-repeat:repeat-x; 垂直方向平铺 background-repeat:repeat-y; 不平铺 background-repeat:no-repeat; body&#123;background-image:url('img_tree.png');background-repeat:no-repeat;&#125;---4. 背景图像滑动方式(background-attachment)scroll 默认值。背景图像会随着页面其余部分的滚动而移动。fixed 当页面的其余部分滚动时，背景图像不会移动。inherit 规定应该从父元素继承 background-attachment 属性的设置body &#123; background-image: url(bgimage.gif);background-attachment: fixed;&#125;---5. 背景图像的位置(background-position)指定背景图像的位置right top left bottombody&#123;background-image:url('img_tree.png');background-repeat:no-repeat;background-position:right top;&#125;---6. 简写属性(backgound)简写属性的顺序为 1. background-color 2. background-image 3. background-repeat 4. background-attachment 5. background-positionbody &#123; background:#ffffff url('img_tree.png') no-repeat right top;&#125; CSS 文本 Property 描述 color 设置文本颜色 body {color:blue;} direction 设置文本方向。 letter-spacing 设置字符间距 line-height 设置行高 text-align 对齐元素中的文本 text-decoration 向文本添加修饰 text-indent 缩进元素中文本的首行 text-shadow 设置文本阴影 text-transform 控制元素中的字母 unicode-bidi 设置或返回文本是否被重写 vertical-align 设置元素的垂直对齐 white-space 设置元素中空白的处理方式 word-spacing 设置字间距 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001. 文本颜色(color)对于W3C标准的CSS：如果你定义了颜色属性，你还必须定义背景色属性。body &#123;color:blue;&#125;h1 &#123;color:#00ff00;&#125;h2 &#123;color:rgb(255,0,0);&#125;---2. 文本对齐方式(text-align)四种取值：right left center justify(自适应窗口对齐对)p.date &#123;text-align:justify;&#125;---3. 文本修饰(text-decoration)三种取值：overline(上划线) line-through(删除线) underline(下划线)h1 &#123;text-decoration:overline;&#125;---4. 文本转换(text-transform)三种取值：uppercase(全部大写) lowercase(全部小写) capitalize(首字母大写)p.uppercase &#123;text-transform:uppercase;&#125;---5. 文本缩进(text-indent)首行文本缩进p &#123;text-indent:50px;&#125;---6. 文字间距(letter-spacing)三个取值normal 默认。规定字符间没有额外的空间。length 定义字符间的固定空间（允许使用负值）。inherit 规定应该从父元素继承 letter-spacing 属性的值。h2 &#123;letter-spacing:-3px&#125;---7. 文字高度(line-height)normal 默认。设置合理的行间距。number 设置数字，此数字会与当前的字体尺寸相乘来设置行间距。length 设置固定的行间距。10px% 基于当前字体尺寸的百分比行间距。inherit 规定应该从父元素继承 line-height 属性的值。p.big &#123;line-height:200%;&#125;p.test &#123;line-height:10px;&#125;---8. 文字阴影(text-shadow)h-shadow 必需。水平阴影的位置。允许负值。v-shadow 必需。垂直阴影的位置。允许负值。blur 可选。模糊的距离。color 可选。阴影的颜色。参阅 CSS 颜色值。h1 &#123;color:white;text-shadow:2px -2px 3px #000;&#125;--- 9. 文本书写方向多语言支持(unicode-bidi)unicode-bidi 属性与 direction 属性一起使用，来设置或返回文本是否被重写，以便在同一文档中支持多种语言。如阿拉伯语言是从左到右书写的。使用该属性可以改变区域内文字书写方向normal 默认。不使用附加的嵌入层面。 embed 创建一个附加的嵌入层面。 bidi-override 创建一个附加的嵌入层面。重新排序取决于 direction 属性。 initial 设置该属性为它的默认值。请参阅 initialinherit 从父元素继承该属性。请参阅 inherit。div.ex1&#123; direction:rtl; unicode-bidi:bidi-override;&#125;---10. 文字垂直对齐(vertical-align)baseline 默认。元素放置在父元素的基线上。sub 垂直对齐文本的下标。super 垂直对齐文本的上标top 把元素的顶端与行中最高元素的顶端对齐text-top 把元素的顶端与父元素字体的顶端对齐middle 把此元素放置在父元素的中部。bottom 把元素的顶端与行中最低的元素的顶端对齐。text-bottom 把元素的底端与父元素字体的底端对齐。length 百分比% 使用 "line-height" 属性的百分比值来排列此元素。允许使用负值。inherit 规定应该从父元素继承 vertical-align 属性的值。--- 11. 文字空白处理(white-space)normal 默认。空白会被浏览器忽略。pre 空白会被浏览器保留。其行为方式类似 HTML 中的 &lt;pre&gt; 标签。nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br&gt; 标签为止。pre-wrap 保留空白符序列，但是正常地进行换行。pre-line 合并空白符序列，但是保留换行符。inherit 规定应该从父元素继承 white-space 属性的值---12. 单词间距(word-spacing)单词之间的间距，不同于letter-spacing(字母字符间距)normal 默认。定义单词间的标准空间。length 定义单词间的固定空间。inherit 规定应该从父元素继承 word-spacing 属性的值。 CSS 字体 Property 描述 font 在一个声明中设置所有的字体属性 font-family 指定文本的字体系列 font-size 指定文本的字体大小 font-style 指定文本的字体样式 font-variant 以小型大写字体或者正常字体显示文本。 font-weight 指定字体的粗细。 1234567891011121. 字体系列(font-family) font-family 属性应该设置几个字体名称作为一种"后备"机制，如果浏览器不支持第一种字体，他将尝试下一种字体。注意: 如果字体系列的名称超过一个字,多个汉字或多个单词，它必须用引号p.serif&#123;font-family:"Times New Roman",Times,serif;&#125;---2. 字体样式(font-style)normal italic斜体 oblique斜体p.oblique &#123;font-style:oblique;&#125;---3]]></content>
      <categories>
        <category>Study</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 双重检查加锁创建单例]]></title>
    <url>%2Farticle%2F65563eb2%2F</url>
    <content type="text"><![CDATA[本文介绍 Java 单例模式，主要包括： 饿汉式单例实现 懒汉式单例实现 线程安全加锁单例实现 双重检查加锁单例实现。 使用枚举实现单例 饿汉式顾名思义，就是很饿了，必须立刻创建。 饿汉式的特点就是空间换时间，在开始时就创建，而且只创建一次，节约了运行时间，保证了线程安全，缺点就是当你不需要用的时候也同样占用内存空间。 123public class TokenProvider &#123; private static TokenProvider sInst = new TokenProvider();&#125; 懒汉式体现了一种懒加载的思想，不需要时不创建，需要时才创建。 懒汉式的特点就是时间换空间，不需要时不创建，需要时才创建，节约了内存空间，缺点就是每次获取都需要判断，增加了运行时间，而且不加锁的懒汉式无法保证线程安全。 为什么呢？因为多线程访问时，假设 A 线程正在创建实体，此时 B 线程已经开始进行 sInst == null 的判空操作，此时 B 线程便会创建一个新的实体。 如何解决？请看下面线程安全加锁 1234567891011public class TokenProvider &#123; private static TokenProvider sInst; public static TokenProvider getInst() &#123; if (sInst == null) &#123; sInst = new TokenProvider(); &#125; return sInst; &#125;&#125; 线程安全加锁当使用懒汉式时，如果多线程同时创建单例，不加锁的话就会创建多个实体，无法保证线程安全，此时应在判空操作之前加锁，让其他线程在外面等待已经进入的线程完成操作，创建完成实体，这时第二个线程进入时，sInst 已经不为空可以直接返回，从而保证线程安全。 缺点也很明显，需要使用该单例时，所有线程都会首先进入同步代码块，在线程同步时会浪费很多时间，我们需要避免这种情况，请看下节双重检查加锁 12345678910111213public class TokenProvider &#123; private static TokenProvider sInst; public static TokenProvider getInst() &#123; synchronized (TokenProvider.class) &#123; if (sInst == null) &#123; sInst = new TokenProvider(); &#125; &#125; return sInst; &#125;&#125; 双重检查加锁为了解决上面的问题，我们需要避免每次都进行同步加锁，在最外层先进行判空操作，当实体已经创建时，后面的线程则不需要进入同步代码块等待，节约了时间。 volatile: 被 volatile 修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存,从而确保多个线程能正确的处理该变量。 123456789101112131415public class TokenProvider &#123; private volatile static TokenProvider sInst; public static TokenProvider getInst() &#123; if (sInst == null) &#123; synchronized (TokenProvider.class) &#123; if (sInst == null) &#123; sInst = new TokenProvider(); &#125; &#125; &#125; return sInst; &#125;&#125; 使用枚举实现单例简单说一下枚举，枚举类似类，一个枚举可以拥有成员变量，成员方法，构造方法。创建enum 时，编译器会自动为我们生成一个继承自 Java.lang.Enum 的类，构建实例的过程不是我们做的，一个 enum 的构造方法限制是 private 的，也就是不允许我们调用。单例中的每一个都是 static final 类型，下面代码的对比应该更清楚一些 123enum Type&#123; A,B,C,D;&#125; 等同于 123456class Type extends Enum&#123; public static final Type A; public static final Type B; public static final Type C; public static final Type D;&#125; 在枚举中我们明确了构造方法限制为私有，在我们访问枚举实例时会执行构造方法，同时每个枚举实例都是 static final 类型的，也就表明只能被实例化一次。在调用构造方法时，我们的单例被实例化。也就是说，因为 enum 中的实例被保证只会被实例化一次，所以我们的 INSTANCE 也被保证实例化一次。 12345678910111213public enum TokenProviderSingleton &#123; INSTANCE; private TokenProvider mInst; TokenProviderSingleton() &#123; mInst = new TokenProvider(); &#125; public TokenProvider getInst() &#123; return mInst; &#125;&#125;]]></content>
      <categories>
        <category>Study</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js 开发-1(基础)]]></title>
    <url>%2Farticle%2F22324dc8%2F</url>
    <content type="text"><![CDATA[Js 是弱类型动态语言 内建数据类型object (Func,Array,Date…)numberstringbooleannullundefined + : 只要有字符串就是字符串拼接- : 如果有字符串，转换为数字计算 == : 等于，类型相同，同 ===，类型不同，进行转换，null == undefined, number == string(转换为数字比较)，boolean == number(boolean转换为number),object == number/string(尝试将obj转为基本类型)=== : 严格等于，类型不同，返回 false，类型相同 null === null,undefined === undefind,NaN != NaN,new Object != new Object]]></content>
  </entry>
  <entry>
    <title><![CDATA[Retrofit开发-2-结合RxJava]]></title>
    <url>%2Farticle%2F36f21fa4%2F</url>
    <content type="text"><![CDATA[请先阅读 Retrofit 开发-1(OkHttp+Retrofit基本使用) 本文建立在对 RxJava2.x 和 Retrofit 基本熟悉的基础上，主要是在 Android 平台下对 RxJava + Retrifit 发送请求进行封装方法的探索。 准备首先你要确保在创建 Retrofit 时使用了 RcJava 的数据转换适配器。 依赖 1adapter_rxjava2 : 'com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0', 配置 12final Retrofit.Builder retrofitBuilder = new Retrofit.Builder();retrofitBuilder.addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(Schedulers.io())); 将数据中返回的全部类型改成 Observable 类型 12345@GET(GET_USER_INFO)Observable&lt;UserInfoDTOResponse&gt; getUser();@GET(GET_BABY_RELATION_LIST)Observable&lt;UserBabyRelationResp&gt; getBabyRelationList(@Query("babyId") Long babyId, @Query("limit") int limit, @Query("offset") Long offset); 请求数据这边熟悉了 RxJava 的相关使用和操作符之后用起来还算得心应手，就不做过多解释，贴两段代码感受一下。 封装的 Observer 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ObserverWrap&lt;T&gt; implements Observer&lt;T&gt; &#123; Context mContext; public ObserverWrap(Context context) &#123; mContext = context; &#125; public ObserverWrap() &#123; &#125; @Override public void onSubscribe(@NonNull Disposable d) &#123; L.eWithTread("Rx", "onSubscribe"); &#125; @Override public void onNext(@NonNull T t) &#123; L.eWithTread("Rx", "onNext -&gt; " + t.toString()); &#125; @Override public void onError(@NonNull Throwable e) &#123; L.eWithTread("Rx", "onError"); e.printStackTrace(); ToastUtil.show("请求失败"); if (e instanceof UnknownHostException) &#123; ToastUtil.show("网络不好"); &#125; onFinish(); &#125; @Override public void onComplete() &#123; L.eWithTread("Rx", "onComplete"); onFinish(); &#125; public void onFinish() &#123; if (mContext != null) &#123; ((BaoBaoBaseActivity) mContext).dismissLoadingDialog(); &#125; &#125;&#125; 获取用户信息 123456789101112131415// 调用RequestTest.getUserInfo() .subscribe(new ObserverWrap&lt;UserInfoDTOResponse.UserInfoDTO&gt;()); // 方法public static Observable&lt;UserInfoDTOResponse.UserInfoDTO&gt; getUserInfo() &#123; return ApiRequest.getService().getUser() .map(new Function&lt;UserInfoDTOResponse, UserInfoDTOResponse.UserInfoDTO&gt;() &#123; @Override public UserInfoDTOResponse.UserInfoDTO apply(@io.reactivex.annotations.NonNull UserInfoDTOResponse userInfoDTOResponse) throws Exception &#123; return userInfoDTOResponse.getData(); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread());&#125; 来一个复杂点的，获取一个列表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 调用RequestTest.getUserBabyRelationList(mActivity,baby) .subscribe(new ObserverWrap&lt;UserBabyRelation&gt;(mActivity)); // 方法public static Observable&lt;UserBabyRelation&gt; getUserBabyRelationList(final Context context, Baby baby) &#123; return ApiRequest.getService() .getBabyRelationList(baby.getBabyId(), 100, null) .subscribeOn(Schedulers.newThread()) .doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(@io.reactivex.annotations.NonNull Disposable disposable) throws Exception &#123; if(context instanceof BaoBaoBaseActivity)&#123; ((BaoBaoBaseActivity) context).showLoadingDialog(); &#125; &#125; &#125;) .subscribeOn(AndroidSchedulers.mainThread()) .filter(new Predicate&lt;UserBabyRelationResp&gt;() &#123; @Override public boolean test(@io.reactivex.annotations.NonNull UserBabyRelationResp userBabyRelationResp) throws Exception &#123; if (userBabyRelationResp.getStatus() == 200 &amp;&amp; isRespNotNull(userBabyRelationResp)) &#123; return true; &#125; else if (userBabyRelationResp.getStatus() != 200) &#123; if (userBabyRelationResp.getMessage() != null) &#123; ToastUtil.show(userBabyRelationResp.getMessage()); &#125; return false; &#125; return false; &#125; &#125;) .map(new Function&lt;UserBabyRelationResp, List&lt;UserBabyRelation&gt;&gt;() &#123; @Override public List&lt;UserBabyRelation&gt; apply(@io.reactivex.annotations.NonNull UserBabyRelationResp userBabyRelationResp) throws Exception &#123; return userBabyRelationResp.getData().getList(); &#125; &#125;) .flatMap(new Function&lt;List&lt;UserBabyRelation&gt;, ObservableSource&lt;UserBabyRelation&gt;&gt;() &#123; @Override public ObservableSource&lt;UserBabyRelation&gt; apply(@io.reactivex.annotations.NonNull List&lt;UserBabyRelation&gt; userBabyRelations) throws Exception &#123; return Observable.fromIterable(userBabyRelations); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread());&#125; 封装在 Android 平台下我们进行网络请求时，往往有些特殊的要求，总结如下，不断完善实现下列需求的方法，寻找一种更合适更简单的 Retrofit + RxJava 的网络请求架构。 请求开始时，显示 Dialog 提示用户等待，请求结束时消掉 Dialog 当 Activity 销毁时取消当前界面的请求。 当 Dialog 被认为 cancel 时，取消当前页面的请求。]]></content>
      <categories>
        <category>Android</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.x开发-3-源码分析]]></title>
    <url>%2Farticle%2F7ae7177b%2F</url>
    <content type="text"><![CDATA[知其然(知道轮子是怎么用的)，知其所以然(也要知道轮子是怎么造的)。 本文主要介绍 RxJava2.x 是如何通过流式API完成事件的传递和变换的，我们不是要全部把它弄的清清楚楚，那需要大量的时间和不断深入才可以，只是通过简单的例子来理解他的基本工作原理和主要功能。 看了很多文章，文章中会讲代理模式什么的，但我觉得更像是包装者模式，可能我理解有偏差😭，但是我觉得这样更好理解一些，我就先按照我的理解来写，后面不对再修正好了。 文中源码我会去掉错误检查和注解的部分代码，只保留核心代码，看起来更清晰。 简单的订阅看一个最最简单的例子 1234567891011121314151617181920212223Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); &#125;&#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(@NonNull Disposable d) &#123; log("onSubscribe"); &#125; @Override public void onNext(@NonNull Integer integer) &#123; log("onNext - &gt; " + integer); &#125; @Override public void onError(@NonNull Throwable e) &#123; log("onError"); &#125; @Override public void onComplete() &#123; log("onComplete"); &#125;&#125;); 这可能是最最基本的用法了，然后看一下源码，被观察者是如何向观察者发送数据的，首先是创建被观察者的过程。 123456// Observable.javapublic static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; ObjectHelper.requireNonNull(source, "source is null"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; ObservableOnSubscribe 是个接口，里面只有一个 subscribe() 方法，而我们就是在这个方法中进行事件的发送的。源码中可以看见实际上创建了一个 ObservableCreate 返回了，这个 ObservableCreate 其实是Observable 的子类，他是一个被观察者的具体实现，因为是内部自己创建的所以叫 ObservableCreate，我猜的。整个过程就创建了一个 ObservableCreate 并返回了回来，然后怎么就可以继续链式调用了，比如在上面的简单例子中，调用了 subscirbe() 方法，这也是最后将调用的方法。 我们就上面的简单例子来继续看 subscribe() 发生的一刻发生了什么，我去掉了各种检查错误的代码，只保留核心代码。 12345// Observable.javapublic final void subscribe(Observer&lt;? super T&gt; observer) &#123; subscribeActual(observer);&#125; 没错，就剩了一句了，subscribeActual() 是一个抽象方法，我们还要去看一下子类的具体实现，上面我们发现创建的 Observable 的子类是 ObservableCreate，那我们肯定是要去看这个子类了。 1234567891011121314151617// ObservableCreate.javapublic final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123; final ObservableOnSubscribe&lt;T&gt; source; public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) &#123; this.source = source; &#125; @Override protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); observer.onSubscribe(parent); source.subscribe(parent); &#125;&#125; 还是只看重点的，final ObservableOnSubscribe&lt;T&gt; source; 就是我们创建 Observable 时传进去的接口类，他只有一个 subscribe() 方法，再来仔细看一下 subscribeActual() 的实现，参数自然是要订阅过来的观察者 Observer，然后可以看到 Observer 被包装成了一个 CreateEmitter 发射器，我们知道他是用来发射事件的，那我们再看一眼发射器，不细看，他是一个静态内部类，看一下类声明即可 123static final class CreateEmitter&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements ObservableEmitter&lt;T&gt;, Disposable&#123;&#125; 接着上面的说，然后将发射器作为参数执行了 ObservableOnSubscribe 的 subscribe() 方法，然后会怎么样？自然是执行我们自己实现的 ObservableOnSubscribe 的 subscribe() 方法，开始使用发射器发送事件。其实我们是调用发射器，发射器调用他包装的 Observer 中对应的方法而已。 插一句，我们注意到当订阅发生时，首先执行了 observer.onSubscribe(parent); 方法，这也就是为啥观察者中的方法为什么会首先被调用，而 CreateEmitter 是实现了 Disposable 接口的，它可用来切断事件流。 总结，当观察者被订阅到被观察者时，被观察者被包装成一个发射器，调用 subscribe() 方法，使用发射器发射事件，被观察者收到事件。 操作符在实际应用过程中我们可能经历无数次操作符的变化，但是为了简化分析的过程，我们只看使用了一个操作符的例子，然后类推一下，其实多个变化也是一样的。 看一个使用操作符的场景 12345678910111213141516Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); &#125;&#125;).map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(@NonNull Integer integer) throws Exception &#123; return String.valueOf(integer); &#125;&#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; log("accept -&gt; " + s); &#125;&#125;); 在上个问题的基础上，我们以 map 操作符为例看一下，使用操作符的场景是如何建立连接，发送事件的，直接来看 map 方法，在 map 方法中创建了一个 ObservableMap 返回。 123456// Observable.javapublic final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) &#123; ObjectHelper.requireNonNull(mapper, "mapper is null"); return RxJavaPlugins.onAssembly(new ObservableMap&lt;T, R&gt;(this, mapper));&#125; 这个 ObservableMap 也是 Observer 的子类，也就是说它也是一个被观察者，参数是当前的被观察者和一个 Function，我们再来看一下 ObservableMap。 1234567891011121314151617181920212223242526272829public final class ObservableMap&lt;T, U&gt; extends AbstractObservableWithUpstream&lt;T, U&gt; &#123; final Function&lt;? super T, ? extends U&gt; function; public ObservableMap(ObservableSource&lt;T&gt; source, Function&lt;? super T, ? extends U&gt; function) &#123; super(source); this.function = function; &#125; @Override public void subscribeActual(Observer&lt;? super U&gt; t) &#123; source.subscribe(new MapObserver&lt;T, U&gt;(t, function)); &#125; static final class MapObserver&lt;T, U&gt; extends BasicFuseableObserver&lt;T, U&gt; &#123; final Function&lt;? super T, ? extends U&gt; mapper; MapObserver(Observer&lt;? super U&gt; actual, Function&lt;? super T, ? extends U&gt; mapper) &#123; super(actual); this.mapper = mapper; &#125; @Override public void onNext(T t) &#123; U v = mapper.apply(t) actual.onNext(v); &#125; &#125;&#125; ObservableMap 包装了原来的 SourceObservable，也接受了我们进行 map 操作的 Function。当订阅发生时，仍旧会调用 subscribeActual() 方法，在这个方法中，我们把最终的观察者包装成了一个 MapObserver，然后把这个 MapObserver 订阅到了 SourceObservable。结合上面简单订阅时的分析，此时，SourceObservable 便会将 MapObserver 包装成一个发射器，开始发射事件了。再关注一下 onNext() 方法，这里会先调用 Function 进行 map 操作。 总结：我们称最开始创建的被观察者为 SourceObservable，如果中间增加一个 map 操作符，此时创建并且返回了一个 ObservableMap 包装 SourceObservable 作为新的被观察者，此时链式调用的对外开放的就是 ObservableMap 了， 当最终的观察者，我们叫他 finalObserver，被订阅到 ObservableMap 时，会将finalObserver 包装成一个 MapObserver (这个 MapObserver 在调用 onNext() 时会继续调用他包装的 finalObserver 的 onNext() 方法和对应的 Function 方法) 订阅到 SourceObservable。然后开始第一节中的流程，也就是这个 MapOserver 将会被包装成一个发射器，开始发射事件，相比之前，此时调用 OnNext() 发送事件时，会首先调用 MapObserver 的 onNext(),然后继续调用它包装的 finalObserver 的 onNext(),不过在这之间会使用 Function 指定的操作对数据进行变换 再增加一个操作符会怎么样，其实就是是一样的流程了，只不过此时对外开放的 ObservalMap 扮演了 SourceObservable 的角色。 我在 RxJava2.x开发-2 (Schedulers) 这篇文章中介绍了如何在 RxJava2.x 中如何使用线程调度，和如何判断当前方法是运行在哪个线程，强烈建议去看一下才能更明白他是怎么样使用的，之前总结了怎么做，现在看一下为什么。 subscribeOn()在 RxJava2.x开发-2 (Schedulers) 总结了 subscribeOn() 用来切换上游线程，而且只有第一次有效，后面的调用只对 doOnSubscribe()/onSubscribe() 方法有效，但是为什么会是这样呢？ 看一个简单的例子 123456789101112Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); &#125;&#125;).subscribeOn(Schedulers.io()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer s) throws Exception &#123; log("accept -&gt; " + s); &#125; &#125;); 被观察者将会在 io 线程运行，为什么？看源码，仍旧是跟之前一样的模式，创建新的被观察者包装原来的观察者。 123456// Observable.javapublic final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; 我们还是将最开始的 Observable 称作 SourceObservable，subscribeOn() 创建并返回了 ObservableSubscribeOn 对象，没错它也是 Observable 的子类，是一个被观察者。我们再来看一下 ObservableSubscribeOn 类，创建时使用了原来的 SourceObservable 和一个线程调度器，先贴一下源代码，后面解释。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// ObservableSubscribeOn.javapublic final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; final Scheduler scheduler; public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) &#123; super(source); this.scheduler = scheduler; &#125; @Override public void subscribeActual(final Observer&lt;? super T&gt; s) &#123; final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s); s.onSubscribe(parent); parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); &#125; static final class SubscribeOnObserver&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements Observer&lt;T&gt;, Disposable &#123; final Observer&lt;? super T&gt; actual; SubscribeOnObserver(Observer&lt;? super T&gt; actual) &#123; this.actual = actual; &#125; @Override public void onNext(T t) &#123; actual.onNext(t); &#125; &#125; final class SubscribeTask implements Runnable &#123; private final SubscribeOnObserver&lt;T&gt; parent; SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123; this.parent = parent; &#125; @Override public void run() &#123; source.subscribe(parent); &#125; &#125;&#125; 重点就在 subscribeActual() 方法，我们知道当订阅发生时会调用 subscribeActual() 方法，此时，创建了一个 SubscribeOnObserver 包装了真正订阅的观察者，然后调用观察者 onSubscribe() 方法，这跟之前的介绍是一样的，不同的是将新创建的 SubscribeOnObserver 订阅到 SourceObservable 这个过程，做成了一个 Task，并使用了线程调度器去执行，此时会发生什么？还是之前说的 SubscribeOnObserver 会被包装成一个发射器开始发射事件，而此时因为使用了线程调度器执行，将会运行在指定的线程。 到现在大致清楚了 RxJava 如何使用 subscribeOn() 方法切换了被观察者所运行的线程，那为什么只有第一次有效果，后面不生效呢？为什么对于 doOnSubscribe()/onSubscibe() 又是生效的呢？ 虽然我们写代码时是从被观察者一路链式编程写下去的，但是其实真正开始执行的时机是，订阅开始的时候，即 subscribe() 调用的时候。而且按照我们之前的分析，subscribe() 方法会往上一层一层的调用上去，一直到最开始创建的被观察者，然后就开始发送事件。那我们调用两次 subscribeOn() 时，每次都会在里面生成新的被观察者，然后在指定线程调用 subscribe() 方法，所以开始的被观察者被调用的线程只取决了离他最近的那个 subscribeOn() ，因为在这里面会将发送最开始的被观察者的 subscribe() 方法 到指定线程运行，就好像假如 ObserableA 在 ThreadA 线程完成订阅，接着会继续调用里面包装的 ObserableB 在 ThreadB 线程完成订阅，其实最终的 ObserableB 还是在 ThreadB 线程完成订阅发送事件的。另外可以发现 doOnSubscribe()/onSubscibe() 是在发送到指定线程执行之前就执行的，所以他仍旧受到后面指定线程的影响，doOnSubscribe() 返回的也是一个 Observable，机制大致相同。 observarOn()调用 observarOn() 可以切换下游所在线程，每次调用都会切换线程。 类似上面的原理，仍旧生成了一个新的被观察者 ObservableObserveOn 1234567// Observable.javapublic final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); ObjectHelper.verifyPositive(bufferSize, "bufferSize"); return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));&#125; 订阅时，如果使用了 Schedulers.trampoline() 那么在当前线程，不需要在创建新的包装观察者，否则创建 ObserveOnObserver 包装原来的观察者。 1234567891011// ObserveOnObserver.java@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; if (scheduler instanceof TrampolineScheduler) &#123; source.subscribe(observer); &#125; else &#123; Scheduler.Worker w = scheduler.createWorker(); source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); &#125;&#125; 看一下 ObserveOnObserver 它实现了 Runnable 接口，在 run 方法中根据当前状态，分别调用它包装的观察者的对应方法。然后在相应的方法的最后都会调用 schedule(); 发送到指定线程操作，达到切换线程的目的，对应方法指的是 onNext/onComplete/onError 1234567891011121314151617181920212223242526272829303132333435363738394041static final class ObserveOnObserver&lt;T&gt; extends BasicIntQueueDisposable&lt;T&gt;implements Observer&lt;T&gt;, Runnable &#123; @Override public void onNext(T t) &#123; schedule(); &#125; @Override public void onError(Throwable t) &#123; if (done) &#123; RxJavaPlugins.onError(t); return; &#125; error = t; done = true; schedule(); &#125; @Override public void onComplete() &#123; if (done) &#123; return; &#125; done = true; schedule(); &#125; // 去指定线程执行 void schedule() &#123; if (getAndIncrement() == 0) &#123; worker.schedule(this); &#125; &#125; @Override public void run() &#123; // 会根据当前的状态队形执行被包装的观察者的相关方法。 if (outputFused) &#123; drainFused(); &#125; else &#123; drainNormal(); &#125; &#125;&#125; 总结说了这么多，我自己都感觉有点乱，心里明白但是写不出来的感觉真难受，还是文笔不行，想画个图表示一下，但画完感觉更复杂了。 在我看来，每次增加一个功能，比如操作符，或者线程切换，都会返回一个新的被观察者包装原来的被观察者，同时创建一个新的观察者，原来的观察者也会被包装进这个新的观察者，操作符会形成进行数据变换的被观察者和观察者，线程调度会形成线程切换的被观察者何观察者，形成一个一层一层包装的关系。 真正触发代码执行的是 subscribe() 方法，此时就会一层一层的调用更里面包装的被观察者的 subscribe() 方法，当最后一个被观察者，也就是我们最开始创建的那个的 subscribe() 方法被触发时，事件便开始发送，事件会一层一层往观察者里面传递，观察者又会调用它里面包装的观察者去处理传递这些事件，这过程中包含了事件的处理，变换，线程调度等。 感觉自己埋了个坑，说了这么多，说的也不是很明白，源码还是要自己看一下才更清楚一些。]]></content>
      <categories>
        <category>Android</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava2.x</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.x开发-2-Schedulers]]></title>
    <url>%2Farticle%2F8de84f35%2F</url>
    <content type="text"><![CDATA[本文主要介绍 RxJava2.x 强大的线程调度。 在 Android 开发中因为不允许阻塞主线程，所以所有的耗时请求都必须全部放在子线程来做，然后再去主线程更新UI，关于主线程和子线程的通信其实异常复杂，好在Android 给我们提供了 AsyncTask，Handler 等方式来简化这一过程。使用 RxJava 会让切换线程变得更简单。 文中部分描述可能有些混乱，为了更好的看出在哪个线程调用，我会在子线程中执行我的代码，我就称它为 MyThread，也就是调用代码所在的线程。io线程，计算线程，newThread线程就是我对 RxJava 几种内置线程的简称。上游线程就是被观察者所在的线程，下游线程是观察者所在线程，调用线程就是我调用代码的线程 MyThread。这里简单理一下，虽然还是有点乱。 Schedulers 种类RxJava 根据不同应用场景内置了多种线程调度器，可以大多数场景的后台操作需求。 Schedulers Desc Schedulers.computation() 用于计算任务，如事件循环或和回调处理，不要用于IO操作，默认线程数等于处理器的数量 Schedulers.io() 用于IO密集型任务，如异步阻塞IO操作，这个调度器的线程池会根据需要增长；对于普通的计算任务，请使用Schedulers.computation() Schedulers.newThread() 为每个任务创建一个新线程 Schedulers.trampoline() 当其它排队的任务完成后，在当前线程排队开始执行 Schedulers.from(executor) 使用指定的 Executor 作为调度器 AndroidSchedulers.mainThread() Android 主线程 AndroidSchedulers.from(looper) 从 Looper 创建 线程调度最为关键的就是两个方法 subscribeOn() 和 observeOn()，从代码的链式调用可以简单的总结为： 上游 Observable 总是默认运行在被调用的线程当中，即你在哪个线程调用就会运行在哪个线程。 下游 Onserver 总是默认运行在上游所在线程中(当然如果你没有切换上游的线程，那么下游也会运行在调用的线程中)，除非使用 observeOn() 进行线程的切换。 subscribeOn() 用来声明上游事件发送时的所在线程，当调用多次 subscribeOn() 时，上游会运行在最早的一次调用声明的线程中。当然也不是说多次的调用是完全没效果的，后面会细说。 observeOn() 用来声明下游观察者所在线程，每次调用 observeOn() 都会发生线程切换，此次调用直到下次切换线程中间的过程中的操作运行在此次调用指定的线程中。 12345678910111213141516171819202122232425262728293031323334353637log("start");Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exceptio log("Observable"); e.onNext(10); &#125;&#125;) // 第1次调用subscribeOn， Observable 将运行在io线程 .subscribeOn(Schedulers.io()) // io 线程，下游总是会默认运行在上游所在线程中 .filter(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(@NonNull Integer integer) throws Exception &#123; log("filter1"); return true; &#125; &#125;) // 第2次调用subscribeOn，不会生效 .subscribeOn(Schedulers.newThread()) // 第1次调用observeOn，切换线程，filter操作运行在主线程 .observeOn(AndroidSchedulers.mainThread()) .filter(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(@NonNull Integer integer) throws Exception &#123; log("filter2"); return true; &#125; &#125;) // 第2次调用observeOn，切换线程到子线程 .observeOn(Schedulers.newThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; log("subscribe = " + integer); &#125; &#125;); 输出结果,我整个代码运行在一个我自己的子线程中，我就叫他 MyThread 好了，方便描述 12345[ThreadName:pool-13-thread-1] start // 因为在 MyThread 子线程调用[ThreadName:RxCachedThreadScheduler-1] Observable // io[ThreadName:RxCachedThreadScheduler-1] filter1 // io.由于没有切换线程，默认运行在上游线程中。[ThreadName:main] filter2 // 切换到主线程[ThreadName:RxNewThreadScheduler-2] subscribe = 10 // 切换到 newThread 线程 doOnSubscribe()当调用多次 subscribeOn() 方法时，上游将运行在最早调用指定的线程中，这个没什么问题，对于下游的 doOnNext()，doOnComplete() 来说，遵循上面说的规则，除非你使用 observerOn() 切换线程，不然运行在上游线程中。 但是 doOnSubscribe() 有点不一样，除非他后面有调用 subscribeOn() 切换线程，否则他默认运行在执行 Observable.subcribe() 语句的线程中。 其实这里的 doXXX() 方法和上一篇文章中观察者中的几个方法是一一对应的，在观察者的中 onSubscribe() 方法也有同样的属性，他在订阅发生的一瞬间首先执行，并且它运行在订阅发生的线程。其他几个方法也是一样，除非你使用 observerOn() 切换线程，不然运行在上游线程中。 12345678910111213141516171819202122232425262728293031323334353637383940log("start");Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; log("Observable"); e.onNext(10); e.onComplete(); &#125;&#125;) // 计算线程，因此 Observable 将会运行在计算线程 .subscribeOn(Schedulers.computation()) .observeOn(Schedulers.newThread()) .doOnNext(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; log("doOnNext"); &#125; &#125;) .doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(@NonNull Disposable disposable) throws Exception &#123; // 后面没有调用 subscribeOn() 因此将运行在 Observable.subscribe() 执行的线程 log("doOnSubscribe"); &#125; &#125;) .doOnComplete(new Action() &#123; @Override public void run() throws Exception &#123; log("doOnComplete"); &#125; &#125;) .observeOn(Schedulers.newThread()) // doOnSubscribe() 运行的线程取决于在哪里执行订阅 // 除非后面有调用 subscribeOn() 进行线程的切换 .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; log("subscribe = " + integer); &#125; &#125;); 输出结果，我整个代码运行在一个我自己的子线程中，我就叫他 MyThread 好了，方便描述 1234567891011// MyThread 子线程运行[ThreadName:pool-16-thread-1] start // 因为 subscribe() 方法也同样运行在 MyThread 子线程，所以 doSunscribe() 页运行在 MyThread 子线程[ThreadName:pool-16-thread-1] doOnSubscribe // 由于调用 subscribeOn(Schedulers.computation()) 所以上游运行在计算线程[ThreadName:RxComputationThreadPool-1] Observable // 遵循上面说的规则，运行在 observerOn() 指定的 newThread 中。[ThreadName:RxNewThreadScheduler-1] doOnNext// 同上 [ThreadName:RxNewThreadScheduler-1] doOnComplete [ThreadName:RxNewThreadScheduler-2] subscribe = 10 切换 doOnSubscribe() 所在线程再换一个更改 doOnSubscribe() 运行线程的例子，跟上面不同的是在 doOnSubscribe() 之后我们使用 subscribeOn(Schedulers.io()) 切换了线程，因此 doOnSubscribe() 将运行在 io 线程。 123456789101112131415161718192021222324252627282930log("start");Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; log("Observable"); e.onNext(10); e.onComplete(); &#125;&#125;) // 计算线程，因此 Observable 将会运行在计算线程 .subscribeOn(Schedulers.computation()) .observeOn(Schedulers.newThread()) .doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(@NonNull Disposable disposable) throws Exception &#123; // doOnSubscribe 之后第一次调用 subscribeOn(Schedulers.io()) 切换到了io线程 // 因此 doOnSubscribe 运行在 io 线程。 log("doOnSubscribe"); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(Schedulers.newThread()) // doOnSubscribe() 运行的线程取决于在哪里执行订阅 // 除非后面有调用 subscribeOn() 进行线程的切换 .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; log("subscribe = " + integer); &#125; &#125;); 运行结果 12345678// MyThread[ThreadName:pool-16-thread-1] start// 由于后面调用了 subscribeOn(io) 因此运行在 io 线程[ThreadName:RxCachedThreadScheduler-1] doOnSubscribe// 运行在上游线程中[ThreadName:RxComputationThreadPool-1] Observable// 使用 observeOn(Schedulers.newThread()) 切换到了 newThread[ThreadName:RxNewThreadScheduler-2] subscribe = 10 举个🌰有啥用呢？模拟一个场景，1⃣️上游发送网络请求，要求在子线程执行，2⃣️ 但是请求刚开始的时候我们要显示 dialog 提示用户等待，需要在主线程执行，3⃣️ 完成之后又要在子线程处理数据，4⃣️ 然后去主线程更新UI。 123456789101112131415161718192021222324252627282930313233343536log("开始操作，为了搞复杂点，我在我自己创建子线程操作");Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; log("子线程发起网络请求"); e.onNext(10); e.onComplete(); &#125;&#125;) // 在子线程发起请求 .subscribeOn(Schedulers.newThread()) .doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(@NonNull Disposable disposable) throws Exception &#123; log("请求之前，主线程弹起dialog"); &#125; &#125;) // 切换到主线程弹 dialog .subscribeOn(AndroidSchedulers.mainThread()) // 切换到计算线程 处理数据 .observeOn(Schedulers.computation()) .filter(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(@NonNull Integer integer) throws Exception &#123; log("计算线程处理数据"); return true; &#125; &#125;) // 切换到主线程更新UI .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; log("主线程更新UI"); &#125; &#125;); 输出结果 12345[ThreadName:pool-13-thread-1] 开始操作，为了搞复杂点，我在我自己创建子线程操作[ThreadName:main] 请求之前，主线程弹起dialog[ThreadName:RxNewThreadScheduler-1] 子线程发起网络请求[ThreadName:RxComputationThreadPool-1] 计算线程处理数据[ThreadName:main] 主线程更新UI 总之，如何判断到底在什么线程运行综上所述，总结几条公式，其实就是把上面说的再说一遍： 几个概念 ： 上游，上游指的是 数据发射源，Observable 中的代码。 下游，下游指的是 操作符方法，Observable 调用方法，观察者中的方法 调用线程，我在哪个线程运行该代码，这个线程就是调用线程。 1⃣️、上游总是默认运行在被 调用线程 当中，即你在哪个线程调用就会运行在哪个线程。 2⃣️、 下游总是默认运行在上游所在线程中 (当然如果你没有切换上游的线程，那么下游也会运行在 调用线程 中) ，除非使用 observeOn() 进行线程的切换。 3⃣️、 subscribeOn() 用来声明上游事件发送时的所在线程，当调用多次 subscribeOn() 时，上游会运行在 最早 的一次调用声明的线程中。 4⃣️、 observeOn() 用来声明下游观察者所在线程，每次调用 observeOn() 都会发生线程切换，此次切换 到 下次切换 之间运行在 此次切换 的线程中。 5⃣️、 对于 doOnNext()/onNext()，doOnComplete()/onComplete()，doOnError()/onError() 几个方法 (前者是 被观察者 调用的方法，后者是 观察者 接口里面的对应方法) ，他们都和操作符一样，遵循 2⃣️ 中的规则。 6⃣️、对于 doOnSubscribe()/onSubscribe() 方法 (前者是 被观察者 调用的方法，后者是 观察者 接口里面的对应方法) 来说，如果他后面有调用 subscribeOn() 切换线程，那么它运行在切换的线程，否则他默认运行在执行 Observable.subcribe() 语句的线程中。 为什么是这样上面只是总结一些规则，一个方法是运行在什么线程，使用上面的规则可以更简单判断出来，我们其实是在通过一些表象来总结如何判断，那为什么会是这样的规则呢？我现在也还没研究明白，，，，，，所以，待办 ～ ok了～关于 RxJava2.x 的一些源码分析见RxJava2.x开发 (源码解析)]]></content>
      <categories>
        <category>Android</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava2.x</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[坚持]]></title>
    <url>%2Farticle%2F927e4523%2F</url>
    <content type="text"><![CDATA[2017年7月2日，早9点10分，周日，天气不错，稍微有点热。 今天周日，转眼一周过来了，这周都尽量能在早上7点到8点起床到公司，算是坚持下来了，以后继续，然后把时间控制在7点多，现在起床之后墨迹的时间太多了，7点多睁眼，都要快9点钟才有状态。 这周主要看了一下 Kotlin 的一点内容，然后 Retrofit 网络请求，简单的开始了解了一下，后面会继续深入，今天重点看 RxJava，加油 ！ TODO LIST : Kotlin 剩余部分继续推进。 OkHttp + Retrofit + RxJava 还是要继续了解。 看了几篇面经，EventBus，Glide，OkHttp，Retrofit 源码看一下原理。 博客继续整理。 更多…]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.x开发-1-基础]]></title>
    <url>%2Farticle%2F3251baff%2F</url>
    <content type="text"><![CDATA[开始总结记录 RxJava 的相关内容，本文中所有涉及 RxJava 的地方均指 Rxjava2.0。 本文主要以 Observable 和 Flowable 为例介绍如何创建被观察者和观察者，并连接他们。 RxJava https://github.com/ReactiveX/RxJava RxJava https://github.com/ReactiveX/RxAndroid 推荐文章记录一下看过的几篇还不错的关于 RxJava 的文章，感谢他们的总结和分享。 RxJava1 - 《 给 Android 开发者的 RxJava 详解 》- 扔物线)，这篇文章是对 RxJava1 的讲解，很不错，图文并茂，看了一遍之后仍旧有些疑惑，建议多看几遍，很多关于原理的介绍可以加强对 Rx 的理解。 RxJava2 - 《 给初学者的RxJava2.0教程(一) 》- 掘金 以及 RxJava2 - 《 给初学者的RxJava2.0教程(二) 》- 掘金，特点就是作者使用水管上游下游的描述方式，简化了对观察者模式和事件发送的理解，浅显易懂，也很全面，适合入门。 《 RxJava2.0 你不知道的事》- 简书 是对 RxJava1.x 和 RxJava2.x 的对比，文章中对 2.x 的部分 api，进行了列举，对比起来看就清晰多了，另外很好的解释了背压的问题，受益匪浅。 《关于RxJava最友好的文章》- 知乎 RxJava2.x APi 文档 我的理解上面推荐的文章中对 RxJava 的相关原理都做了部分说明，我就不做过多描述，说一下我的一些理解吧。 RxJava 最关键的两个点就是 观察者模式 和 异步。在 RxJava 中被观察者作为事件的产生方，是 主动 的，是整个事件流程的起点。观察者作为事件的处理方，是 被动 的，是整个事件流程的终点。在起点和终点之间，即事件传递的过程中是可以被加工，过滤，转换，合并等等方式处理的。 Observable，被观察者，被订阅者，可被观察的，他是数据和事件发射的源，他在 RxJava 中是有多种实现方式，这里不是说的哪个类，而是一种泛指。 Observer／Subscriber，观察者，订阅者，他是事件接受者。 整体来看，可以理解为一条事件流，被观察者在上游发送事件，观察者在下游接受事件，中游会有很多针对事件的处理和变换，这样理解更简单一些，也更有助于理解背压(Backpressure)的存在。为了更好的理解，避免叙述的混乱，文章中我会用 上游 和 下游 这样的描述来代替 被观察者 和 观察者。 使用 Observable创建一个最简单的 Observable，发送 Integer 类型的数据，RxJava 有很多创建 Observable 的简单方法，我们暂时就使用最原始的那种，方便理解。 ObservableEmitter 继承 Emitter，是一个数据发射器，用来向观察者发送数据。 123456789101112// 创建 ObservableObservable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; // 发射数据 e.onNext(1); e.onNext(2); // 结束发送 e.onComplete(); e.onNext(3); &#125;&#125;); 创建一个 Observer，接受数据并打印。 123456789101112131415161718Observer&lt;Integer&gt; observer = new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(@NonNull Disposable d) &#123; log("onSubscribe"); &#125; @Override public void onNext(@NonNull Integer integer) &#123; log("onNext == &gt; " + integer); &#125; @Override public void onError(@NonNull Throwable e) &#123; log("onError"); &#125; @Override public void onComplete() &#123; log("onComplete"); &#125;&#125;; 实现订阅，查看结果。 123456789observable.subscribe(observer);// 结果如下，3 不会被打印---------------[ThreadName:pool-13-thread-1] onSubscribe[ThreadName:pool-13-thread-1] onNext == &gt; 1[ThreadName:pool-13-thread-1] onNext == &gt; 2[ThreadName:pool-13-thread-1] onComplete--------------- 这样我们就实现了一个简单的订阅流程，完成了数据的传递，总结以下要点： ObservableEmitter 继承 Emitter，是一个发射器，用来向下游发送事件，它可以发送如下3种事件，也对应下游订阅者的相关方法。 12345public interface Emitter&lt;T&gt; &#123; void onNext(@NonNull T value); void onError(@NonNull Throwable error); void onComplete();&#125; 上游和下游的所有方法都默认运行在当前所在线程内，如上运行结果，我在子线程运行则所有方法会在子线程调用。 订阅发生在 observable.subscribe(observer); 时，此时上游才开始发送事件，并且 onSubscribe() 方法会在开始订阅时首先执行。 上游可以发送无数个 onNext(T t) 事件，下游都可以接受到。 当上游发送 onComplete() 事件之后，上游的事件会继续发送，但是下游在接受到 onCompelete() 事件之后就会切换事件流，不会在接受后续的事件，因此发送多个 onComplete() 虽然不会导致程序 crash，但是是无意义的。 当上游发送 onError() 事件之后，上游的事件会继续发送，但是下游在接受到 onError() 事件之后就会切换事件流，不会在接受后续的事件，当你发送第二个 onError() 事件时会导致程序 crash。 发送 onComplete() 和 onError() 事件不是必须的。 onComplete() 和 onError() 是唯一且互斥的，你不能发送多个 onComplete() 或多个 onError()，也不能不能发送一个 onCompelete() 事件再发送 onError()，反过来也是。 中断事件流Disposable 对象可用用来切断事件流，在 onSubscribe() 被调用时会返回 Disposable 对象，我们在获取到数字 4 时切断事件流。将上面的代码稍微简化一下 12345678910111213141516171819202122232425262728293031323334353637// 创建 ObservableObservable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; // 发射数据 e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onNext(5); // 结束发送 e.onComplete(); e.onNext(6); &#125;&#125;).subscribe(new Observer&lt;Integer&gt;() &#123; Disposable mDisposable; @Override public void onSubscribe(@NonNull Disposable d) &#123; mDisposable = d; log("onSubscribe"); &#125; @Override public void onNext(@NonNull Integer integer) &#123; log("onNext == &gt; " + integer); if (integer == 4) &#123; mDisposable.dispose(); &#125; &#125; @Override public void onError(@NonNull Throwable e) &#123; log("onError"); &#125; @Override public void onComplete() &#123; log("onComplete"); &#125;&#125;); 结果为 12345[ThreadName:pool-13-thread-1] onSubscribe[ThreadName:pool-13-thread-1] onNext == &gt; 1[ThreadName:pool-13-thread-1] onNext == &gt; 2[ThreadName:pool-13-thread-1] onNext == &gt; 3[ThreadName:pool-13-thread-1] onNext == &gt; 4 其他订阅方法在实际应用过程中我们可能并不关注下游所有的接受事件的方法，因此 RxJava 提供了多种订阅方式来简化订阅过程。 这里说一下 Action 和 Consumer，与 RxJava1.x 不同，没有使用 ActionN 这种命名方式。 Action 是无参无返回值的接口，它可以用来替代类似 onComplete() 这种无参无返回值值的方法。 123public interface Action &#123; void run() throws Exception;&#125; Consumer 是单个参数无返回值的接口，它可以用来代替类似 onSubscribe(@NonNull Disposable d)，onNext(@NonNull Integer integer)，onError(@NonNull Throwable e) 这类单个参数无返回值的方法。 123public interface Consumer&lt;T&gt; &#123; void accept(@NonNull T t) throws Exception;&#125; 重载的订阅方法，除了以 Observer 的方式订阅之外，其他方法都返回 Disposable 对象用来中断事件流。 1234567891011121314151617// 下游不关注上游的任何事件public final Disposable subscribe()// 观察者public final void subscribe(Observer&lt;? super T&gt; observer)// 只关注 onNext() 事件public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) // 只关注 onNext() onError() public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError)// 只关注 onNext() onError() onComplete()public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError,Action onComplete)// 只关注 onNext() onError() onComplete() onSubscribe()public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) 使用只关注 onNext() 事件的订阅方法实现订阅。 123456789101112131415Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; // 发射数据 e.onNext(1); e.onNext(2); // 结束发送 e.onComplete(); &#125;&#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; log("use Consumer onNext = &gt; " + integer); &#125;&#125;); 对 Observable 的介绍相对详细，下面的介绍会简单一些，因为很多相似的地方，就不再赘述了。 使用 FlowableFlowable 与 Observable 的区别就是实现了 背压(Backpressure) 的管理，讲真，我对背压这个概念也理解的不是很全面，概括的讲背压就是上游发送的事件太多，下游处理事件的速度太慢，导致上游事件堆积，此时如何处理堆积的事件，就是背压处理的策略。 背压处理策略，在 RxJava2.x 中 Observable 不再支持背压，需要支持背压时需要使用 Flowable 创建被观察者，并要求明确指定背压处理策略。 关于 Flowable 和 Backpressure 的内容后面作单独研究，这里不展开。 123456public enum BackpressureStrategy &#123; ERROR, BUFFER, DROP, LATEST&#125; 实现一个订阅，支持背压时，需要在下游调用 request(long n) 来向上游请求，自己要多少数据，请求多少数据上游就会发多少数据过来，如下实例中，只会获取到一次事件。 123456789101112131415161718192021222324252627Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull FlowableEmitter&lt;Integer&gt; e) throws Exception &#123; for (int i = 0; i &lt; 10; i++) &#123; e.onNext(i); &#125; e.onComplete(); &#125;&#125;, BackpressureStrategy.BUFFER).subscribe(new FlowableSubscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; log("onSubscribe"); s.request(1); &#125; @Override public void onNext(Integer integer) &#123; log("onNext == &gt; " + integer); &#125; @Override public void onError(Throwable t) &#123; log("onError"); &#125; @Override public void onComplete() &#123; log("onComplete"); &#125;&#125;); 中断事件流Subscription 类似于 Observable 中的 Disposable，可以用来中断事件流，不同的是需要使用 cancel() 方法，另外有另一个 request(long n) 方法用来向上游请求数据。 1234public interface Subscription &#123; public void request(long n); public void cancel();&#125; 如下，使用 Subscription 中断事件。 12345678910111213141516171819202122232425262728Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull FlowableEmitter&lt;Integer&gt; e) throws Exception &#123; for (int i = 0; i &lt; 10; i++) &#123; e.onNext(i); &#125; e.onComplete(); &#125;&#125;, BackpressureStrategy.BUFFER).subscribe(new FlowableSubscriber&lt;Integer&gt;() &#123; Subscription mSubscription; @Override public void onSubscribe(Subscription s) &#123; log("onSubscribe"); mSubscription = s; s.request(1); &#125; @Override public void onNext(Integer integer) &#123; log("onNext == &gt; " + integer); mSubscription.request(5); if (integer == 5) &#123; mSubscription.cancel(); &#125; &#125; // ... &#125;); 关于 request下游请求多少就会收到多少事件，但是不会阻塞上游事件发送的过程，上游的事件会一直发，但是下游没请求的话接受不到事件。 request(long n) 中的数量是会累加的，累加的数量就是请求的总量，如果请求的总量超过了发送的总量，则上游事件会被全部接受到，但是不会多出来。 如下实例中，总共请求了 1 + 2 + 2 = 5 次事件，因此只收到了 5 次事件，但是上游的事件发送并没有停止。 1234567891011121314151617181920212223242526Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull FlowableEmitter&lt;Integer&gt; e) throws Exception &#123; for (int i = 0; i &lt; 10; i++) &#123; log("send next " + i); e.onNext(i); &#125; e.onComplete(); &#125;&#125;, BackpressureStrategy.BUFFER).subscribe(new FlowableSubscriber&lt;Integer&gt;() &#123; Subscription mSubscription; @Override public void onSubscribe(Subscription s) &#123; log("onSubscribe"); mSubscription = s; s.request(1); &#125; @Override public void onNext(Integer integer) &#123; log("onNext == &gt; " + integer); if(integer == 0 || integer == 1) &#123; mSubscription.request(2); &#125; &#125; // ...&#125;); 输出结果 12345678910111213141516[ThreadName:pool-13-thread-1] onSubscribe[ThreadName:pool-13-thread-1] send next 0[ThreadName:pool-13-thread-1] onNext == &gt; 0[ThreadName:pool-13-thread-1] send next 1[ThreadName:pool-13-thread-1] onNext == &gt; 1[ThreadName:pool-13-thread-1] send next 2[ThreadName:pool-13-thread-1] onNext == &gt; 2[ThreadName:pool-13-thread-1] send next 3[ThreadName:pool-13-thread-1] onNext == &gt; 3[ThreadName:pool-13-thread-1] send next 4[ThreadName:pool-13-thread-1] onNext == &gt; 4[ThreadName:pool-13-thread-1] send next 5[ThreadName:pool-13-thread-1] send next 6[ThreadName:pool-13-thread-1] send next 7[ThreadName:pool-13-thread-1] send next 8[ThreadName:pool-13-thread-1] send next 9 其他订阅方法Flowable 跟 Observable 一样对订阅操作也有很多重载方法，可以参照Obervable#其他订阅方法。 更多被观察者实现我现在还不太清楚它们之间的关系，就先列举一下 API，后面有机会再仔细看看 Maybe 123456789101112131415161718Maybe.create(new MaybeOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull MaybeEmitter&lt;Integer&gt; e) throws Exception &#123; &#125;&#125;).subscribe(new MaybeObserver&lt;Integer&gt;() &#123; @Override public void onSubscribe(@NonNull Disposable d) &#123; &#125; @Override public void onSuccess(@NonNull Integer integer) &#123; &#125; @Override public void onError(@NonNull Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125;&#125;); Completable 123456789101112131415Completable.create(new CompletableOnSubscribe() &#123; @Override public void subscribe(@NonNull CompletableEmitter e) throws Exception &#123; &#125;&#125;).subscribe(new CompletableObserver() &#123; @Override public void onSubscribe(@NonNull Disposable d) &#123; &#125; @Override public void onComplete() &#123; &#125; @Override public void onError(@NonNull Throwable e) &#123; &#125;&#125;); Single 123456789101112131415Single.create(new SingleOnSubscribe&lt;Object&gt;() &#123; @Override public void subscribe(@NonNull SingleEmitter&lt;Object&gt; e) throws Exception &#123; &#125;&#125;).subscribe(new SingleObserver&lt;Object&gt;() &#123; @Override public void onSubscribe(@NonNull Disposable d) &#123; &#125; @Override public void onSuccess(@NonNull Object o) &#123; &#125; @Override public void onError(@NonNull Throwable e) &#123; &#125;&#125;);]]></content>
      <categories>
        <category>Android</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava2.x</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit开发-1-基础]]></title>
    <url>%2Farticle%2Fe57450c6%2F</url>
    <content type="text"><![CDATA[Retrofit 本文介绍 OkHttp 和 Retrofit 的基本使用，包括： 创建和配置 OkHttpClient 创建和配置 Retrofit 如何使用 Retrofit 定义接口发起请求 关于 Retrofit 中 method，path，query param，body，Header 注解声明的介绍。 添加依赖1234567891011121314// 网络请求okhttp3 : 'com.squareup.okhttp3:okhttp:3.4.2',// 单元测试，未用okhttp3Mockwebserver : 'com.squareup.okhttp3:mockwebserver:3.4.2',// 调试工具类库stetho : 'com.facebook.stetho:stetho:1.4.2',stetho_okhttp3 : 'com.facebook.stetho:stetho-okhttp3:1.4.2',// json解析gson : 'com.google.code.gson:gson:2.6.1',// retrofit 2.0retrofit : 'com.squareup.retrofit2:retrofit:2.3.0',converter_gson : 'com.squareup.retrofit2:converter-gson:2.1.0',// 日志打印logging_interceptor : 'com.squareup.okhttp3:logging-interceptor:3.8.0', 创建 OkHttpRetrofit 是对 OkHttp 的封装，提供了使用注解更简单的构建各种请求，配置各种参数的方式。本质发起网络请求的还是 OkHttp，但 Retrofit 让这一操作更加的简单优雅。 创建一个 OkHttpClent 并进行简单配置 12345678910111213141516171819202122232425262728/** * 创建 OkHttpClient * * @return OkHttpClient */private OkHttpClient buildOkHttpClient() &#123; OkHttpClient.Builder okHttpBuilder = new OkHttpClient.Builder(); // 连接超时 okHttpBuilder.connectTimeout(5 * 1000, TimeUnit.MILLISECONDS); // 读超时 okHttpBuilder.readTimeout(5 * 1000, TimeUnit.MILLISECONDS); // 写超时 okHttpBuilder.writeTimeout(5 * 1000, TimeUnit.MILLISECONDS); // 清除 interceptors okHttpBuilder.interceptors().clear(); okHttpBuilder.networkInterceptors().clear(); // 自定义 Interceptor，用来添加全局 Header okHttpBuilder.addNetworkInterceptor(new HeaderInterceptor()); // 自定义 Interceptor，进行日志打印，扩展自 HttpLoggingInterceptor okHttpBuilder.addNetworkInterceptor(new LogInterceptor(LogInterceptor.Level.BOTH)); // 失败后重试 okHttpBuilder.retryOnConnectionFailure(true); // face book 调试框架 okHttpBuilder.addNetworkInterceptor(new StethoInterceptor()); // token校验，返回 403 时 okHttpBuilder.authenticator(new TokenAuthenticator()); return okHttpBuilder.build();&#125; 创建 RetrofitOkHttp 只负责发起网络请求，维护网络连接等操作，而 Retrofit 帮我们将网络传输的数据转换为可用的 model 对象，并且提供简单的数据处理方式。 配置 CallAdapterFactory 为 RxJava2CallAdapterFactory.createWithScheduler(Schedulers.io()) 用来将返回的数据转换为 RxJava 的 Observable 对象，但是本文还没涉及到 RxJava 的部分。 配置 ConverterFactory 为 GsonConverterFactory.create(new Gson()) 用来使用 GSON 将网络数据序列化为可用对象。 ps：baseUrl 要求以 / 结尾，而请求的 path 要求不以 / 开头，也就是说我们需要类似 https://www.baidu.com/ 的形式。 12345678910111213141516171819/** * 创建 retrofit * * @param okHttpClient client * @return retrofit */private Retrofit buildRetrofit(OkHttpClient okHttpClient) &#123; final Retrofit.Builder retrofitBuilder = new Retrofit.Builder(); // client retrofitBuilder.client(okHttpClient); // baseUrl retrofitBuilder.baseUrl(BASE_URL); // rxJava 调用 adapter retrofitBuilder.addCallAdapterFactory( RxJava2CallAdapterFactory.createWithScheduler(Schedulers.io())); // 数据转换 adapter retrofitBuilder.addConverterFactory(GsonConverterFactory.create(new Gson())); return retrofitBuilder.build();&#125; 创建 api 服务接口创建接口类，使用注解声明网络请求的方法和相关参数，这里只是一个简单的例子，更多参数和配置将在后面说明，如： 1234567public interface ApiService &#123; String GET_USER_INFO = "api/v1/user/info"; @GET(GET_USER_INFO) Call&lt;UserInfoDTOResponse&gt; getUser(@Header("Authorization") String auth);&#125; 使用 Retrofit 初始化 ApiService，获取到 ApiService 的实例之后就可以使用该实例发起请求。 我使用 ApiRequest 持有 ApiService 的实例，同时 ApiRequest 是一个单例，作为发起网络请求的管理者。 1234private void createService() &#123; Retrofit retrofit = buildRetrofit(buildOkHttpClient()); mApiService = retrofit.create(ApiService.class);&#125; 发起请求 12345678910111213141516171819public static void getUserInfo() &#123; // 从单例中获取 ApiService ApiService service = ApiRequest.getService(); // 创建请求 Call&lt;UserInfoDTOResponse&gt; userCall = service.getUser(); // 发起请求 userCall.enqueue(new Callback&lt;UserInfoDTOResponse&gt;() &#123; @Override public void onResponse(@NonNull Call&lt;UserInfoDTOResponse&gt; call,@NonNull Response&lt;UserInfoDTOResponse&gt; response) &#123; UserInfoDTOResponse body = response.body(); if (body != null &amp;&amp; body.getData() != null) &#123; L.e(TAG, body.getData().toString()); &#125; &#125; @Override public void onFailure(@NonNull Call&lt;UserInfoDTOResponse&gt; call,@NonNull Throwable t) &#123; &#125; &#125;);&#125; 下面对 Retrofit 中 method,path,qurey,body,header几个部分分别说明。 MethodRetrofit 支持 GET，POST，PUT，DELETE，HEAD，OPTION 等请求方式，并有对应的注解。 12345@GET(GET_USER_INFO)Call&lt;UserInfoDTOResponse&gt; getUser();@DELETE(DELETE_RM_BABY)Call&lt;BaseResponse&gt; deleteBaby(@Path(PATH_BABY_ID) Long babyId); PATH请求路径，请求路径中可以包含参数，并在参数中使用 @PATH 注解来动态改变路径，比如路径 api/v1/user/{id}，使用注解 @PATH(&quot;id&quot;) Long id 即可改变路径中 {id} 请求时的值。 12345678910// path 中不包含参数@GET(GET_USER_INFO)Call&lt;UserInfoDTOResponse&gt; getUser();String PATH_BABY_ID = "babyId";String PUT_EDIT_BABY = "api/v2/baby/doEdit/&#123;" + PATH_BABY_ID + "&#125;";@PUT(PUT_EDIT_BABY)Call&lt;BaseResponse&gt; putEditBaby(@Path(PATH_BABY_ID) Long babyId); Body发送 POST 、PUT 请求时通常需要携带 body 数据，使用 @Body 注解，如下： 12@PUT(PUT_EDIT_BABY)Call&lt;BaseResponse&gt; putEditBaby(@Body BabyParam babyParam); Query配置 UrlQuery 参数，比如 api/v1/user/list?limit=100&amp;offset=10 这种类型。有两种配置方式： 第一种使用 @Query 注解，如 @Query(&quot;userId&quot;) Long userId 的形式。这种形式可以传递 null 值，如果某个参数为 null，将不会拼接在 url 后面。 第二种使用 @QueryMap 注解，如 @QureyMap Map&lt;String,String&gt; params 的形式。这种形式传递一个 map 作为参数，但是 map 中 value 不能为 null，否则会抛出异常。 12345@GET(GET_BABY_RELATION_LIST)Call&lt;UserBabyRelationResp&gt; getBabyRelationList(@Query("babyId") Long babyId, @Query("limit") int limit, @Query("offset") Long offset);@GET(GET_BABY_RELATION_LIST)Call&lt;UserBabyRelationResp&gt; getBabyRelationList(@QueryMap Map&lt;String,String&gt; map); Header静态 Header，使用 @Headers 注解添加在请求接口上，用法如下： 123456789101112@Headers(&#123;"key:value","key:value"&#125;)@Headers("key:value")eg:@Headers(&#123;"Authorization: authValue", "User-Agent: Retrofit-Sample-App"&#125;)@GET(GET_USER_INFO)Call&lt;UserInfoDTOResponse&gt; getUser();@Headers("Authorization: authValue")@GET(GET_USER_INFO)Call&lt;UserInfoDTOResponse&gt; getUser(); 局部动态 Header，使用 @Header(&quot;key&quot;) 和 @HeaderMap 注解添加在请求参数上，动态配置，用法如下： 12345678910@Header("Authorization") String auth// retrofit:2.1.0 添加@HeaderMap Map&lt;String, String&gt; headerseg:@GET(GET_USER_INFO)Call&lt;UserInfoDTOResponse&gt; getUser(@Header("Authorization") String auth);@GET(GET_USER_INFO)Call&lt;UserInfoDTOResponse&gt; getUser(@HeaderMap Map&lt;String, String&gt; headers); 全局配置 Header，为 OkHttp 添加 Interceptor，需要注意的是 addNetWorkIntercepror() 和 addInterceptor() 的区别。当进入 netWorkInterceptor 时已经添加了 User-Agent 等 Header，此时要把自己的 Header 一个一个 addHeader() 进去，防止把原来的冲掉。 1234567891011121314151617181920212223242526272829public final class HeaderInterceptor implements Interceptor &#123; public static final String TAG = HeaderInterceptor.class.getSimpleName(); // 到达 netWorkInterceptor 时，默认 header 已经添加，不能使用替换的方式，要使用 addHeader 的方式 // 到达 interceptor 时，还没有添加默认 header ,可以直接替换原来的 header ，后面会追加默认 header @Override public Response intercept(@NonNull Chain chain) throws IOException &#123; Request request = chain.request(); L.e(TAG, "添加全局 header "); Request.Builder builder = request.newBuilder(); Map&lt;String, String&gt; headersMap = ApiRequest.getHeadersMap(); for (String key : headersMap.keySet()) &#123; builder.addHeader(key, headersMap.get(key)); &#125; Response response; try &#123; response = chain.proceed(builder.build()); &#125; catch (Exception e) &#123; e.printStackTrace(); throw e; &#125; return response; &#125;&#125;OkHttpClient.Builder okHttpBuilder = new OkHttpClient.Builder();okHttpBuilder.addNetworkInterceptor(new HeaderInterceptor()); Todo更多内容还没有涉及… 1234567891011// 表单提交@FormUrlEncoded@POST("user/edit")@HEADCall&lt;User&gt; updateUser(@Field("first_name") String first, @Field("last_name") String last);// 文件上传@Multipart@PUT("user/photo")Call&lt;User&gt; updateUser(@Part("photo") RequestBody photo, @Part("description") RequestBody description);]]></content>
      <categories>
        <category>Android</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Retrofit</tag>
        <tag>Library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[改变]]></title>
    <url>%2Farticle%2F3443742407%2F</url>
    <content type="text"><![CDATA[2017年6月29日早8点 小雨 上周周末看了《变形金刚5》，然后睡了整整两天，周日的晚上有种强烈的负罪感，感觉简直就是在浪费生命，于是就把今日头条、微博、爱奇艺、哔哩哔哩、土豆等软件全都卸载了，留下了脉脉、CSDN、知乎… 到今天已经是第四天，这几天一直坚持晚上11点钟左右睡觉，早上7点钟到8点钟之间起床，有点危机感，这样下去终归是不行的。今天早上7点多睁眼看了一篇文章，是一篇面经，看了他总结的面试知识点，十之八九都答不上来。感觉一直在工作的过程中都是实现为主，堆砌代码，原理、算法什么的好久没去管过，很早之前还会去看一眼源码，分析一下，现在根本没那个积极性，是时候得改变一下，多学点东西才有选择的权力。 总有一天我也要变的很🐂x。革命尚未成功，同志仍需努力。 附面经 一年Android工作经验，一举拿下百度、网易、美团、小米、快手等Offer面经 查到了这个🐂人的博客地址，不过貌似打不开CSDN]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView]]></title>
    <url>%2Farticle%2F3518734228%2F</url>
    <content type="text"><![CDATA[本文主要记录 Android 中 WebView 控件的相关使用，不断完善中… 基本配置汇总一下 WebView 的配置方法，当然不是全部都需要配置的，只是一个汇总和记录，具体比较重要的配置，有需要的话后面会展开介绍。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private static void initWebViewCache(WebView mWebView) &#123; String cachePath = new File(Environment.getExternalStorageDirectory(), "appCache").getAbsolutePath(); WebSettings settings = mWebView.getSettings(); settings.setAppCacheEnabled(true); settings.setAppCachePath(cachePath); settings.setDatabaseEnabled(true); // 过时 // settings.setDatabasePath(cachePath); settings.setDomStorageEnabled(true);// 开启dom缓存 // LOAD_DEFAULT：默认的缓存使用模式。在进行页面前进或后退的操作时，如果缓存可用并未过期就优先加载缓存，否则从网络上加载数据。这样可以减少页面的网络请求次数。 // LOAD_CACHE_ELSE_NETWORK：只要缓存可用就加载缓存，哪怕它们已经过期失效。如果缓存不可用就从网络上加载数据。 // LOAD_NO_CACHE：不加载缓存，只从网络加载数据。 // LOAD_CACHE_ONLY：不从网络加载数据，只从缓存加载数据。 settings.setCacheMode(WebSettings.LOAD_NO_CACHE); // 缓存最大值，过时 settings.setAppCacheMaxSize(1000 * 1024);&#125;public static void initWebViewSettings(WebView mWebView) &#123; //支持获取手势焦点 mWebView.requestFocusFromTouch(); // 触觉反馈，暂时没发现用处在哪里 mWebView.setHapticFeedbackEnabled(false); WebSettings settings = mWebView.getSettings(); // 支持插件 settings.setPluginState(WebSettings.PluginState.ON); // 允许js交互 settings.setJavaScriptEnabled(true); // 设置WebView是否可以由JavaScript自动打开窗口，默认为false，通常与JavaScript的window.open()配合使用。 settings.setJavaScriptCanOpenWindowsAutomatically(true); // 允许中文编码 settings.setDefaultTextEncodingName("UTF-8"); // 使用大视图，设置适应屏幕 settings.setUseWideViewPort(true); settings.setLoadWithOverviewMode(true); // 支持多窗口 settings.setSupportMultipleWindows(true); // 隐藏自带缩放按钮 settings.setBuiltInZoomControls(false); // 支持缩放 settings.setSupportZoom(true); //设置可访问文件 settings.setAllowFileAccess(true); //当WebView调用requestFocus时为WebView设置节点 settings.setNeedInitialFocus(true); //支持自动加载图片 if (Build.VERSION.SDK_INT &gt;= 19) &#123; settings.setLoadsImagesAutomatically(true); &#125; else &#123; settings.setLoadsImagesAutomatically(false); &#125; // 指定WebView的页面布局显示形式，调用该方法会引起页面重绘。 // NORMAL,SINGLE_COLUMN 过时, NARROW_COLUMNS 过时 ,TEXT_AUTOSIZING settings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.SINGLE_COLUMN); // 从Lollipop(5.0)开始WebView默认不允许混合模式，https当中不能加载http资源，需要设置开启 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; settings.setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW); &#125;&#125; Java 与 JS 交互 案例，做一个支付的交互，java 加载 html 网页，调用 js 进行支付，支付成功后，html 返回支付结果。 首先需要定义一个 JavaScriptInterface，它是 js 调用 Java 代码的桥梁，定义 PayJsBridge 类，使用 @JavascriptInterface 注解声明 js 调用的方法。 123456789private class PayJsBridge &#123; @JavascriptInterface public void payResult(boolean isSuccess) &#123; // 支付结果 if (mOnPayListener != null) &#123; mOnPayListener.onPayResult(isSuccess); &#125; &#125;&#125; 将 PayJsBridge 添加到 WebView 中，使用 mWebView.addJavascriptInterface(Object obj,String name) 方法，两个参数分别为 obj：带有 JavascriptInterface 注解方法的对象实例。 name：一个标志符，js 将会使用该标志来调用 java 层的方法。 12PayJsBridge mPayJsBridge = new PayJsBridge();mWebView.addJavascriptInterface(mPayJsBridge, "native"); Java 调用 Js使用 java 调用 js 方法相对简单。 在 js 中应该声明如下 function， 123456&lt;script&gt;function startPay(orderId,channelId)&#123; document.getElementById("display").innerHTML= 'orderId = '+orderId +',channelId = '+ channelId; window.native.payResult(true);&#125;&lt;/script&gt; 在 java 层调用时只需 loadUrl(&quot;Javascript:js方法名()) 即可。 1mWebView.loadUrl("javascript:startPay(100,1)"); Js 调用 Java在添加调用接口时，我们添加了一个标记，如上面代码中添加的是 native，它相当于调用接口对象的一个别名，因此在 js 中调用 java 方法时，只需要使用 window 对象，如下 1window.native.payResult(true); 附测试 html 和 java 源码index.html 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;script&gt;function startPay(orderId,channelId)&#123; document.getElementById("display").innerHTML= 'orderId = '+orderId +',channelId = '+ channelId; window.native.payResult(true);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p id="display"&gt;将要显示&lt;/p&gt;&lt;button type="button" onclick="startPay(1,3)"&gt;支付&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; test.java 12345678910111213141516171819202122232425// 交互接口private class PayJsBridge &#123; @JavascriptInterface public void payResult(boolean isSuccess) &#123; if (mOnPayListener != null) &#123; mOnPayListener.onPayResult(isSuccess); &#125; &#125;&#125;// 添加调用接口mWebView.getSettings().setJavaScriptEnabled(true);PayJsBridge mPayJsBridge = new PayJsBridge();mWebView.addJavascriptInterface(mPayJsBridge, "native");// 调用 jspublic void actionPay(long orderId) &#123; StringBuilder jsCmd = new StringBuilder("javascript:startPay(") .append(orderId) .append(",") .append(mCurrentPaymentId) .append(")"); mWebView.loadUrl(jsCmd.toString()); ToastUtil.show("模拟支付 jsCmd = " + jsCmd);&#125; 拦截 URL 打开应用(支付宝)前端使用支付宝进行支付时，需要打开手机支付宝客户端，断点看到支付宝会加载一个 alipays:// 开头的url，链接中配置了支付的相关信息，客户端要做的就是拦截该Url，使用 intent 打开支付宝。 当 html 加载网页之前会先走 shouldOverrideUrlLoading() 方法，此时截断不使用 webView 加载，而是使用 intent 打开。此方法不仅适用支付宝，也适用打开其他应用，被打开的应用需要暴露一个 schema… 12345678910111213141516171819202122232425262728mWebView.setWebViewClient(new WebViewClient() &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; // 如果不使用intent覆盖加载这个链接，就走原来 if (!shouldOverrideIntentUrl(getContext(), url)) &#123; view.loadUrl(url, Api.makeHttpHeaders(getContext())); &#125; return true; &#125;&#125;);// 是不是使用 intent 打开private boolean shouldOverrideIntentUrl(Context context, String url) &#123; if (url.startsWith("alipays://") || url.startsWith("intent://")) &#123; try &#123; Intent intent = Intent.parseUri(url, Intent.URI_INTENT_SCHEME); intent.addCategory("android.intent.category.BROWSABLE"); intent.setComponent(null); intent.setSelector(null); context.startActivity(intent); return true; &#125; catch (URISyntaxException e) &#123; e.printStackTrace(); return false; &#125; &#125; return false;&#125; 支持下载链接当网页中加载一个下载的链接，如 http://xxx.apk 这种链接，会走 shouldOverrideUrlLoading() 方法，但是，它是无法加载一个网页的，此时需要设置 DownloadListener，需要下载的链接会进入监听，你可以在监听中自己进行网络下载保存到文件，下面我使用直接打开浏览器的方式，更简单一些。 1234567891011121314mWebView1.setDownloadListener(new DownloadListener() &#123; @Override public void onDownloadStart(String url, String userAgent, String contentDisposition, String mimetype, long contentLength) &#123; // 去浏览器打开 Intent intent = new Intent(Intent.ACTION_VIEW); String downLoadUrl = url; if (!downLoadUrl.contains("http://")) &#123; downLoadUrl = "http://" + downLoadUrl; &#125; intent.setData(Uri.parse(downLoadUrl)); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); BaoBaoApplication.getInstance().startActivity(intent); &#125;&#125;); WebChromeClientWebView 默认是无法弹出 alert() 的，需要设置 WebChromeClient 1mWebView.setWebChromeClient(new WebChromeClient());]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView Adapter]]></title>
    <url>%2Farticle%2F1632666977%2F</url>
    <content type="text"><![CDATA[LightAdapter 希望能够实现一个轻量级的、更容易使用和理解的RecyclerView Adapter 类库，吸取别人的长处，不断完善中。 基本的数据加载与绑定由 LightAdapter 来实现，更多增强功能由多个模块 Module 分工合作完成，现在具有以下模块 HFModule，实现为 RecyclerView 添加 Header 和 Footer 的功能，可以动态的显示和移除 Header 和 Footer。 LoadMoreModule，实现到达列表底部自动触发监听加载更多数据。 TopLoadMoreModule，实现到达列表顶部自动触发监听加载更多数据。 SelectorModule，实现选择器功能，辅助简化列表单选和多选操作和数据更新和存储。 UpdateModule，实现包装数据更新功能，在主线程更新数据，并提供更多更新数据的方法。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Contribute</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android编译FFmpeg之命令行]]></title>
    <url>%2Farticle%2F4043209466%2F</url>
    <content type="text"><![CDATA[上篇文章介绍了 FFmpeg 大体的编译流程，并在 Java 层进行 JNI 接口的调用，借此了解 Android 编译底层 so 库的方式，本文主要介绍如何在 Android 平台使用 FFmoeg 命令行对音视频进行操作。 承接上文，本文从编译好各个 so 文件之后，编写 Java 层调用的 c 文件开始。 源代码 GitHub - FFmpegAndroidSupport(注意在 try_cmd 分支) Java 层 Native 方法首先进行 Java 层代码的编写，创建 FFmpegSupport 类，加载 so 文件，声明 native 方法。 123456789101112131415161718192021222324252627282930313233343536public class FFmpegSupport &#123; static &#123; try &#123; System.loadLibrary("avdevice-57"); System.loadLibrary("avfilter-6"); System.loadLibrary("avformat-57"); System.loadLibrary("avutil-55"); System.loadLibrary("avcodec-57"); System.loadLibrary("postproc-54"); System.loadLibrary("swresample-2"); System.loadLibrary("swscale-4"); System.loadLibrary("ffmpegjni"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static int ffmpegRunCommand(String command) &#123; if (command.isEmpty()) &#123; return 1; &#125; String[] args = command.split(" "); return ffmpegRunCommand(args); &#125; static int ffmpegRunCommand(String[] commands) &#123; for (String command : commands) &#123; Log.d("ffmpeg-jni", command); &#125; return ffmpegRun(commands.length, commands); &#125; public static native int ffmpegRun(int argc, String[] args);&#125; 生成 .h 头文件使用 javah 命令根据你的 java 文件自动生成 .h 文件，javah 命令需要 class 文件，所以首先你需要对工程进行编译，生成 class 文件，它位于 project/app/build/intermediates/classes/debug 目录下。 比如我的类叫做 FFmpegSupport，包名 com.march.fas，运行命令后生成了 com_march_fas_FFmpegSupport.h 文件，这个 .h 文件的名字应该是可以自定义的，现在是默认的包名类名，我还没有查到相关参数。 123456javah -d &lt;.h文件生成的目录&gt; -classpath &lt;class文件存储的目录&gt; &lt;包名.类名&gt;// 如下javah -d /Users/march/AndroidPro/FFmpegAndroidSupport/app/src/main/jni \-classpath /Users/march/AndroidPro/FFmpegAndroidSupport/app/build/intermediates/classes/debug \com.march.fas.FFmpegSupport 查看 .h 文件的内容，将 jclass 改为 jobject，原因的话我也不知道为什么，不是很懂这一块儿，也是查资料慢慢总结的。 123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class com_march_fas_FFmpegSupport */#ifndef _Included_com_march_fas_FFmpegSupport#define _Included_com_march_fas_FFmpegSupport#ifdef __cplusplusextern "C" &#123;#endif/* * Class: com_march_fas_FFmpegSupport * Method: ffmpegRun * Signature: (I[Ljava/lang/String;)I */JNIEXPORT jint JNICALL Java_com_march_fas_FFmpegSupport_ffmpegRun (JNIEnv *, jobject, jint, jobjectArray);#ifdef __cplusplus&#125;#endif#endif 编写对应 c 文件根据生成的 .h 编写 c 文件，其中 logjni.h 是一个打印日志的工具类，详细可以参考 github 上面的源文件。 123456789101112131415161718192021222324252627282930313233343536#include "logjni.h"#include "com_march_fas_FFmpegSupport.h"#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;int main(int argc, char **argv);JNIEXPORT jint JNICALL Java_com_march_fas_FFmpegSupport_ffmpegRun(JNIEnv *env, jobject obj, jint argc, jobjectArray args) &#123; int i = 0; char **argv = NULL; jstring *strr = NULL; if (args != NULL) &#123; argv = (char **) malloc(sizeof(char *) * argc); strr = (jstring *) malloc(sizeof(jstring) * argc); for (i = 0; i &lt; argc; ++i) &#123; strr[i] = (jstring)(*env)-&gt;GetObjectArrayElement(env, args, i); argv[i] = (char *)(*env)-&gt;GetStringUTFChars(env, strr[i], 0); LOGD("args: %s", argv[i]); &#125; &#125; LOGD("Run ffmpeg"); int result = main(argc, argv); LOGD("ffmpeg result %d", result); for (i = 0; i &lt; argc; ++i) &#123; (*env)-&gt;ReleaseStringUTFChars(env, strr[i], argv[i]); &#125; free(argv); free(strr); return result;&#125; 准备工作如上代码中，我们使用 ffmpeg.c 中的 main() 函数，因此需要将 ffmpeg.c 和 ffmpeg.h 拷贝到 jni 目录中，同时 ffmpeg.c 又引用了多个文件，大致有以下几个文件，这些文件都需要拷贝到 jni 目录中 12345678config.hffmpeg.cffmpeg.hffmpeg_filter.cffmpeg_opt.ccmdutils_common_opts.hcmdutils.hcmdutils.c 跟上一篇文章说的一样，我们还是要将编译好的 so 文件拷贝到 jni 目录，同时编写 Android.mk 和 Application.mk 文件。为了让结构更加清晰，我对目录做了些许改动。在 jni 目录下新建了 prebuilt/armeabi 文件夹，用来存放 so 文件。同时 Android.mk 和 Application.mk 文件也需要做相应修改。 Android.mk 文件， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE:= avcodec-prebuilt-armeabiLOCAL_SRC_FILES:= prebuilt/armeabi/libavcodec-57.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE:= avdevice-prebuilt-armeabiLOCAL_SRC_FILES:= prebuilt/armeabi/libavdevice-57.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE:= avfilter-prebuilt-armeabiLOCAL_SRC_FILES:= prebuilt/armeabi/libavfilter-6.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE:= avformat-prebuilt-armeabiLOCAL_SRC_FILES:= prebuilt/armeabi/libavformat-57.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := avutil-prebuilt-armeabiLOCAL_SRC_FILES := prebuilt/armeabi/libavutil-55.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := swresample-prebuilt-armeabiLOCAL_SRC_FILES := prebuilt/armeabi/libswresample-2.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := swscale-prebuilt-armeabiLOCAL_SRC_FILES := prebuilt/armeabi/libswscale-4.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := postproc-prebuilt-armeabiLOCAL_SRC_FILES := prebuilt/armeabi/libpostproc-54.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := libffmpegjniLOCAL_ARM_MODE := armLOCAL_SRC_FILES := com_march_fas_FFmpegSupport.c \ ffmpeg.c \ cmdutils.c \ ffmpeg_opt.c \ ffmpeg_filter.cLOCAL_LDLIBS := -L$(SYSROOT)/usr/lib -llog -lzLOCAL_SHARED_LIBRARIES:= avcodec-prebuilt-armeabi \ avdevice-prebuilt-armeabi \ avfilter-prebuilt-armeabi \ avformat-prebuilt-armeabi \ avutil-prebuilt-armeabi \ swresample-prebuilt-armeabi \ swscale-prebuilt-armeabi \ postproc-prebuilt-armeabiLOCAL_C_INCLUDES += -L$(SYSROOT)/usr/includeLOCAL_C_INCLUDES += /Users/march/AndroidPro/FFmpegAndroidSupport/ffmpeg-3.3.1LOCAL_CFLAGS := -DUSE_ARM_CONFIGinclude $(BUILD_SHARED_LIBRARY) Application.mk 文件 12APP_ABI := armeabi-v7aAPP_PLATFORM := android-14 修改 ffmpeg 源代码]]></content>
      <categories>
        <category>Android</category>
        <category>Ndk</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>FFmpeg</tag>
        <tag>Ndk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Kotlin 开发-3 (属性与域篇)]]></title>
    <url>%2Farticle%2F12ba0671%2F</url>
    <content type="text"><![CDATA[本文主要介绍 Kotlin 属性和域的相关内容。 Kotlin 中，使用 val 声明常量(不可变)，使用 var 声明变量(可变)。 12345public val a = 100 // 常量，不可变，当你再想改变他的值时会报错private var b = 1000 // 变量，可变b = -100val c:Int? = null 属性的声明声明属性的完整语法如下，其中的初始化器(initializer)， 取值方法(getter)， 以及设值方法(setter)都是可选的。Kotlin 具有类型自动推断得特性，如果属性类型可以通过初始化器自动推断得到， 或者可以通过这个属性覆盖的基类成员属性推断得到， 则属性类型的声明也可以省略。 标准的初始化方法，需要清楚其中几个概念 propertyName ：变量名 PropertyType ：变量类型，如果可以推断得到，可以省略 property_initializer ：初始化器，它可以是一个固定值或一个表达式 getter ：取值方法，访问器的一种 setter ：设值方法，访问器的一种 123var &lt;propertyName&gt;: &lt;PropertyType&gt; [= &lt;property_initializer&gt;] [&lt;getter&gt;] [&lt;setter&gt;] 注意，如下注释 1 处，对于 var 变量来说，初始化器，设值，取值方法都是允许同时存在的；如下注释 2 处，对于 val 变量来说，不允许有设值方法，同时 getter 方法和 初始化器 不允许同时指定，因为只读变量只允许初始化一次。 使用 注解 和 可见度修饰符，如下注释 3 处，，如果不想在外界访问属性的 set／get 方法，可以使用可见度修饰符来避免外部访问。同样也可以在 set／get 方法前使用注解。 1234567891011121314151617181920212223242526open class ClsA &#123; // 1 var x: Int = 100 get() = 100 set(value) &#123; field = value &#125; // 2. 不允许有设值方法，同时get方法和初始化器不允许同时指定，因为只读变量只允许初始化一次 val y: Int get() = 100 // 这是不允许的，因为val只读的 // set(value) &#123; // field = value // &#125; // 3. 在set/get方法前使用可见度修饰符和注解 var z: Int = 100 @Inject get private set&#125;eg:val param:ClsA = ClsA()// 编译错误，因为不允许访问z的设值方法param.z = 100 Backing FieldsKotlin 我们可以直接使用属性名称对类的属性进行访问，但是实际上我们并没有直接访问该属性的引用，而是在编译时被转换成了 getter/setter 方法来进行访问，如注释中 1 处代码，这样我们既可以简化代码，又保持了类的封闭性。 Kotlin 的类中不允许拥有域(Field)，也就是说你在类内部也无法直接使用属性的名称对属性进行访问，而是都会转换为 getter/getter 方法。因此当你在 set 方法中调用该属性为他赋值时又会调用 set 方法，导致 堆栈溢出，如实例中 2，这是我在开始写的时候遇到的问题。 12345678910// 1 伪代码ClsA().x = 100 相当于 ClsA().setX(100)val a = ClsA.x 相当于 val a = ClsA().getX()// 2var xx: Int = 100 set(value) &#123; // 再次调用 set 方法 xx = value + 1 &#125; 但是自定义属性的访问器时不可避免的要使用 域变量，因此 Kotlin 提供了 Backing Fields 的特性，使用关键字 field 表示，field 标识符只允许在属性的访问器函数内使用，如下代码中，使用 field 即可真实的访问(不经过getter/setter) 变量 xx，完成赋值操作。 12345var xx: Int = 100 get() = field++ set(value) &#123; field = value - 1 &#125; Backing Property有时隐含的后端域属性不足以解决某些情况的问题，此时可以使用自定义的 Backing Property。如下实例中，Backing Property 就是另外定义一个属性 _yy 用来存储数据，而外界访问的属性 yy 只是提供了一个访问器方法而已，本身已经不具备什么意义啦，将访问器的声明和数据的存储放在两个地方，就不会发生之前的冲突（我的理解😊） 12345678910111213141516private var _yy: String? = nullvar yy: String get() &#123; if (_yy == null) &#123; _yy = "init str" &#125; return _yy ?: "be changed" &#125; set(value) &#123; _yy = "this is $value" &#125; // 访问yyval param: ClsA = ClsA()param.yy 编译期常数如果属性值在编译期间就能确定, 则可以使用 const 修饰符, 将属性标记为 编译期常数值(compile time constants)。 这类属性必须满足以下所有条件: 必须是顶级属性， 或者是一个 object 的成员。 值被初始化为 String 类型, 或基本类型(primitive type)。 不存在自定义的取值方法。 1234567// 顶级属性const val TEST_CONST = "TEST_CONST"// 声明在 object 中object Const&#123; const val TEST_CONST_IN_OBJ = "TEST_CONST_IN_OBJ"&#125; 属性初始化 - 延迟(lateinit)lateinit 关键字表示当前 变量 不会在声明时进行初始化操作，初始化操作会在后面进行，像是一种协议机制，告知编译器我会在后面使用该变量之前的恰当时机初始化该变量，不要进行警告⚠️。在一个 lateinit 属性被初始化之前访问它， 会抛出一个特别的异常，这个异常将会指明被访问的属性，以及它没有被初始化这一错误。 需要注意的是使用 lateinit 关键字有很多限制: 必须是变量，即使用 var 关键字进行声明。 不能修饰可为 null 的类型，比如 lateinit var str:String? 是编译不通过的。 不能修饰基本数据类型。例如 Int,Float等 123lateinit var stuLateInit:StudentstuLateInit = Student("name",11) 属性延迟初始化 - 代理(by lazy)by lazy 是属性代理的基本运用，是经过简化后的属性代理，他为属性提供初始化方法。这里不扩展属性代理的相关问题。 因为他只提供取值方法所以仅可以用在常量的初始化中，使用 by lazy 当属性被第一次访问时，就会触发初始化流程。 只有常量，也就是使用 val才能使用 by lazy 延迟初始化 1234567891011val stuByLazy:Student by lazy &#123; Student("name",11)&#125;val mMyMsgTv:TextView by lazy &#123; findViewById(R.id.mTestTv) as TextView&#125;// 当常量被使用时才进行初始化logError(stuByLazy.myCls)mMyMsgTv.text="文本"]]></content>
      <categories>
        <category>Study</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Kotlin 开发-4 (类与对象篇)]]></title>
    <url>%2Farticle%2F2717980190%2F</url>
    <content type="text"><![CDATA[本文主要介绍 Kotlin 类与对象。 看了官方文档的相关描述，发现很多名词在 Kotlin 中和 Java 都有不太一样，在 Kotlin 中 方法 被称为 函数，而像 open , final 这种关键字被称为注解(annotation)，在我之前的认知当中只有 @Inject 这种才是注解。因此文章中的描述都尽量使用 Kotlin 中的术语。 接口接口使用 interface 关键字声明； 接口中可以包含抽象方法的声明，也可以包含方法的实现。 接口与抽象类的区别在于， 接口不能存储状态数据。 接口可以有属性， 但这些属性必须是抽象的， 或者必须提供访问器的自定义实现。 接口不支持 Backing Field，因此 var 变量无法定义访问器 123456789101112131415161718192021222324252627interface FirstInterface &#123; // 可以具有属性，但是属性必须是抽象的 // 或者必须提供访问器的自定义实现 val testVal1: Int var testVar2: Int val testVal3: Int get() = 100 // 编译错误，接口不支持 backing field // 因此 var 类型的属性不能自定义访问器 var testVar4: Int get() = 100 // 编译错误，属性必须是抽象的 // 或者必须提供访问器的自定义实现 val testVal10: Int = 1 var testVar10: Int = 1 // 可以包含抽象方法的声明 fun testFun1() // 也可以包含方法的实现 fun testFun2(param: Int): String &#123; return "test fun 2" &#125;&#125; 实现接口12345678910111213141516171819202122232425class SecondInterface:FirstInterface&#123; // 使用初始化器覆盖接口抽象属性 override val testVal1: Int = 10 // 使用自定义访问器覆盖接口抽象属性 override var testVar2: Int get() = 100 set(value) &#123;&#125; // 覆盖接口非抽象属性 override val testVal3: Int get() = super.testVal3 // 覆盖接口抽象方法 override fun testFun1() &#123; &#125; // 覆盖接口非抽象方法 override fun testFun2(param: Int): String &#123; return super.testFun2(param) &#125;&#125; 解决接口覆盖冲突由于接口是可以多继承的，如果实现多个接口，同时接口中有相同方法的声明，就会出现覆盖冲突，使用官网的一个例子来说明一下覆盖冲突的解决。单继承时自然要实现接口中所有抽象方法，当实现多个接口时，如果实现的接口中具有同名的抽象方法，即使在接口中对该方法都已经有了实现，那么在子类中也必须实现该方法，并使用super&lt;接口名称&gt;.方法名，如下面的 super&lt;A&gt;.bar() 来在子类中显式的声明到底是继承哪一个实现。 123456789101112131415161718192021222324252627interface A &#123; fun foo() &#123; print("A") &#125; fun bar()&#125;interface B &#123; fun foo() &#123; print("B") &#125; fun bar() &#123; print("bar") &#125;&#125;class C : A &#123; override fun bar() &#123; print("bar") &#125;&#125;class D : A, B &#123; // 重名函数必须实现，即使继承的接口中已经有了具体实现 override fun foo() &#123; super&lt;A&gt;.foo() super&lt;B&gt;.foo() &#125; override fun bar() &#123; super&lt;B&gt;.bar() // 由于 A 中对 bar 没有实现，可以如下简写 // super.bar() &#125;&#125; 类的构造器Kotlin 中的类可以有一个 主构造器 (primary constructor), 以及一个或多个 次构造器 (secondary constructor)。主构造器是类头部的一部分, 位于类名称(以及可选的类型参数)之后。 主构造器主构造器紧跟在类名后面进行声明，声明的一般形式如下，可见度修饰符默认为 public，(如果主构造器是 public 的，同时没有注解那么可以省略 constructor 关键字)。当然如果类内部没有具体的实现，{} 也是可以省略的。 12345678// 完整的写法class Engineer private @Inject constructor(name: String, age: Int, language: String)// 简化写法，由于是public的，同时没有注解，省略了constructor关键字class Engineer (name: String, age: Int, language: String)// 默认生成一个public的无参构造器class Engineer 由于主构造器中无法使用初始化代码，可以在类内进行属性的初始化，使用 init{} 关键字表示。 123456789101112class Engineer (name: String, age: Int, language: String) &#123; var name: String = "" var age:Int = 0 var language:String = "" init &#123; this.name = name this.age = age this.language = language log("name = $name,age = $age, lan = $language") &#125;&#125; 在主构造器内可以直接使用 val 和 var 声明和初始化属性，他们都是类的成员属性。 123class Engineer(val name: String = "", age: Int = 0, language: String = "") &#123;&#125; 注意: 在 JVM 中, 如果主构造器的所有参数都指定了默认值, 编译器将会产生一个额外的无参数构造器, 这个无参数构造器会使用默认参数值来调用既有的构造器. 有些库(比如 Jackson 或 JPA) 会使用无参数构造器来创建对象实例, 这个特性将使得 Kotlin 比较容易与这种库协同工作. 次级构造器如果类有主构造器, 那么每个次级构造器都必须委托给主构造器, 要么直接委托, 要么通过其他次级构造器间接委托. 委托到同一个类的另一个构造器时, 使用 this 关键字实现。 12345class Engineer(val name: String = "", age: Int = 0, language: String = "") &#123; constructor(name: String, age: Int) : this(name, age, "en")&#123; log("次级构造器") &#125;&#125; 创建对象构造器中的属性指定初始值后在创建对象时可以省略，使用如下方法，避免重载构造方法，主构造器中具有默认值的属性不是必须赋值的。 123val en = Engineer("",12)val en1 = Engineer(name = "test")val en2 = Engineer(name = "test",age = 12,language = "") 继承kotlin 中所有的类默认继承自超类 Any,Any 不是 java.lang.Object; 尤其要注意, 除 equals() , hashCode() 和 toString() 之外, 它没有任何成员。 Kotlin 中所有的类都是 fnial 的，也就是不允许继承，这点和 Java 正好相反，如果你想继承一个类必须使用 open 关键字声明。 Kotlin 使用 : 表示继承，子类和父类构造器调用分为以下两种情况 如果类有主构造器, 那么必须在主构造器中使用主构造器的参数来初始化基类。 12345open class Engineer(var name: String = "", var age: Int = 0, var language: String = "") &#123;&#125;class BigEngineer(var level: Int) : Engineer("name",12) &#123;&#125; 如果类没有主构造器, 那么所有的次级构造器都必须使用 super 关键字来初始化基类, 或者委托到另一个构造器, 由被委托的构造器来初始化基类。 注意, 这种情况下, 不同的次级构造器可以调用基类中不同的构造器。 12345678910open class Engineer(var name: String = "", var age: Int = 0, var language: String = "") &#123; &#125;class BigEngineer : Engineer &#123; var level = 0 constructor(name:String,age:Int,level:Int):super(name,age,"en")&#123; this.level = level &#125;&#125; 方法的覆盖和类一样，类中的所有方法都默认是 final 的，即不允许在子类中进行重写，如果想要在子类中更改，需要使用 open 注解声明，如实例中 3。 如果子类想要覆盖父类的方法，必须添加 override 注解。 如果遗漏了这个注解，编译器将会报告错误。 如果一个函数没有标注 open 注解， 那么在子类中声明一个同名同参的方法将是非法的, 无论是否添加 override 注解， 都不可以，如实例中 4。 当一个子类成员标记了 override 注解来覆盖父类成员时， 覆盖后的子类成员本身也将是 open 的, 也就是说， 子类成员可以被自己的子类再次覆盖，如实例中 1。 如果你希望禁止这种再次覆盖，可以使用 final 注解，如实例中 2。 实例： 12345678910111213141516171819202122open class Engineer(var name: String = "", var age: Int = 0, var language: String = "") &#123; open fun test() &#123;&#125; open fun test2() &#123;&#125; // 此函数不允许在子类覆盖 fun test3() &#123;&#125;&#125;open class BigEngineer(name: String = "", age: Int = 0, var level: Int = 0) : Engineer(name, age, "en") &#123; // 1. 此函数覆盖了超类中的函数，他将默认是open的，他的子类可以覆盖该方法。 override fun test() &#123;&#125; // 2. 此函数在子类中将不会被覆盖，因为显式的添加了final注解 final override fun test2() &#123;&#125; // 3. 这句是编译错误的，因为test3()不是open的 // override fun test3() &#123;&#125; // 4. 这句是编译错误的，超类中test3()是final的，在子类中声明同名同参的函数是非法的 // fun test3()&#123;&#125;&#125; 在一个 final 类(比如， 一个没有添加 open 注解的类)中， 声明 open 成员是没有意义的。 123456class Test&#123; // 警告⚠️open has no effect in a final class。 // 在一个final类中声明open成员是无意义的，因为类无法被继承，成员函数和变量也无法被重写。 open fun test()&#123;&#125; open val a = 0&#125; 属性的覆盖前提，属性的覆盖方式与方法覆盖类似，同样必须在父类中声明为 open，当超类中声明的属性在后代类中再次声明时，必须使用 override 关键字来标记，而且覆盖后的属性数据类型必须与超类中的属性数据类型兼容。 可以使用带初始化器的属性来覆盖超类属性， 也可以使用带取值方法(getter)的属性来覆盖。 可以在主构造器的属性声明中使用 override 关键字，覆盖主构造器中的属性。 可以使用一个 var 属性覆盖一个 val 属性，但不可以反过来使用一个 val 属性覆盖一个 var 属性。 允许这种覆盖的原因是， val 属性本质上只是定义了一个 get 方法，使用 var 属性来覆盖它， 只是向后代类中添加了一个 set 方法。 123456789101112131415161718192021222324// name属性是open的，它可以在子类中被覆盖open class Engineer(open var name: String = "", var age: Int = 0, var language: String = "") &#123; open val a: Int get() = 100 open val b: Int = 100 open var c:Int = 100&#125;// 覆盖了超类中的name属性open class BigEngineer(override var name: String = "", age: Int = 0, var level: Int = 0) : Engineer(name, age, "en") &#123; // 可以使用初始化器或getter方法对属性进行覆盖，都是允许的。 override val a: Int = 100 override var b = 0 get() = 1 // 这句是编译错误的，因为val变量不能覆盖var变量 // override val c:Int = 1&#125; 覆盖的原则在 Kotlin 中， 类继承中的方法实现问题, 遵守以下规则: 如果一个类从它的直接超类中继承了同一个成员的多个实现，那么这个子类必须覆盖这个成员，并提供一个自己的实现，这样在子类中消除歧，为了表示使用的方法是从哪个超类继承得到的， 我们使用 super 关键字, 将超类名称放在尖括号类, 比如 super&lt;父类&gt;。 1234567891011121314151617181920212223open class ClsA &#123; open val a = 100 open fun test() &#123;&#125;&#125;interface ClsB &#123; val a: Int fun test() &#123;&#125;&#125;class ClsC : ClsA(), ClsB &#123; // 属性的覆盖不存在这样的问题 override val a = 1000 // 方法的覆盖 // 此时编译器强制必须实现test()方法,因为可以从超类中继承多个实现 override fun test() &#123; // 明确的调用父类中的方法 super&lt;ClsA&gt;.test() super&lt;ClsB&gt;.test() &#125;&#125;]]></content>
      <categories>
        <category>Study</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Kotlin 开发-2 (基础语法篇)]]></title>
    <url>%2Farticle%2F811551029%2F</url>
    <content type="text"><![CDATA[本篇主要介绍 Kotlin 的基础语法，控制流，内建数据类型等内容… import 语句和包的相关概念。 可见度修饰符的使用。 大部分内建数据类型的介绍。包括数值类型，字符类型，布尔类型，数组类型，字符串类型。 控制流的使用，if , when , for , while 等关键字在 Kotlin 中的新特性。 如何在函数中返回和跳转，return , continue , break 等关键字的使用。 go~ 包123456// 导包import com.march.ktexample.model.Student// 导包时使用别名，然后就可以使用别名调用import android.util.Log as LL.e(TAG, str) 可见度修饰符类，对象，接口，构造器，函数，属性以及属性访问器设值方法(访问器取值方法总与属性本身可见度相同，因此不需要控制其可见度)，都可以使用 可见度修饰符 。Kotlin 中的四种可见度修饰符：private、protected、internal、public，默认为 public。与 Java 不同的是少了 default 多了 internal。 注意：局部变量， 局部函数，以及局部类，都不能指定可见度修饰符。 top-leveltop-level， 像 class 这种可以直接声明在包下。在 Kotlin 中，函数, 属性, 类, 对象, 接口都可以声明为 top-level。比如扩展函数和扩展属性就是 声明为 top-level 的。注意，这里说的是 top-level 级别声明，在这些声明内部再声明别的函数或者属性，不再讨论范畴，将在下一部分说明，对于 top-level 中的声明来说： public 意为该声明在任何位置都可以访问，public 是默认的，可以省略。If you do not specify any visibility modifier, public is used by default, which means that your declarations will be visible everywhere; private 意为该声明只能在同一个源代码文件中访问。If you mark a declaration private, it will only be visible inside the file containing the declaration; internal 意为该声明在同一个module的任意位置是可以访问的。If you mark it internal, it is visible everywhere in the same module; protected 对 top-level 的声明是无效的。protected is not available for top-level declarations. 1234567891011121314151617package com.march.ktexample// filename:VisibilityModifiersTest.kt// 类声明class MyCls // 接口声明，同 module 访问internal interface MyInter // 函数声明，只允许在文件内访问private fun MyFun()&#123;&#125; // 属性声明，所有地方都可以访问，默认 public 可以省略public var MyVal = 10 // 设置方法只有文件内可以访问 private set 类与接口在类和接口内部使用可见度修饰符 private 在类内(以及它的所有成员之间)可以访问。private means visible inside this class only (including all its members); protected 和 private 相同，而且在子类中也可以访问。protected — same as private + visible in subclasses too; internal 在同一个 module 内，能访问该类的地方，也能访问该类的 internal 成员。any client inside this module who sees the declaring class sees its internal members; public 在任何位置凡是能访问该类，则也能访问该类的 public 成员。any client who sees the declaring class sees its public members. 注意： 在 Kotlin 中，外部类不能访问其内部类的 private 成员。如果你覆盖一个 protected 成员，并且没有明确指定可见度，那么覆盖后成员的可见度也将是 protected。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475open class OuterCls &#123; // 类内可访问 private var a = 1 // 类内可访问，子类可访问 protected open val b = 2 // 模块内可以访问该类的地方，都可以访问该属性 internal val c = 3 // 默认为 public,任何位置，可以访问该类的地方都可以访问该属性 var d = 4 fun test() &#123; a = 1 // 外部类访问嵌套类pubic成员 NestedCls().publicVar // 编译错误，外部类不能访问嵌套类 private 成员 NestedCls().privateVar // 编译错误，外部类不能访问嵌套类 protected 成员 NestedCls().protectedVar // 外部类访问内部吧类public成员 InnerCls().publicVar // 编译错误，外部类不能访问内部类 protected 成员 InnerCls().privateVar // 编译错误，外部类不能访问内类 protected 成员 InnerCls().protectedVar &#125; // 嵌套类 private class NestedCls &#123; public var publicVar: Int = 5 private var privateVar: Int = 5 protected var protectedVar: Int = 5 // 嵌套类，不能访问外部类成员，不论 private public fun test() &#123; // 编译错误 a = 1 // 编译错误 d = 10 &#125; &#125; inner class InnerCls &#123; public var publicVar: Int = 5 private var privateVar: Int = 5 protected var protectedVar: Int = 5 // 内部类，可以访问外部类成员，不论 private public fun test() &#123; a = 1 d = 10 &#125; &#125;&#125;class Subclass : OuterCls() &#123; // a 不可访问 // b, c 和 d 可以访问 // Nested 和 e 可以访问 // 覆盖了父类中的 b，b可见度仍然为 protected，可以被子类覆盖 override val b = 5 fun testSub()&#123; // 编译错误，子类不可以访问 NestedCls 因为他是 private 的 NestedCls().publicVar // 可以访问 InnerCls，他是 public 的 InnerCls().publicVar &#125;&#125;class Unrelated(o: OuterCls) &#123; // o.a, o.b 不可访问 // o.c 和 o.d 可以访问(属于同一模块) // Outer.Nested 不可访问, Nested::e 也不可访问&#125; 构造器注意，指定类构造器可见度，你需要明确添加一个 constructor 关键字。 private 指定为 private 的构造器只在类内可以访问。 protected 类构造器可见度不支持 protected。 internal 表示同模块内可以访问该构造器。 public 在任何位置都可访问，构造器默认 public。 1234567891011121314class MyCls1 private constructor()&#123; fun test()&#123; // 类内可以访问 MyCls1() &#125;&#125;class MyCls2 public constructor()class MyCls3 internal constructor()class MyCls4 internal constructor()&#123; fun test()&#123; // 编译错误，private 的构造器同文件内不能访问 MyCls1() &#125;&#125; 内建数据类型介绍 Kotlin 的内建数据类型，包括数值类型，字符类型，布尔类型，数组类型，字符串类型。 数值类型Kotlin 数值使用内建对象表示，所有数值类型继承自 Number 抽象类，Number 中定义了数值在各个类型之间转换的方法。 Long 类型需要在数字末尾追加 大写 的 L 表示，如 123L；Float 类型需要在数字末尾追加 f／F 表示，如 123.5F。默认十进制计数，如： 123；十六进制以 0x 开头，如 0x1FA；二进制以 0b 开头，如 0b001101；不支持 八进制表示。 Double (64 bit) ；Float (32 bit) ；Long (64 bit) ；Int (32 bit) ；Short (16 bit) ；Byte (8 bit) ； 同一性：对象的类型，内容相同，使用 === 运算符比较为 true 相等性：内容相等，使用 == 运算法比较为 true 数值装箱 Kotlin 中一切皆为对象，因此内建的数值类型也为对象，但是他们具有如同基本数据类型的特性，即 同一性，数值内建对象就如同 Java 中的基本数据类型，他们的值是不能为 null 的，你可以使用像 Int? 这样来进行数值装箱，这里可以参考 Java 中数值装箱的概念。装箱之后的数值会保持 相等性 但无法保持 同一性 12345678910111213141516// 内建对象的同一性val aInt = 10val bInt = 10logError("$&#123;aInt === bInt&#125;")// truelogError("$&#123;aInt == bInt&#125;")// true// 数值装箱后保持相等性，但是不保持同一性val aOrigin:Int = 10000val aBoxInt: Int? = aOriginval bBoxInt: Int? = aOriginlogError("$&#123;aBoxInt === bBoxInt&#125;")// falselogError("$&#123;aBoxInt == bBoxInt&#125;")// true困惑：当aOrigin = 10时，aBoxInt === bBoxInt 为 true，当aOrigin = 10000时，aBoxInt === bBoxInt 为 false 类型转换 Kotlin 不会将较小的数据类型隐式地转换为较大的数据类型. 也就是说, 如果不进行显式类型转换, 我们就不能将一个 Byte 类型值赋给一个 Int 类型的变量。你需要使用 toInt() 显式扩大为更大的类型， Number 类中定义了向各个数据类型转换的方式。 123456val bb : Byte = 1val ll:Long = 1// 扩大val ii1:Int = bb.toInt()// 缩小val ii2:Int = ll.toInt() 数值运算符 1234567shl(bits) – 带符号左移 (等于 Java 的&lt;&lt;)shr(bits) – 带符号右移 (等于 Java 的 &gt;&gt;)ushr(bits) – 无符号右移 (等于 Java 的 &gt;&gt;&gt;)and(bits) – 按位与(and)or(bits) – 按位或(or)xor(bits) – 按位异或(xor)inv() – 按位取反 字符类型Char 类型不是 Number 的子类，也就是说 Char 类型并不是数值类型。 Char 类型使用 单引号 如 &#39;a&#39; 表示。特殊字符使用反斜线转义表达. Kotlin支持的转义字符包括: \t, \b, \n, \r, \&#39;, \&quot;, \\, \$ 。 其他任何字符, 都可以使用 Unicode 转义表达方式: &#39;\uFF00&#39;。 Char 类型也具有一系列的类型转换方法，你可以使用 &#39;0&#39;.toInt() 这样的语法将 Char 类型转换为数值类型。 可以使用 Char? 类型对 Char 类型进行装箱操作，与数值类型一样，装箱操作不能保持对象同一性。 布尔类型Boolean 类型用来表示布尔值, 有两个可能的值: true 和 false. 当需要一个可为 null 的布尔值引用时, 布尔值也会被装箱(box). 布尔值的计算与 Java 相同。 数组类型Kotlin 中的数组通过 Array 类表达, 这个类拥有 get 和 set 函数(这些函数通过运算符重载转换为 [] 运算符), 此外还有 size 属性, 以及其他一些有用的成员函数。 Kotlin 中也有专门的类来表达基本数据类型的数组: ByteArray, ShortArray, IntArray 等等, 这些数组可以避免数值对象装箱带来的性能损耗. 这些类与 Array 类之间不存在继承关系, 但它们的方法和属性是一致的. 各个基本数据类型的数组类都有对应的工厂函数。 1234567891011121314151617181920// 初始化一个 Arrayval array1 = arrayOf(1, 2, 4)// 初始化一个全为 null 的 Arrayval array2 = arrayOfNulls&lt;Int&gt;(10)// IntArray类型val array3 = intArrayOf(1, 2, 3)// ShortArray类型val array4 = shortArrayOf(1, 2, 3)// 使用工厂函数初始化val array5 = Array(10, &#123; i -&gt; i * i&#125;)// 推荐下标访问logError(array5[0])logError(array5.get(0))logError(array5.size) 字符串类型使用双引号 &quot;abc&quot; 表示转移字符串，支持转义字符。使用三个双引号 &quot;&quot;&quot;abc&quot;&quot;&quot; 表示原生字符串，原生字符串不支持转义，可以包含任何转义字符。 1234567891011121314// 默认使用 | 分割val text = """ |Tell me and I forget\n. |Teach me and I remember\t. |Involve me and I learn. |(Benjamin Franklin) """.trimMargin()logError(text)// 输出Tell me and I forget\n.Teach me and I remember\t.Involve me and I learn.(Benjamin Franklin) 字符串模板，转义字符串和原生字符串都支持字符串模板，使用 ${表达式} 的方式可以在字符串中间插入数据。只有一个简单值时可以省略 {} ,同时也支持复杂表达式的计算。转义字符串中你可以使用 \$ 来写入 $ 字符，原生字符串中由于不支持转义字符，你可以使用 ${&quot;$&quot;} 的方式写入 $ 字符。 12345val user = User()val param = 100var str = "test str template like $param"str = "test str template like $&#123;user.name&#125; "str = "test str template like $&#123;if (user.age &lt;= 0) 100 else user.age&#125;" 控制流控制流主要包括判断结构，分支结构，循环结构 if 判断结构123456789101112131415var a = 0if (a == 0) a = 100if (a == 0) a = 100 else a = 1000// 作为表达式时必须有else分支val rst1 = if (a == 0) 100 else 1000// 具有多行语句必须使用&#123;&#125;val rst2 = if (a == 0) &#123; logError(100) 100&#125; else &#123; logError(1000) 1000&#125; when 分支结构Kotlin 使用 when 关键字实现分支结构。 当 when 作为表达式出现时，必须具有 else 分支，除非你的分支已经包含了所有的情况，这是因为作为表达式时他必须有一个返回值，而 else 分支将会在所有条件都不满足时执行。 when 作为表达式 12345678910111213fun testFun3(param: Int): Int = when (param) &#123; // 一般用法 0 -&gt; 0 // 使用 in 操作符匹配范围 in 1..5 -&gt; 1 !in 100..105 -&gt; -1 // 使用多个匹配 5, 6, 7 -&gt; 2 // 类型判断 is Int -&gt; 3 // 作为表达式必须有else分支 else -&gt; 100&#125; 在函数中使用 when 12345678// 作为函数时不需要必须有 else 分支fun testFun5() &#123; val param: Any? = 100 when (param) &#123; // 自动的类型推断，此时param 是 String 类型 is String -&gt; param.startsWith("") &#125;&#125; for 循环结构任何值, 只要能够产生一个迭代器( iterator), 就可以使用 for 循环进行遍历。 能够产生一个迭代器是指： 存在一个成员函数- 或扩展函数 iterator(), 它的返回类型应该 存在一个成员函数- 或扩展函数 next(), 并且 存在一个成员函数- 或扩展函数 hasNext(), 它的返回类型为 Boolean 类型。 遍历数组和 List 12345678910111213141516171819202122232425262728// 遍历临时数组for (item in (1..4)) &#123; logError(item)&#125;// 遍历listval lists = mutableListOf(1, 2, 4)// 遍历itemfor (item in lists) &#123; logError(item)&#125;// 使用下标遍历for (i in lists.indices) &#123; logError(lists.get(i))&#125;// 获取下标和值for((i,item) in lists.withIndex())&#123; logError("$i = $item")&#125;// 遍历数组也是一样的val arrays = arrayOf(1,2,3)for (item in arrays)&#123; logError(item)&#125;for (i in arrays.indices)&#123; logError(arrays[i])&#125; 遍历 map 12345// 遍历mapval maps = mapOf(Pair("a", "b"), Pair("a1", "b1"))for ((key, value) in maps) &#123; logError("map($key-&gt;$value)")&#125; 遍历字符串 12345// 遍历字符串val str = "test"for (s in str)&#123; logError("$s in str")&#125; while 循环结构用法与其他语言是一致的。 12345678910var a = 0while (a &gt; 100) &#123; logError("a is $a") a++&#125;do &#123; logError("a is $a") a++&#125; while (a &gt; 100) 返回与跳转Kotlin 中有三种标签可以跳出程序流程 return. 默认行为是, 从最内层的函数或 匿名函数 中返回。break. 结束最内层的循环。continue. 在最内层的循环中, 跳转到下一次循环。 Kotlin 中的任何表达式都可以用 label 标签来标记。标签的形式与标识符相同, 后面附加一个 @ 符号,如 loopOut@,使用标签标记位置，就可以使用程序跳出操作符跳出指定位置，如 break@loopOut,continue@loopOut,return@loopOut。需要注意的是中间不需要有空格，他们是一体的。如果有标签的同时又有返回值，使用 return@loopOut 100 这样的形式，意为跳出到 loopOut 标签位置，返回值是 100 。 12345678910111213fun testFun6() &#123; loopOut@ for (i in 1..10) &#123; loopIn@ for (j in 10..100) &#123; if (i * j == 100) break@loopOut if (i * j &lt; 10) continue@loopIn if (i * j == 101) break@loopIn logError("result = $&#123;i * j&#125;") &#125; &#125;&#125; 在 Kotlin 中, 通过使用字面值函数(function literal), 局部函数(local function), 以及对象表达式(object expression), 允许实现函数的嵌套。通过标签限定的 return 语句, 可以从一个外层函数中返回. 最重要的使用场景是从 Lambda 表达式中返回。 如下面的例子中，默认会从函数 testFun61() 中返回，返回值为9，而且你写 return 语句时，编译器会提示你必须返回一个 Int 类型。这种非局部的返回(non-local return), 仅对传递给 内联函数(inline function) 的 Lambda 表达式有效。 123456789// 函数会返回 9fun testFun61(): Int &#123; val arrays = Array(10, &#123; i -&gt; i * i &#125;) arrays.forEach &#123; if (it == 9) return it &#125; return 0&#125; 如果需要从内部 Lambda 表达式跳出而不是从函数中返回，可以使用标签指定跳出目标。使用隐含标签会更方便一些, 隐含标签的名称与 Lambda 表达式被传递去的函数名称相同。如下面的隐含标签为 forEach@。 12345678910111213141516171819// 此时返回 0fun testFun62():Int&#123; val arrays = Array(10, &#123; i -&gt; i * i &#125;) arrays.forEach signal@&#123; if (it == 9) return@signal &#125; return 0&#125;// 使用隐含标签fun testFun63():Int&#123; val arrays = Array(10, &#123; i -&gt; i * i &#125;) arrays.forEach &#123; if (it == 9) return@forEach &#125; return 0&#125;]]></content>
      <categories>
        <category>Study</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Kotlin 开发 (番外)]]></title>
    <url>%2Farticle%2F3679990147%2F</url>
    <content type="text"><![CDATA[本篇主要介绍 Kotlin 变量和常量 发现 AS 开发 Kotlin 的时候自动提示等功能有点卡顿，之前还在用Kotlin 1.0.6 的时候这个问题就很显著，现在 1.1.2 也并没有改善，用起来卡卡的有点不爽啊😕，希望尽早优化。今天下载了 Kotlin 下的 Parcelable 插件，用起来还不错，之前用 Java 的时候也基本不会自己去写这个，相信 Kotlin 的各种插件支持也会越来越完善的。 常量变量的声明常量变量的初始化常量变量的引用和 空安全属性代理的相关概念自定义属性代理 空值安全在进行 变量／常量 的初始化时能够感受到 Kotlin 在编译时对 null 值的控制，正是因为 Kotlin 的这些特性，使得 Kotlin 成为一种 空安全(Null Safaty) 的语言，遵循 Kotlin 的规范将有效的避免程序中的 NPE。 其实遵循 Kotlin 的变量的声明和初始化方式基本可以避免 NPE 的出现，Kotlin 不允许给一个 变量 null 值，但是你可以使用 Type? 的形式(例如 String? )声明这是一个可以为 null 的变量，他就可以被初始化为 null。例如你可以这样声明一个可以为 null 的变量 var stuCanBeNull: Student? = null。也就是说变量仍旧可能是 null 的。 安全调用安全调用即 safe calls，使用?.操作符。 当我们访问一个变量的属性或者方法时，为了避免 NPE 我们通常要在前期做严密的空值判断确保调用的对象不为空时才能放心调用，safe calls 的机制大大简化了这个过程。 safe calls 只有当引用不为 null 时才进行调用，否则直接返回 null，如下情况中 b 的类型为 Int?，因为 a 可能为 null，调用 a 的 length 属性，如果 a 不为 null，则返回 Int 类型的长度，反之返回 null，因此 b 为 Int?，即可能为 null 的 Int 类型。 12val a: String? = nullval b = a?.length 一个使用 safe calls 简化调用的实例 123456789val myParam1:Student? = null// java 中，在使用之前，我们通常会做一系列判空操作if(myParam1!=null &amp;&amp; myParam1.myCls!=null)&#123; Log.e(TAG,"$&#123;myParam1.myCls.length&#125;")&#125;// Kotlin safe callsLog.e(TAG,"$&#123;myParam1?.myCls?.length&#125;") 有时我们在判空之后会执行一系列的操作，此时就可以结合 let 关键字，使用 ?.let{} 来确保变量不为空时执行方法，同时在 let 方法体内，可以使用 it 关键字访问变量。 1234val a: String? = nullval b = a?.length// b不为null时进行打印b?.let &#123; log("$it") &#125; Elvis 操作符Elvis 操作符 即 ?: 操作符。当使用 ?. 操作符进行安全调用时，如果遇到 null 则会直接返回 null，那如果当为 null 时返回其他值时如何操作呢？Elvis 操作符 就是用来解决这个问题的。 如果 ?: 左侧的表达式值不是 null, Elvis 操作符 就会返回它的值, 否则, 返回右侧表达式的值. 注意, 只有在左侧表达式值为 null 时, 才会计算右侧表达式。 1234// 原始版本，使用 if...elseval l: Int = if (b != null) b.length else -1// 使用 ?: 操作符val l = b?.length ?: -1 由于在 Kotlin 中 throw 和 return 都是表达式, 因此它们也可以用在 Elvis 操作符 s的右侧. 这种用法可以带来很大的方便, 比如, 可以用来检查函数参数值是否合法: 12345fun foo(node: Node): String? &#123; val parent = node.getParent() ?: return null val name = node.getName() ?: throw IllegalArgumentException("name expected") // ...&#125; !! 操作符如果你确实清楚此时可以抛出一个 NPE，那么你可以使用 !! 操作符。 对于 b 不为 null 的情况, 这个表达式将会返回这个非 null 的值, 如果 b 是 null, 这个表达式就会抛出一个 NPE。 1val l = b!!.length as? 操作符如果对象不是我们期望的目标类型, 那么通常的类型转换就会导致 ClassCastException 。 使用 as? 进行安全的类型转换, 如果转换不成功, 它将会返回 null。 1val aInt: Int? = a as? Int 自定义属性代理自定义属性代理访问SharePreference,可以大大简化数据的读取和写入操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Suppress("UNCHECKED_CAST")class Preference&lt;T&gt;( val context: Context, val name: String, val defaultValue: T) : ReadWriteProperty&lt;Any?, T&gt; &#123; val preference: SharedPreferences by lazy &#123; context.getSharedPreferences("KEY", Context.MODE_PRIVATE) &#125; override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T &#123; return findPreference(name, defaultValue) &#125; override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) &#123; putPreference(name, value) &#125; private fun &lt;U&gt; findPreference(name: String, default: U): U = with(preference) &#123; val res: Any = when (default) &#123; is Long -&gt; getLong(name, default) is String -&gt; getString(name, default) is Int -&gt; getInt(name, default) is Boolean -&gt; getBoolean(name, default) is Float -&gt; getFloat(name, default) else -&gt; throw IllegalArgumentException("This type can be saved into Preferences") &#125; res as U &#125; private fun &lt;U&gt; putPreference(name: String, value: U) &#123; val editor = preference.edit() when (value) &#123; is Long -&gt; editor.putLong(name, value) is String -&gt; editor.putString(name, value) is Int -&gt; editor.putInt(name, value) is Boolean -&gt; editor.putBoolean(name, value) is Float -&gt; editor.putFloat(name, value) else -&gt; throw IllegalArgumentException("This type can be saved into Preferences") &#125; editor.apply() &#125;&#125;// 测试代码class DemoActivity : Activity()&#123; var aInt: Int by Preference(this, "aInt", 0) fun whatever()&#123; println(aInt)//会从SharedPreference取这个数据 aInt = 9 //会将这个数据写入SharedPreference &#125;&#125;]]></content>
      <categories>
        <category>Study</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AS 升级 gradle 到2.3.1异常]]></title>
    <url>%2Farticle%2F2758264870%2F</url>
    <content type="text"><![CDATA[AndroidStudio升级gradle插件版本到2.3.1之后不能运行了，提示MultiDex找不到，由此引发了很多问题。 开始升级插件版本升级到2.3.1，配置project / build.gradle 1classpath "com.android.tools.build:gradle:2.3.1" gradle版本升级到3.3，配置project / gradle / gradle-wrapper.properties 123456#Sun Mar 05 00:36:45 CST 2017distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip 分包引起的问题配置分包123456defaultConfig &#123; multiDexEnabled true &#125; 依赖添加compile 'com.android.support:multidex:1.0.1' 小米的问题一切都ok之后出现了新的问题，Failed to establish session然后无法安装应用，在github上面找到了回答，瞻仰一下。 最后总结就是要把开发者模式的MIUI优化选项给关闭掉，不然安装不了。之前还有一个开启允许Usb安装的选项，不打开的话也无法安装应用，总之小米手机特别一点。 123456789101112Works !for those who suffer from this:enable developer mode - In your phone, go to Settings, About phone and click on MIUI version 7 times. You’ll see a pop up which says you are a developer now. Go back to Settings, Additional settings, Developer options and enable USB Debugging. Connect your phone to your PC/Mac and on the phone authorize your computergo back to Developer options, scroll down to find Turn on MIUI optimization and disable it. Your phone will be rebootedTry it now :)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android编译FFmpeg之HelloWorld]]></title>
    <url>%2Farticle%2F3809198562%2F</url>
    <content type="text"><![CDATA[编译FFmpeg3.3.1的so文件，并在Android工程中使用。 FFmpeg版本：3.3.1 ／ OS：Mac OSX 本文博客链接 GitHub，本文介绍内容请查看hello_world分支 ps: 开始的时候我只编译出了6个so文件，缺少libavdevice.so和libpostproc.so，主要是因为build_andorid.sh的配置不同，现在可以编译出8个so文件，在文章中的图片出现的都是6个so文件，特此声明。 源代码 GitHub - FFmpegAndroidSupport(注意在 hello_world 分支) 配置 NDK 环境打开~/.bash_profile文件，添加ndk的环境变量，最后别忘了source .bash_profile更新配置，完成之后运行 ndk-build -v查看版本，没有提示找不到命令就可以了。 12# ndk export PATH=$&#123;PATH&#125;:/Users/march/AndroidRes/sdk/ndk-bundle 修改 configure修改ffmpeg-3.3.1/configure文件，这个主要是生成的lib包的包名规范成以libxxx.so的形式。 否则生成的so文件在android下是无法加载的，替换过程一定要谨慎，需要全部替换掉。这里我提供一个替换好的configure文件供参考:thumbsup: 1234567891011# 找到下面几行替换一下SLIBNAME_WITH_MAJOR='$(SLIBNAME).$(LIBMAJOR)' LIB_INSTALL_EXTRA_CMD='$$(RANLIB)"$(LIBDIR)/$(LIBNAME)"' SLIB_INSTALL_NAME='$(SLIBNAME_WITH_VERSION)' SLIB_INSTALL_LINKS='$(SLIBNAME_WITH_MAJOR)$(SLIBNAME)'# 替换后的结果SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)' LIB_INSTALL_EXTRA_CMD='$$(RANLIB)"$(LIBDIR)/$(LIBNAME)"' SLIB_INSTALL_NAME='$(SLIBNAME_WITH_MAJOR)' SLIB_INSTALL_LINKS='$(SLIBNAME)' 编写 build_android.sh 脚本编写ffmpeg-3.3.1/build_android.sh脚本注意,NDK后面的路径换成自己的路径，可以参考编写好的文件:smile: 关注下面的配置，不要直接拷贝--disable-avdevice加上之后将不会生成avdevice.so文件--enable-gpl加上之后将会生成postproc.so文件 123456789101112131415161718192021222324252627282930313233343536373839#!/bin/shNDK=/Users/march/AndroidRes/sdk/ndk-bundleSYSROOT=$NDK/platforms/android-23/arch-armTOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64function build_one&#123;./configure \--target-os=linux \--prefix=$PREFIX \--arch=arm \--disable-doc \--enable-shared \--disable-static \--disable-yasm \--disable-symver \--enable-gpl \--disable-ffmpeg \--disable-ffplay \--disable-ffprobe \--disable-ffserver \--disable-doc \--disable-symver \--cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \--enable-cross-compile \--sysroot=$SYSROOT \--extra-cflags="-Os -fpic $ADDI_CFLAGS" \--extra-ldflags="$ADDI_LDFLAGS" \$ADDITIONAL_CONFIGURE_FLAGmake cleanmakemake install&#125;make cleanCPU=armPREFIX=$(pwd)/android/$CPUADDI_CFLAGS="-marm"build_one 编译生成 ffmpeg so 库执行build_android.sh脚本如果没有权限可以使用chomd +x增加执行权限然后等一段时间，😯不，是很长时间，所以前面的配置要谨慎，不然编译完了之后发现有问题，就会很💔，你会发现在FFmpeg中出现了一个名为android的文件夹。目录如下 将编译生成的文件 copy 到 AS 中目录如下，jniLibs里面是最后我们编译生成好之后拷贝进去的，现在应该是空的，编译生成的so文件会生成在src/main/libs目录里面，生成好之后，如果你使用jniLibs目录加载so,就拷贝到这里。图片中的描述略有歧义。 编写 C 语言的 JNI 接口这里是拷贝了别人写好的代码，这篇文章主要还是把整个编译流程完成，因此直接用了别人已经写好的，后面的文章会对这一块详细介绍。 编写文件名为ffmpeg_support.c的c文件，声明java调用接口，函数命名需要按照Java_包名_类名_方法名的形式来编写，区分大小写。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include "libavcodec/avcodec.h"#include "libavformat/avformat.h"#include "libavfilter/avfilter.h"#ifdef ANDROID#include &lt;jni.h&gt;#include &lt;android/log.h&gt;#define LOGE(format,...) __android_log_print(ANDROID_LOG_ERROR,"myndk",format,##__VA_ARGS__)#else#define LOGE(format,...) printf("(&gt;_&lt;)"format "\n",##__VA_ARGS__)#endifJNIEXPORT jstring Java_com_march_fas_FFmpegSupport_ffmpegHello(JNIEnv *env,jobject obj)&#123; char info[40000] =&#123;0&#125;; av_register_all(); AVCodec *c_temp = av_codec_next(NULL); while(c_temp != NULL)&#123; if(c_temp-&gt;decode!=NULL)&#123; sprintf(info,"%s[Dec]",info); &#125;else&#123; sprintf(info,"%s[Enc]",info); &#125; switch(c_temp-&gt;type)&#123; case AVMEDIA_TYPE_VIDEO: sprintf(info,"%s[Video]",info); break; case AVMEDIA_TYPE_AUDIO: sprintf(info,"%s[AUDIO]",info); break; default: sprintf(info,"%s[Other]",info); break; &#125; sprintf(info,"%s[%10s]\n",info,c_temp-&gt;name); c_temp=c_temp-&gt;next; LOGE("chendong"); &#125; return (*env)-&gt;NewStringUTF(env,info);&#125; 编写 Android.mk12345678910111213141516171819202122232425262728293031323334353637383940LOCAL_PATH :=$(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := avcodecLOCAL_SRC_FILES := libavcodec-57.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := avfilterLOCAL_SRC_FILES := libavfilter-6.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := avformatLOCAL_SRC_FILES := libavformat-57.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := avutilLOCAL_SRC_FILES := libavutil-55.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := swresampleLOCAL_SRC_FILES := libswresample-2.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := swscaleLOCAL_SRC_FILES := libswscale-4.soinclude $(PREBUILT_SHARED_LIBRARY)#Programinclude $(CLEAR_VARS)LOCAL_MODULE :=sffhelloworldLOCAL_SRC_FILES := simplest_ffmpeg_helloworld.cLOCAL_C_INCLUDES += $(LOCAL_PATH)/includeLOCAL_LDLIBS := -llog -lzLOCAL_SHARED_LIBRARIES := avcodec avfilter avformat avutil swresample swscaleinclude $(BUILD_SHARED_LIBRARY) 编写 Application.mk关于Application.mk的相关配置可以查看官方文档下面android-14指的是最小支持的AndroidApi在4.0以上，具体看可以查看官方文档APP_PLATFORM这块的内容。这个跟你在manifest文件里面配置的min-sdk也有些关联，不拼配会有警告，不过现在都会在gradle文件中配置minSdk，不用在意也可以，实在强迫症就在manifest里面再声明一次。 12APP_ABI := armeabi armeabi-v7aAPP_PLATFORM := android-14 编译生成可用的 so 文件local.properties 如下配置ndk目录,通常是默认配置好的。 12ndk.dir=/Users/march/AndroidRes/sdk/ndk-bundlesdk.dir=/Users/march/AndroidRes/sdk 然后进入到terminal，cd到jni目录，执行 ndk-build 命令等待一段时间编译完成的结果应该是这样的，如果你使用jniLibs目录作为加载so的目录，将so文件拷贝到jniLibs中。 在 app/build.gradle 配置以下代码，可以将 jniLibs 目录指向 libs，这样就不需要每次拷贝 so 文件到 jniLibs 了 12345678sourceSets &#123; //定义编译时编译文件的路径 main &#123; res.srcDirs = ['src/main/res'] jniLibs.srcDirs = ['src/main/libs'] jni.srcDirs = [] &#125; &#125; 调用 JNI加载so文件以及java层的调用接口 123456789101112131415161718192021222324252627282930public class FFmpegSupport &#123; static &#123; try &#123; System.loadLibrary("avutil-55"); System.loadLibrary("swresample-2"); System.loadLibrary("avcodec-57"); System.loadLibrary("avformat-57"); System.loadLibrary("swscale-4"); System.loadLibrary("avfilter-6"); System.loadLibrary("ffmpeg_support"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static native String ffmpegHello();&#125;// 测试public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); FFmpegSupport.ffmpegHello(); &#125;&#125; 运行项目编辑app/build.gradle配置好so加载路径，将so文件拷贝进jniLibs目录，当然你如果喜欢放在libs目录里面也是可以的，一定要记得armeabi/xxx.so，abi目录不要忘记，不然会提示找不到，不要问我为什么特别提醒 :smile: 1234567sourceSets &#123; //定义编译时编译文件的路径 main &#123; res.srcDirs = [&apos;src/main/res&apos;] jniLibs.srcDirs = [&apos;src/main/jniLibs&apos;] &#125; &#125; 点击运行，出现了以下错误：Your project contains C++ files but it is not using a supported native build system。下面的配置可以解决这个问题。 123456789101112// 在gradle.properties添加Android.useDeprecatedNdk=true// 在app/build.gradle 添加jni.srcDirs = []这一行sourceSets &#123; //定义编译时编译文件的路径 main &#123; res.srcDirs = [&apos;src/main/res&apos;] jniLibs.srcDirs = [&apos;src/main/jniLibs&apos;] jni.srcDirs = [] &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Ndk</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>FFmpeg</tag>
        <tag>Ndk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Kotlin 开发-1 (新特性篇)]]></title>
    <url>%2Farticle%2F3395269050%2F</url>
    <content type="text"><![CDATA[Google 2017 IO大会宣布Kotlin作为Android一级开发语言，一时间各大技术博客网站，微信订阅号，朋友圈都被kotlin刷屏了，全都是对kotlin的简要介绍，现在过了大约一周感觉大家慢慢平静下来了，发布的文章的质量也更高，更有针对性，相信不久的将来再广大开发者的推动下，kotlin会发展的越来越好。 就像Google发布Android专用的开发工具AndroidStudio一样，仅仅一年多的时间，Eclipse和Idea在Android开发领域就被完全取代了，Google的决心是看得见的。kotlin能够与Java无缝兼容，性能更好，语法更优雅，又有类型推断，函数式编程等新特性支持，相信在Android开发领域，取代Java只是时间问题，毕竟是官网支持的。 本文是对Kotlin的第一次接触，重点放在项目搭建和新特性的体验上，更深的细节将会放在后面的文章中研究，go ~ 推荐文章Kotlin 官网和对应中文版，这个中文版文档的风格和官网风格一样，对比看起来舒服一点，推荐。 kotlin官网文档 ／ http://kotlinlang.org Kotlin官方文档中文翻译版本 ／ http://www.liying-cn.net/kotlin/ Kotlin 的两篇推荐文章，很早就在推荐使用了 微信文章-你为什么需要kotlin Segmentfault上腾讯bugly的一篇文章，介绍了kotlin的基本特性 另外备注几份参考文档，各有优势，作补充用 kotlin官网文档中文版 ／ https://hltj.gitbooks.io &lt; kotlin for andriod developer&gt; 中文翻译版 ／ https://wangjiegulu.gitbooks.io https://huanglizhuo.gitbooks.io 基本配置AS 3.0 已经自带了Kotlin的配置，本文在 AS 2.3 基础上进行配置。 打开Setting -&gt; plugin下载插件，重启AS，创建项目 -&gt; new File -&gt; Kotlin Activity，会提示配置相关信息，点击配置即可，插件会在工程中作下面的相关配置，以上可以使用IDE很快完成，整体项目没有很大变化。 project/build.gradle文件 123456buildscript &#123; ext.kotlin_version = '1.0.6' dependencies &#123; classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version" &#125;&#125; app/build.gradle 文件 1234567891011121314151617181920212223242526272829apply plugin: 'com.android.application'apply plugin: 'kotlin-android'// 基于Android的扩展增强apply plugin: 'kotlin-android-extensions'android &#123; compileSdkVersion 25 buildToolsVersion "25.0.1" defaultConfig &#123; ... &#125; buildTypes &#123; ... &#125; // 资源路径 sourceSets &#123; main.java.srcDirs += 'src/main/kotlin' &#125;&#125;dependencies &#123; // kotlin compile "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"&#125;// 需要加入这个repositories &#123; mavenCentral()&#125; 汇总一些细节 Kotlin 不强制在每句代码后面加 ;。 Kotlin 不支持三目运算符了，可以使用 if(condition) 表达式1 else 表达式2 的方式代替，比如 val a = if(b&gt;0) 100 else 0 不再使用 new 关键字创建对象，而是更简单的 val user = User() 与 Java 相反，Kotlin 中所有类和方法都默认是不允许继承的，也就是 final 的，如果想要继承类或重写方法可以使用 open 关键字。 Kotlin 中类名不必与文件同名，函数也不是必须声明在类中才可以，可以直接声明在文件中。 Kotlin 中注释允许嵌套。 使用 is 代替 instanceof ，如 if(str is String){...} 引用xml中的控件再也不用 findViewById() 也不用 ButterKnife 注解啦. 这种扩展在性能上和 findViewById() 是一样的，另外需要注意的是，使用这种扩展必须要在 layout 被设置好了才能使用, 在 fragment 里面, 要等到 onViewCreated() 之后才能使用. 12345678910111213141516&lt;!--在xml定义，id为 mTestTv --&gt;&lt;TextView android:id="@+id/mTestTv" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#fff" android:gravity="center" android:text="test" android:textColor="#000" android:textSize="18sp"/&gt;// app/build.gradle中扩展增强插件apply plugin: 'kotlin-android-extensions' import kotlinx.android.synthetic.main.main_activity.*mTestTv.text = "test it" 空值安全(Null Safety)Kotlin 是一种空值安全的语言，他基本能帮助你告别 NPE，并且提供了大量的操作符简化判空操作，更多内容将在下一篇文章&lt;常量变量篇&gt;中详细介绍。 一个使用 safe calls 简化调用的实例 123456789val myParam1:Student? = null// java 中，在使用之前，我们通常会做一系列判空操作if(myParam1!=null &amp;&amp; myParam1.myCls!=null)&#123; Log.e(TAG,"$&#123;myParam1.myCls.length&#125;")&#125;// Kotlin safe callsLog.e(TAG,"$&#123;myParam1?.myCls?.length&#125;") 字符串模版再也不用 + 或者 StringBuilder 来回拼接和计算字符串，kotlin提供了更加优雅的实现方式。 使用 ${表达式} 的方式可以在字符串中间插入数据。只有一个简单值时可以省略 {} ,同时也支持复杂表达式的计算。 12345val user = User()val param = 100var str = "test str template like $param"str = "test str template like $&#123;user.name&#125; "str = "test str template like $&#123;if (user.age &lt;= 0) 100 else user.age&#125;" 扩展函数和属性Kotlin 提供了向一个类扩展新功能的能力，而且不必从这个类继承, 也不必使用任何设计模式, 比如 Decorator 模式之类。 这种功能是通过一种特殊的声明来实现的, Kotlin 中称为 扩展(extension)。 Kotlin 支持 扩展函数(extension function) 和 扩展属性(extension property)。 另外我刚开始看这个地方的时候，是将扩展函数声明在使用它的类中，在另一个类中要使用就无法引用了，难道每次都要重新写？那不是很鸡肋。其实由于 java 的惯性，我觉得所有的方法必须声明在类中，java 中确实是这样的， 但是 Kotlin 不必这样做，你的类文件的名字可以不和文件名相同，函数也可以直接声明在文件中，而不是某个类中。 注意：不需要声明 class，扩展方法和属性是静态加载的， 直接写在 .kt 文件中即可。 注意：在扩展属性的 get() 方法中不要访问该属性，因为你一旦访问该属性，就会调用 get() 方法，从而造成堆栈溢出。 新建 ContextExtensions.kt 文件，在里面声明该扩展函数和扩展属性 12345678910111213// 扩展函数fun Context.logError(msg: String) &#123; Log.e(this.javaClass.simpleName, msg)&#125;// 扩展属性var Context.extensionProperty: String get() &#123; return javaClass.simpleName &#125; set(value) &#123; extensionProperty = value &#125; 接下来就可以在任何 Context 的实现类，比如 Activity 中使用 logError() 函数和 extensionProperty 属性 1234// 扩展函数logError("方法扩展")// 扩展属性logError(extensionProperty) 自动类型推断Kotlin支持自动的类型推断，比如我们可以如下声明一个常量，那么常量 myStr 的类型被推断为 String 类型。可以使用 String 的API。 12val myStr = ""Log.e(tag,"str length = $&#123;myStr.length&#125;") 当进行显示类型转换时，自动进行类型推断，下面声明了两个类，Student 继承自 User ,在 stuUser is Student 的判断之后，stuUser 的类型被推断为 Student ，因此可以直接访问 myClass 属性。 123456789101112open class User(val name: String, val age: Int) &#123; // 二级构造函数 constructor() : this("", 0)&#125;class Student(name: String, age: Int,val myCls: String) : User(name, age)// 自动类型推断val stuUser = User()if (stuUser is Student) &#123; // 这里stuUser已经是Student类型，不需要进行强制转换。 Log.e(tag, stuUser.myCls)&#125; 支持 lambda 表达式使用 lambda 表达式可以使代码更加清晰，原来一层一层的 {} 都被省略掉了，不可否认的是可读性要比原来差一点，不过习惯了就好多了。 另外 Kotlin 也为 lambda 表达式提供了很多扩展支持，来强化 lambda 表达式的使用，在kotlin中,如果函数的最后一个参数是函数，那么这个参数可以直接写在圆括号外面（要用花括号），如果只有一个函数参数，可以直接省略圆括号！而且当参数只有一个时可以省略参数而使用 it 来代替。 12345678910111213141516171819mTestTv.setOnClickListener &#123; v -&gt; run &#123; logError("test" + v.id) &#125;&#125;mTestTv.setOnClickListener &#123; v -&gt; if (v.id == 0) &#123; logError("test$&#123;v.id&#125;)") &#125; else &#123; logError( "test$&#123;v.id&#125;)") &#125;&#125;mTestTv.setOnClickListener &#123; logError("test$&#123;it.id&#125;)")&#125; 函数是一等公民函数是一等公民指的是函数和对象，基本数据类型一样，可以作为变量，可以作为参数传递，可以作为返回值。 函数不依赖于类，可以独立存在。 Kotlin支持函数式编程。函数声明的方式为 (参数名:参数类型...)-&gt; 返回值类型 ，比如 (param:String)-&gt;Int ，指的是一个参数为 String 类型，返回值是 Int 类型的函数，如果没有返回值则使用 Unit 关键字。 刚开始尝试像使用变量一样使用函数，有些不太适应，当你需要将函数进行传递赋值时，先写一个 {}，将函数声明在 {} 中即可； 尝试简单声明函数 12345678fun myFun(param: String): Int &#123; logError("函数") return param.hashCode()&#125;fun myFunReturnVoid(param: String): Unit &#123; logError("声明函数返回空")&#125; 函数作为变量 12345678// 函数作为变量val funVal: (param: String) -&gt; Int = &#123; // 参数param param: String -&gt; // 返回hashcode param.hashCode()&#125;funVal("测试函数作为变量调用") 函数作为参数，下面的函数接受一个参数为 String 返回值为 Int 的函数作为参数，并调用他。lis 是形参，(String) -&gt; Int)是函数类型。下面的两个重载函数的例子，是为了展示只有一个函数参数时的简化写法，多个参数时使用常规写法。结合上面 lambda 表达式的相关用法。 12345678910111213141516171819// 只有一个函数做参数，并且只有一个参数fun testFunOneFunParam(lis: (String) -&gt; Int): Int &#123; return lis("测试函数作为参数传递,只有一个函数作为参数")&#125;// 有多个参数，并且函数不是最后一个fun testFunMultiParam(lis: (String) -&gt; Int, param: String): Int &#123; return lis("测试函数作为参数传递,第一个参数是函数")&#125;// 调用testFunOneFunParam &#123; param -&gt; param.hashCode()&#125;testFunMultiParam(&#123; param -&gt; param.hashCode()&#125;, "测试函数不是作为第一个参数的情况") 函数作为返回值 12345678910// 函数作为返回值fun returnFun(param: String): ((intParam: Int) -&gt; String) &#123; return &#123; intParam -&gt; "int param is $intParam param is $param" &#125;&#125;// 调用returnFun("执行完返回一个函数")(100) 单表达式函数，当函数的返回值只有一个简单表达式时，可以使用单表达式函数，简化代码 123456789// 单表达式函数fun testFun2() = 100// 单表达式函数结合whenfun testFun3(param: Int) = when (param) &#123; 0 -&gt; 0 in 1..5 -&gt; 1 5, 6, 7 -&gt; 2 else -&gt; 100&#125; 数据类我们经常会创建一些数据类, 什么功能也没有, 而仅仅用来保存数据. 在这些类中, 某些常见的功能经常可以由类中保存的数据内容即可自动推断得到. 在 Kotlin 中, 我们将这样的类称为 数据类, 通过 data 关键字标记； 定义一个数据类，只需要一行代码即可，{} 可以省略掉，数据类会默认生成 equals() ，toString() ， copy() 等方法，这里特别提一下 copy() ，可以生成一个新的数据，这个特性是相当不错的。 当然数据类也有很多限制 主构造器至少要有一个参数;主构造器的所有参数必须标记为 val 或 var;数据类不能是abstract类, open 类, 封闭(sealed)类, 或内部(inner)类;数据类不能继承自任何其他类(但可以实现接口). 1234data class DataModel(val param1: String, val param2: Int)// 使用val dataModel = DataModel("p1",100)dataModel.copy("p2",99) 数据类添加成员方法 123456data class DataModel(val param1: String, val param2: Int) &#123; fun speak(msg: String) &#123; Log.e("DataModel", "speak$msg") &#125;&#125;dataModel.speak("haha")]]></content>
      <categories>
        <category>Study</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL]]></title>
    <url>%2Farticle%2F1299261529%2F</url>
    <content type="text"><![CDATA[1. 前言 SQL，指结构化查询语言，全称是(Structured Query Language)，SQL 语句是大小写不敏感的。说明：使用db_name作为数据库名，使用tb_name作为表名。使用col_name作为列名，使用row_name作为行名。使用alias_name作为别名。[xxx]表示可选使用的属性。(a…|b…|c…)表示三种情况任选一种使用。 2. 数据库配置123456789编辑 ./bash_profile 文件，加入别名open ~/.bash_profile# mysqlalias mysql=/usr/local/mysql/bin/mysql连接到mysql服务mysql -u root -p 3. 库操作语句1234567891011121314显示数据库列表SHOW databases;创建数据库CREATE DATABASE db_name; 使用数据库USE db_name; 删除数据库DROP database db_name;使用字符集SET names utf8; 4. 表操作语句关于表字段约束的讲解见附2 123456789101112131415161718192021222324252627282930313233343536373839404142434445创建表CREATE TABLE table_name(col_name1 data_type(size) [约束],col_name2 data_type(size) [约束],col_name3 data_type(size) [约束],....);eg:CREATE TABLE Persons(PersonID int,LastName varchar(255),FirstName varchar(255),Address varchar(255),City varchar(255));删除表DROP TABLE tb_name;删除表数据，但是保留表结构TRUNCATE TABLE tb_name增加一列ALTER TABLE tb_name ADD col_name 数据类型 [约束]删除一列ALTER TABLE tb_name DROP COLUMN col_name;修改一列ALTER TABLE tb_name ALTER old_col_name new_col_name 数据类型 [约束]修改一列的数据类型/* SQL Server / MS Access */ALTER TABLE tb_nameMODIFY COLUMN col_name 数据类型/* My SQL / Oracle */ALTER TABLE tb_nameALTER COLUMN col_name 数据类型添加主键ALTER TABLE tb_name ADD PRIMARY KEY(col_name);删除主键ALTER TABLE tb_name DROP PRIMARY KEY(col_name); 5. 增删改查语句5.1 SELECT 语句123456基本查询语句[DISTINCT] 可选，用于返回唯一不同的值。SELECT [DISTINCT] * FROM tb_name;SELECT [DISTINCT] col_name1,col_name2 FROM tb_name;eg:SELECT name,country FROM Websites; 5.2 SELECT INTO 语句使用SELECT INTO和 INSERT INTO SELECT 语句，复制表数据。MySQL 数据库不支持 SELECT INTO 语句，但支持 INSERT INTO SELECT。新表将会使用 SELECT 语句中定义的列名称和类型进行创建。您可以使用 AS 关键字来应用新名称。 12345678910111213141516171819复制全部数据或者使用WHERE子句筛选SELECT *INTO new_tb_name [IN db_name]FROM old_tb_name;or复制指定列数据或者使用WHERE子句筛选SELECT col_name...INTO new_tb_name [IN db_name]FROM old_tb_name;复制全部数据或者使用WHERE子句筛选INSERT INTO new_tb_nameSELECT * FROM old_tb_name;or复制指定列数据或者使用WHERE子句筛选INSERT INTO new_tb_name(col_name...)SELECT col_name...FROM old_tb_name; 5.3 INSERT INTO 语句1234567891011// 不指定列名插入INSERT INTO tb_nameVALUES (value1,value2,value3,...);// 指定列名插入INSERT INTO tb_name (col_name1,col_name2,col_name3,...)VALUES (value1,value2,value3,...);eg:INSERT INTO Websites (name, url, country)VALUES ('stackoverflow', 'http://stackoverflow.com/', 'IND'); 5.4 UPDATE 语句12345678910使用UPDATE语句时，一定要添加WHERE条件，否则会更新所有的数据。UPDATE tb_nameSET col_name1=value1,col_name2=value2,...WHERE (这里参照WHERE子句，匹配指定数据);eg:UPDATE Websites SET alexa='5000', country='USA' WHERE name='aasdfghjkl'; 5.5 DELETE 语句123456789DELETE FROM tb_nameWHERE (这里参照WHERE子句，匹配指定数据);DELETE * FROM tb_nameWHERE (这里参照WHERE子句，匹配指定数据);eg:DELETE FROM WebsitesWHERE name='百度' AND country='CN'; 6. WHERE 子句1234SELECT col_name1,col_name2FROM tb_nameWHERE col_name1 operator value1 [逻辑运算符 col_name2 operator value2...]; 6.1 逻辑运算符1234567891011逻辑运算符NOT 非操作AND 与操作，表达式前后条件必须都成立才为trueOR 或操作，表达式前后操作有一个成立即为true逻辑运算的优先级：() NOT AND OReg:SELECT * FROM WebsitesWHERE alexa &gt; 15AND (country='CN' OR country='USA'); 6.2 比较运算符123456789101112131415161718192021222324252627282930313233343536373839/*比较运算符=,&gt;,&lt;,&gt;=,&lt;=,&lt;&gt;(不等于，一些版本中写作!=),BETWEEN...AND(在范围内),LIKE(模糊查询),IN(指定所有可能值进行匹配),IS NULL(空值判断)*/eg:空值查询 IS NULLSELECT * FROM tb)nae WHERE col_name IS NULL;存在查询 INSELECT * FROM tb_name WHERE col_name IN (5000,3000,1500);SELECT * FROM tb_name WHERE col_name IN ('abc','tyu','test');区间查询 BETWEEN...AND...区间查询两边都是闭区间，类似[1,100]SELECT * FROM tb_name WHERE col_name BETWEEN 100 AND 200;模糊查询 LIKESELECT * FROM tb_name WHERE col_name LIKE 'M%';todo 模糊查询通配符% 表示多个字值，_ 下划线表示一个字符。 M% : 为能配符，正则表达式，表示的意思为模糊查询信息为 M 开头的。 %M% : 双百分号表示查询的信息在内容中间。 %M_% : 表示查询的字母在内容的倒数第二位。 7. JOIN 子句(表连接)JOIN 子句用于基于这些表之间的共同字段把来自两个或多个表的行结合起来。 连接方式 描述 INNER JOIN 如果表中有至少一个匹配，则返回行 LEFT JOIN 即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN 即使左表中没有匹配，也从右表返回所有的行 FULL JOIN 只要其中一个表中存在匹配，则返回行 7.1 INNER JOIN 内连接INNER JOIN 也可以简写为 JOININNER JOIN关键字在表中存在至少一个匹配时返回行。1234SELECT col_nameFROM tb_name1INNER JOIN tb_name2ON tb_name1.col_name=tb_name2.col_name; 7.2 LEFT OUTER JOIN 左外连接LEFT OUTER JOIN也可以简写为 LEFT JOINLEFT JOIN 关键字从左表返回所有的行，即使右表中没有匹配，如果右表中没有匹配，则结果为 NULL。1234SELECT col_nameFROM tb_name1LEFT OUTER JOIN tb_name2ON tb_name1.col_name=tb_name2.col_name; 7.3 RIGHT OUTER JOIN 右外连接RIGHT OUTER JOIN 也可以简写为 RIGHT JOINRIGHT JOIN 关键字从右表返回所有的行，即使左表中没有匹配，如果左表中没有匹配，则结果为NULL。1234SELECT col_nameFROM tb_name1RIGHT OUTER JOIN tb_name2ON tb_name1.col_name=tb_name2.col_name; 7.4 FULL OUTER JOIN 全外连接FULL OUTER JOIN 关键字只要左表 和右表 其中一个表中存在匹配，则返回行.FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。1234SELECT col_nameFROM tb_name1FULL OUTER JOIN tb_name2ON tb_name1.col_name=tb_name2.col_name; 8. 关键字8.1 AS 关键字,使用别名使用AS关键字，可以为表名称或列名称指定别名，基本上，创建别名是为了让列名称的可读性更强，以下情况使用别名很有用。 在查询中涉及超过一个表 在查询中使用了函数 列名称很长或者可读性差 需要把两个列或者多个列结合在一起 ps:别名如果包含空格，要求使用双引号或方括号。 12345678910111213141516列别名用法使用列别名查询之后的展示数据将使用别名来展示SELECT col_name AS alias_nameFROM tb_name;eg:SELECT name AS n, country AS cFROM Websites;表别名用法SELECT col_nameFROM tb_name AS alias_name;eg:SELECT w.name, w.url, a.count, a.date FROM Websites AS w, access_log AS a WHERE a.site_id=w.id and w.name="百度"; 8.2 ORDER BY 关键字12345678910ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。SELECT col_name1,col_name2FROM tb_nameORDER BY col_name (ASC|DESC)[,col_name (ASC|DESC)...];eg:SELECT * FROM WebsitesORDER BY alexa DESC; 8.3 LIMIT 关键字12345使用limit关键字，可以跳过m条数据，查询n条数据，m可以省略，表示从头开始查询。SELECT * FROM tb_name LIMIT [m,]n;eg：SELECT * FROM Websites LIMIT 3,2; 8.4 UNION 关键字UNION 操作符用于合并两个或多个 SELECT 语句的结果集。UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。UNION 只会选取不同的值。请使用 UNION ALL 来选取重复的值！ 1234567SELECT col_name FROM tb_name1UNIONSELECT col_name FROM tb_name2;SELECT col_name FROM tb_name1UNION ALLSELECT col_name FROM tb_name2; 9. 函数9.1 CONCAT()连接函数结果将会拼接CONCAT()函数中的全部值 1234下面的例子将会拼接三个字段的值(结果：'www.baidu.com,100,china')，并作为一列(site_info)显示SELECT name, CONCAT(url, ', ', alexa, ', ', country) AS site_infoFROM Websites; 10. 索引在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。在表中创建索引，以便更加快速高效地查询数据。用户无法看到索引，它们只能被用来加速搜索/查询。更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。 10.1 创建索引12345678910111213141516创建一个简单的索引。允许使用重复的值：CREATE INDEX index_nameON table_name (column_name)在表上创建一个唯一的索引。不允许使用重复的值：唯一的索引意味着两个行不能拥有相同的索引值。 CREATE UNIQUE INDEX index_nameON table_name (column_name)注释：用于创建索引的语法在不同的数据库中不一样。因此，检查您的数据库中创建索引的语法。 eg:创建索引CREATE INDEX PIndexON Persons (LastName)在多个列上创建索引CREATE INDEX PIndexON Persons (LastName, FirstName) 10.2 删除索引12345678/* MS Access */DROP INDEX index_name ON table_name/* MS SQL Server */DROP INDEX table_name.index_name/* DB2/Oracle */DROP INDEX index_name/* MySQL */ALTER TABLE table_name DROP INDEX index_name 附1. 模糊查询附1.1. 通配符 通配符 描述 示例 % 代替0个或者多个字符 chen%,匹配chen开头的全部数据 _ 代替一个字符 ch_n,匹配类似chan,chbn,chcn这种数据 [charlist] 字符序列中的任一个单个字符 [ABC],匹配A,B,C [^charlist] or [!charlist] 不在字符序列中的任一个字符 [!ABC],匹配除了A,B,C以外的其他字符 123SELECT col_nameFROM tb_nameWHERE col_name LIKE pattern; 附1.2 正则表达式1todo 附2. 表约束 约束 描述 NOT NULL 指示某列不能存储 NULL 值。 UNIQUE 保证某列的每行必须有唯一的值。 PRIMARY KEY NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。 FOREIGN KEY 保证一个表中的数据匹配另一个表中的值的参照完整 性。 CHECK 保证列中的值符合指定的条件。 DEFAULT 规定没有给列赋值时的默认值。 附2.1 NOT NULL 非空约束NOT NULL 约束强制列不接受NULL值。NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。 1234567CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255)); 附2.2 UNIQUE 唯一约束UNIQUE 约束唯一标识数据库表中的每条记录。UNIQUE和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。PRIMARY KEY 约束拥有自动定义的 UNIQUE 约束。请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。 1234567891011121314151617181920212223242526272829303132/* MySQL */CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),UNIQUE (P_Id))/* SQL Server / Oracle / MS Access */CREATE TABLE Persons(P_Id int NOT NULL UNIQUE,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255))命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName)) 更改UNIQUE约束12345678910111213ALTER TABLE PersonsADD UNIQUE (P_Id)如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，请使用下面的 SQL 语法：ALTER TABLE PersonsADD CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName)撤销 UNIQUE 约束 MySQL：ALTER TABLE PersonsDROP INDEX uc_PersonIDSQL Server / Oracle / MS Access：ALTER TABLE PersonsDROP CONSTRAINT uc_PersonID 附2.3 PRIMARY KEY 主键约束PRIMARY KEY 约束唯一标识数据库表中的每条记录。主键必须包含唯一的值。主键列不能包含 NULL 值。每个表都应该有一个主键，并且每个表只能有一个主键。 123456789101112131415161718192021222324252627282930313233/* MySQL */CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),PRIMARY KEY (P_Id))/* SQL Server / Oracle / MS Access */CREATE TABLE Persons(P_Id int NOT NULL PRIMARY KEY,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255))命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束 CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName))注释：在上面的实例中，只有一个主键 PRIMARY KEY（pk_PersonID）。然而，pk_PersonID 的值是由两个列（P_Id 和 LastName）组成的。 更改PRIMARY KEY约束123456789101112131415ALTER TABLE PersonsADD PRIMARY KEY (P_Id)如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束，请使用下面的 SQL 语法：ALTER TABLE PersonsADD CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName)注释：如果您使用 ALTER TABLE 语句添加主键，必须把主键列声明为不包含 NULL 值（在表首次创建时）。撤销 PRIMARY KEY 约束/* MySQL */ALTER TABLE PersonsDROP PRIMARY KEY/* SQL Server / Oracle / MS Access */ALTER TABLE PersonsDROP CONSTRAINT pk_PersonID 附2.4 FOREIGN KEY 外键约束一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。FOREIGN KEY 约束用于预防破坏表之间连接的行为。FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。 例如：我们现在有Persons表用来存储用户信息，Persons表主键P_Id表示用户id，Orders表用来存储用户订单，Orders表外键P_Id指向 Persons表的主键P_Id，来约束Orders表中所有订单的用户id必须是在用户表中出现的。 Orders 表中的 P_Id 列指向 Persons 表中的 P_Id 列。 Persons 表中的 P_Id 列是 Persons 表中的 PRIMARY KEY。 Orders 表中的 P_Id 列是 Orders 表中的 FOREIGN KEY。 1234567891011121314151617181920212223242526272829/* MySQL */CREATE TABLE Orders(O_Id int NOT NULL,OrderNo int NOT NULL,P_Id int,PRIMARY KEY (O_Id),FOREIGN KEY (P_Id) REFERENCES Persons(P_Id))/* SQL Server / Oracle / MS Access */CREATE TABLE Orders(O_Id int NOT NULL PRIMARY KEY,OrderNo int NOT NULL,P_Id int FOREIGN KEY REFERENCES Persons(P_Id))命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束CREATE TABLE Orders(O_Id int NOT NULL,OrderNo int NOT NULL,P_Id int,PRIMARY KEY (O_Id),CONSTRAINT fk_PerOrders FOREIGN KEY (P_Id)REFERENCES Persons(P_Id)) 更改外键约束 1234567891011121314151617ALTER TABLE OrdersADD FOREIGN KEY (P_Id)REFERENCES Persons(P_Id)如需命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束，请使用下面的 SQL 语法：ALTER TABLE OrdersADD CONSTRAINT fk_PerOrdersFOREIGN KEY (P_Id)REFERENCES Persons(P_Id)撤销 FOREIGN KEY 约束 /* MySQL */ALTER TABLE OrdersDROP FOREIGN KEY fk_PerOrders/* SQL Server / Oracle / MS Access */ALTER TABLE OrdersDROP CONSTRAINT fk_PerOrders 附2.5 CHECK 约束CHECK 约束用于限制列中的值的范围。如果对单个列定义 CHECK 约束，那么该列只允许特定的值。如果对一个表定义 CHECK 约束，那么此约束会基于行中其他列的值在特定的列中对值进行限制。1234567891011121314151617181920212223242526272829303132/* MySQL */CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CHECK (P_Id&gt;0))/* SQL Server / Oracle / MS Access */CREATE TABLE Persons(P_Id int NOT NULL CHECK (P_Id&gt;0),LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255))如需命名 CHECK 约束，并定义多个列的 CHECK 约束 CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT chk_Person CHECK (P_Id&gt;0 AND City='Sandnes')) 更改CHECK约束1234567891011121314ALTER TABLE PersonsADD CHECK (P_Id&gt;0)如需命名 CHECK 约束，并定义多个列的 CHECK 约束ALTER TABLE PersonsADD CONSTRAINT chk_Person CHECK (P_Id&gt;0 AND City='Sandnes')撤销 CHECK 约束 /* MySQL */ALTER TABLE PersonsDROP CHECK chk_Person/* SQL Server / Oracle / MS Access */ALTER TABLE PersonsDROP CONSTRAINT chk_Person 附2.6 DEFAULT 约束DEFAULT 约束用于向列中插入默认值。如果没有规定其他的值，那么会将默认值添加到所有的新记录。1234567891011121314151617CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255) DEFAULT 'Sandnes')通过使用类似 GETDATE() 这样的函数，DEFAULT 约束也可以用于插入系统值CREATE TABLE Orders(O_Id int NOT NULL,OrderNo int NOT NULL,P_Id int,OrderDate date DEFAULT GETDATE()) 更改DEFAULT约束1234567891011121314151617181920添加 DEFAULT 约束/* MySQL */：ALTER TABLE PersonsALTER City SET DEFAULT 'SANDNES'/* SQL Server / MS Access */ALTER TABLE PersonsALTER COLUMN City SET DEFAULT 'SANDNES'/* Oracle */ALTER TABLE PersonsMODIFY City DEFAULT 'SANDNES'撤销 DEFAULT 约束 /* MySQL */ALTER TABLE PersonsALTER City DROP DEFAULT/* SQL Server / Oracle / MS Access */ALTER TABLE PersonsALTER COLUMN City DROP DEFAULT 附2.7 AUTO INCREMENT]]></content>
      <categories>
        <category>Study</category>
        <category>Db</category>
      </categories>
      <tags>
        <tag>Database</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment懒加载]]></title>
    <url>%2Farticle%2F2799403346%2F</url>
    <content type="text"><![CDATA[ViewPager 结合 Fragment 使用时，由于 ViewPager 的特性，会预先加载当前显示页面左右两边的页面，也就是说默认会缓存3个页面，（也可以使用 mViewPager.setOffscreenPageLimit(3); 这个方法来改变这个设置。）]]></content>
      <categories>
        <category>Android</category>
        <category>todo</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2Farticle%2F185805107%2F</url>
    <content type="text"><![CDATA[本文主要介绍如何使用 Hexo+NexT 搭建自己的博客，和在建站期间遇到的一些问题以及优化方式。 弄懂 NexTpost.md 中 bool 属性默认值是 false BugFix错误 Cannot set property &#39;lastIndex&#39; of undefined，修改 hexo/config.yml 设置 auto_detect: false 12345highlight: enable: true line_number: true auto_detect: false tab_replace: SEO优化 Hexo NexT主题SEO优化 SEO优化，Google收录 页面简单加密访问找到文件themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig在&lt;meta&gt;标签之后添加如下js代码 12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 在文章的Front-matter定义password 123456789---layout: posttitle: Hexo加密文章示例date: 2017-03-02category: tags: keywords:password: 123456--- 添加留言界面添加page，在博客根目录下执行如下命令，会在source目录下面创建msg/index.md文件。 1hexo new page msg 配置文字和图标，打开themes/next/_config.yml文件，进行如下配置，才能使留言的界面显示 1234567menu: home: / #about: /about archives: /archives tags: /tags categories: /categories guestbook: /guestbook 配置图标，打开themes/next/_config.yml文件，进行如下配置，可以自定义显示在侧边栏的留言的图标，图标的配置使用key-value的形式，下面代码中home``calendar等都是key，使用这个key可以从这个网站-FontAwesome获取图标，如果想更换图标，只需要去那个网站获取图标的名字去掉头部的icon作为key添加到下面代码中即可。 12345678910menu_icons: enable: true home: home about: user categories: th schedule: calendar tags: tags guestbook : comments archives: archive commonweal: heartbeat 打开themes/next/language/zh-CN.yml文件，进行如下配置，才能显示为 留言 字样 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 guestbook: 留言 过滤文件不进行渲染在给站点添加 README.md 和 Google，百度相关的验证文件时，我们希望这个文件不要被主题渲染，而是源文件直接拷贝到 public 文件夹中，只需要在 hexo/_config.yml 中进行如下配置。 1234skip_render: - 'README.*' - 'google26933bad87c2b3ba.*' - 'baidu_verify_HnYctWkkrH.*' category 分级在头部如下写入 categories 标签 123categories: - Extensions - Hexo 链接唯一化安装 hexo-abbrlink 插件 1npm install hexo-abbrlink --save 配置 hexo/_config.yml，添加如下，完成后打开文件，保存几次，会自动添加 abbrlink 属性，如果已经有值了则不会更改。 123456permalink: article/:abbrlink/ # article/ 可自行更换# abbrlink configabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 文章压缩安装插件 hexo-all-minifier 1npm install hexo-all-minifier 配置 hexo/_config.yml，添加如下 1234567891011121314151617181920212223242526# 文章压缩html_minifier: enable: true ignore_error: false exclude:css_minifier: enable: true exclude: - &apos;*.min.css&apos;js_minifier: enable: true mangle: true output: compress: exclude: - &apos;*.min.js&apos;image_minifier: enable: true interlaced: false multipass: false optimizationLevel: 2 pngquant: false progressive: false 添加 fork me on github修改 hexoBlog/themes/next/layout/_layout.swig 文件，在 header标签之前添加图片，图片样式可以到该站点选择颜色和位置等。href 中需要修改你为的 github 地址12345678910&lt;div class=&quot;&#123;&#123; container_class &#125;&#125; &#123;% block page_class %&#125;&#123;% endblock %&#125; &quot;&gt; &lt;div class=&quot;headband&quot;&gt;&lt;/div&gt; &lt;!--- add Fork me on Github --&gt; &lt;div class=&quot;forkme&quot;&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://github.com/chendongMarch&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; left: 0; border: 0;&quot; src=&quot;https://camo.githubusercontent.com/567c3a48d796e2fc06ea80409cc9dd82bf714434/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f6461726b626c75655f3132313632312e706e67&quot; alt=&quot;Fork me on GitHub&quot; data-canonical-src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_left_darkblue_121621.png&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;!--- add Fork me on Github --&gt; &lt;header id=&quot;header&quot; class=&quot;header&quot; itemscope itemtype=&quot;//schema.org/WPHeader&quot;&gt; 在 head 标签内添加 style 使小屏幕访问时不显示这个图片 123456789101112131415&lt;head&gt; &#123;% include '_partials/head.swig' %&#125; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt;&lt;style&gt; .forkme&#123; display: none; &#125;@media (min-width: 768px) &#123; .forkme&#123; display: inline; &#125;&#125; &lt;/style&gt; &#123;% include '_third-party/analytics/index.swig' %&#125;&lt;/head&gt; 代码风格处理查看 hexoBlog/themes/next/source/css/_common/components/highlight/highlight.styl 文件，是对高亮代码的相关配置。找到标签修改既可。 1234567// 行内代码code&#123; // 分行时是不是根据单词划分 word-wrap: break-all/break-word; // 代码颜色 color:#fff;&#125; 添加本地搜索安装插件 hexo-generator-searchdb 1npm install hexo-generator-searchdb --save 配置 hexo/_config.yml 12345search: path: search.xml field: post format: html limit: 10000 配置 next/_config.yml 123# Local searchlocal_search: enable: true 添加加载进度在 Next 主题下打开 `` 文件，在最后追加进度条 1234567891011121314151617&#123;# 添加进度条 #&#125;&lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;&lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt;&lt;style&gt; .pace .pace-progress &#123; background: #00d9cf; /*进度条颜色*/ height: 2px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 解决表格被等分文件 themes/next/source/css/_common/scaffolding/tables.styl 1table-layout: auto; 添加 Leancloud 统计今天发现网页访问很慢，查了之后发现不蒜子统计访问太慢，换成leancloud,但是只有pv统计。 参考文章 指定文章不在首页显示文件 /Users/march/Documents/hexoBlog/themes/next/layout/index.swig 修改。 123456789101112&lt;section id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; &#123;% for post in page.posts %&#125; &#123;%if !post.hide %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125;&lt;/section&gt;// render 之前判断&#123;%if !post.hide %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125;&#123;% endif %&#125; 然后在文章文件头部，增加 1234---...hide: true---]]></content>
      <categories>
        <category>Extensions</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Extensions</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo加密文章示例]]></title>
    <url>%2Farticle%2F684233485%2F</url>
    <content type="text"><![CDATA[本文使用Hexo加密]]></content>
      <categories>
        <category>Extensions</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Extensions</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速实现Fragment切换功能]]></title>
    <url>%2Farticle%2F4099568815%2F</url>
    <content type="text"><![CDATA[一个app首页通常是使用Activity + Fragment的形式展示，控制Fragment的显示和隐藏基本有两种实现方法:&emsp;&emsp;1. ViewPager , 比如微信 , 优势是手势操作更加方便，官方提供了FragmentPagerAdapter可以很方便帮助我们实现数据加载（Fragment要使用懒加载的方式，避免浪费资源），劣势就是当你的第一个Fragment中已经使用了ViewPager，两层套一起事件会冲突，而且操作也不友好啦。&emsp;&emsp;2. FragmentManager , 比如头条，针对使用ViewPager组合Fragment的问题，使用FragmentManager控制Fragment的显示和隐藏，不需要考虑懒加载的问题，不过不能支持滑动啦。&emsp;&emsp;3. 本文主要是封装FragmentManager切换页面的相关操作。 设计思路设计一个管理类，负责 Fragment 的创建，显示，隐藏，回收等逻辑，想要进行 Framgnet 切换的界面，只需要创建这个管理类实现监听即可，从而将这些逻辑分离出来，达到复用的目的。 定义接口首先定义 FragmentOperator 接口，这个接口的目的是在完成 Framgent 切换之后能够告知所在的 Activity 作出相应响应操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061interface FragmentOperator &#123; /** * 获取放置fragment的控件id * * @return id */ int getFragmentContainerId(); /** * 构建fragment * * @param showItem 将要展示的fragment pos * @return fragment */ Fragment makeFragment(int showItem); /** * 进行转换之前做操作,实现该方法可以自定义fragment切换的动画效果等 * * @param transaction transaction */ void beginTransaction(FragmentTransaction transaction); /** * 切换成功之后会回调这个方法，同步选中之后的显示状态 * 比如改变按钮的颜色等操作 * * @param selectImage 被选中的item */ void syncSelectState(int showItem); /** * 当点击显示同一个，当两次切换到了同一个fragment，返回true时会进行此次切换 * * @param showItem 显示的item * @return 返回false表示忽略此次点击的切换 */ boolean whenShowSameFragment(int showItem); /** * 当点击显示的不是同一个，用于需要针对切换到某个fragment时的场景 * * @param showItem 显示的item * @return 返回false表示忽略此次点击的切换 */ boolean whenShowNotSameFragment(int showItem);&#125;// 上面的接口中不是所有的方法都是必须的，下面是一个简单的实现public static abstract class SimpleFragmentOperator implements FragmentOper @Override public boolean whenShowNotSameFragment(int showItem) &#123; return true; &#125; @Override public boolean whenShowSameFragment(int showItem) &#123; return false; &#125; @Override public void syncSelectState(int showItem) &#123; &#125; @Override public void beginTransaction(FragmentTransaction transaction) &#123; &#125;&#125; 核心方法使用 tag 作为标记添加 fragment ,避免重复创建 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private static final String FRAGMENT_ATG = "FragmentHelper";private static final String ITEM_HIDE = "mHideItem";private static final String ITEM_SHOW = "mShowItem";private FragmentOperator operator;private Fragment mCurrentFragment;private FragmentManager mFragmentManager;private int mShowItem, mHideItem;private int mExactlyItem = 0; /** * 隐藏当前显示的fragment,显示将要显示的fragment * * @param hideItem 需要隐藏的fragment * @param showItem 需要显示的fragment * @param isOnCreate 是否是第一次从OnCreate中启动,点击都是false */private void performSelectItem(int hideItem, int showItem, boolean isOnCreate) &#123; // 获得将要显示页的tag String currentTag = getFragmentTag(hideItem); // 隐藏当前的的fragment FragmentTransaction transaction = mFragmentManager.beginTransaction(); operator.beginTransaction(transaction); // 第一次创建，一个都没有，不需要隐藏，直接显示 if (mFragmentManager.getFragments() == null) &#123; mShowItem = showItem; mExactlyItem = showItem; mCurrentFragment = operator.makeFragment(showItem); transaction.add(operator.getFragmentContainerId(), mCurrentFragment, getFragmentTag( .show(mCurrentFragment); &#125; else &#123; // 优化，如果被杀后再进来，全部的fragment都会被呈现显示状态，所以都隐藏一遍 if (isOnCreate &amp;&amp; mFragmentManager.getFragments() != null) &#123; for (Fragment fragment : mFragmentManager.getFragments()) &#123; transaction.hide(fragment); &#125; &#125; else &#123; // 正常按钮点击进入，隐藏上一个即可 Fragment lastFragment = mFragmentManager.findFragmentByTag(currentTag); if (lastFragment != null) &#123; transaction.hide(lastFragment); &#125; &#125; // 获得将要显示页的tag String toTag = getFragmentTag(showItem); // find要显示的Fragment mCurrentFragment = mFragmentManager.findFragmentByTag(toTag); if (mCurrentFragment != null) &#123; // 已经存在则显示 transaction.show(mCurrentFragment); &#125; else &#123; // 不存在则添加新的fragment mCurrentFragment = operator.makeFragment(showItem); if (mCurrentFragment != null) &#123; transaction.add(operator.getFragmentContainerId(), mCurrentFragment, toTag); &#125; &#125; &#125; // 同步状态 operator.syncSelectState(showItem); // 保存当前显示fragment的item mHideItem = hideItem; mShowItem = showItem; transaction.commitAllowingStateLoss();&#125; 显示 Fragment在 Activity 中使用时只需要调用 showFragment() 方法即可 123456789101112131415161718/** * 显示某个fragment * * @param showItem 显示的item */public void showFragment(int showItem) &#123; if (showItem == mShowItem) &#123; if (operator.whenShowSameFragment(showItem)) &#123; performSelectItem(mExactlyItem, showItem, false); mExactlyItem = showItem; &#125; &#125; else &#123; if (operator.whenShowNotSameFragment(showItem)) &#123; performSelectItem(mExactlyItem, showItem, false); mExactlyItem = showItem; &#125; &#125;&#125; 优化当 Activity 被回收时，记录上次的状态 123456789101112131415161718192021222324252627282930313233343536// 保存数据// FragmentHelperpublic void onCreate(Bundle save) &#123; if (save != null) &#123; mHideItem = save.getInt(ITEM_HIDE, 0); mShowItem = save.getInt(ITEM_SHOW, 0); performSelectItem(mHideItem, mShowItem, true); &#125;&#125;// 在Activity销毁时调用@Overrideprotected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); if (mFragmentHelper != null) &#123; mFragmentHelper.onSaveInstanceState(outState); &#125;&#125;// 重新加载// FragmentHelperpublic void onCreate(Bundle save) &#123; if (save != null) &#123; mHideItem = save.getInt(ITEM_HIDE, 0); mShowItem = save.getInt(ITEM_SHOW, 0); performSelectItem(mHideItem, mShowItem, true); &#125;&#125;// 在Activity创建时调用@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mFragmentHelper = new FragmentHelper(getSupportFragmentManager(), mSimpleOperator); mFragmentHelper.onCreate(savedInstanceState);&#125; 使用123456789101112131415161718192021222324252627282930313233343536373839404142public class TestMultiFragmentActivity2 extends BaseActivity &#123; private FragmentHelper mFragmentHelper; private FragmentHelper.SimpleFragmentOperator mSimpleOperator; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mSimpleOperator = new FragmentHelper.SimpleFragmentOperator() &#123; @Override public int getFragmentContainerId() &#123; return 0; &#125; @Override public Fragment makeFragment(int showItem) &#123; return null; &#125; @Override public void syncSelectState(int showItem) &#123; &#125; &#125;; mFragmentHelper = new FragmentHelper(getSupportFragmentManager(), mSimpleOperator); // 只有销毁后回来才会调起切换操作否则没反应 mFragmentHelper.onCreate(savedInstanceState); &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); if (mFragmentHelper != null) &#123; mFragmentHelper.onSaveInstanceState(outState); &#125; &#125; @Override protected int getLayoutId() &#123; return 0; &#125;&#125; 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206/** * CreateAt : 2016/11/5 * Describe : 实现Fragment切换 * * @author chendong */public class FragmentHelper &#123; private static final String FRAGMENT_ATG = "FragmentHelper"; private static final String ITEM_HIDE = "mHideItem"; private static final String ITEM_SHOW = "mShowItem"; private FragmentOperator operator; private Fragment mCurrentFragment; private FragmentManager mFragmentManager; private int mShowItem, mHideItem; private int mExactlyItem = 0; public void onCreate(Bundle save) &#123; if (save != null) &#123; mHideItem = save.getInt(ITEM_HIDE, 0); mShowItem = save.getInt(ITEM_SHOW, 0); performSelectItem(mHideItem, mShowItem, true); &#125; &#125; public void onSaveInstanceState(Bundle outState) &#123; outState.putInt(ITEM_HIDE, mHideItem); outState.putInt(ITEM_SHOW, mShowItem); &#125; public FragmentHelper(FragmentManager mFragmentManager, FragmentOperator operator) &#123; this.mFragmentManager = mFragmentManager; this.mFragmentManager = mFragmentManager; this.operator = operator; &#125; /** * 显示某个fragment * * @param showItem 显示的item */ public void showFragment(int showItem) &#123; if (showItem == mShowItem) &#123; if (operator.whenShowSameFragment(showItem)) &#123; performSelectItem(mExactlyItem, showItem, false); mExactlyItem = showItem; &#125; &#125; else &#123; if (operator.whenShowNotSameFragment(showItem)) &#123; performSelectItem(mExactlyItem, showItem, false); mExactlyItem = showItem; &#125; &#125; &#125; /** * 获取当前处于活动状态的fragment' * * @return fragment */ public Fragment getCurrentFragment() &#123; return mCurrentFragment; &#125; /** * 隐藏当前显示的fragment,显示将要显示的fragment * * @param hideItem 需要隐藏的fragment * @param showItem 需要显示的fragment * @param isOnCreate 是否是第一次从OnCreate中启动,点击都是false */ private void performSelectItem(int hideItem, int showItem, boolean isOnCreate) &#123; // 获得将要显示页的tag String currentTag = getFragmentTag(hideItem); // 隐藏当前的的fragment FragmentTransaction transaction = mFragmentManager.beginTransaction(); operator.beginTransaction(transaction); // 第一次创建，一个都没有，不需要隐藏，直接显示 if (mFragmentManager.getFragments() == null) &#123; mShowItem = showItem; mExactlyItem = showItem; mCurrentFragment = operator.makeFragment(showItem); transaction.add(operator.getFragmentContainerId(), mCurrentFragment, getFragmentTag(showItem)) .show(mCurrentFragment); &#125; else &#123; // 优化，如果被杀后再进来，全部的fragment都会被呈现显示状态，所以都隐藏一遍 if (isOnCreate &amp;&amp; mFragmentManager.getFragments() != null) &#123; for (Fragment fragment : mFragmentManager.getFragments()) &#123; transaction.hide(fragment); &#125; &#125; else &#123; // 正常按钮点击进入，隐藏上一个即可 Fragment lastFragment = mFragmentManager.findFragmentByTag(currentTag); if (lastFragment != null) &#123; transaction.hide(lastFragment); &#125; &#125; // 获得将要显示页的tag String toTag = getFragmentTag(showItem); // find要显示的Fragment mCurrentFragment = mFragmentManager.findFragmentByTag(toTag); if (mCurrentFragment != null) &#123; // 已经存在则显示 transaction.show(mCurrentFragment); &#125; else &#123; // 不存在则添加新的fragment mCurrentFragment = operator.makeFragment(showItem); if (mCurrentFragment != null) &#123; transaction.add(operator.getFragmentContainerId(), mCurrentFragment, toTag); &#125; &#125; &#125; // 同步状态 operator.syncSelectState(showItem); // 保存当前显示fragment的item mHideItem = hideItem; mShowItem = showItem; transaction.commitAllowingStateLoss(); &#125; private String getFragmentTag(int item) &#123; return FRAGMENT_ATG + item; &#125; interface FragmentOperator &#123; /** * 获取放置fragment的控件id * * @return id */ int getFragmentContainerId(); /** * 构建fragment * * @param showItem 将要展示的fragment pos * @return fragment */ Fragment makeFragment(int showItem); /** * 进行转换之前做操作,实现该方法可以自定义fragment切换的动画效果等 * * @param transaction transaction */ void beginTransaction(FragmentTransaction transaction); /** * 切换成功之后会回调这个方法，同步选中之后的显示状态 * 比如改变按钮的颜色等操作 * * @param showItem 被选中的item */ void syncSelectState(int showItem); /** * 当点击显示同一个，当两次切换到了同一个fragment，返回true时会进行此次切换 * * @param showItem 显示的item * @return 返回false表示忽略此次点击的切换 */ boolean whenShowSameFragment(int showItem); /** * 当点击显示的不是同一个，用于需要针对切换到某个fragment时的场景 * * @param showItem 显示的item * @return 返回false表示忽略此次点击的切换 */ boolean whenShowNotSameFragment(int showItem); &#125; // 上面的接口中不是所有的方法都是必须的，下面是一个简单的实现 public static abstract class SimpleFragmentOperator implements FragmentOperator &#123; @Override public boolean whenShowNotSameFragment(int showItem) &#123; return true; &#125; @Override public boolean whenShowSameFragment(int showItem) &#123; return false; &#125; @Override public void syncSelectState(int showItem) &#123; &#125; @Override public void beginTransaction(FragmentTransaction transaction) &#123; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EditText]]></title>
    <url>%2Farticle%2F2515477621%2F</url>
    <content type="text"><![CDATA[EditText 是 TextView 的子类，用于进行文字输入等操作，是开发中特别常用的一个控件了，本文主要介绍： 更改EditText的背景 设置监听事件 给EditText设置具有带图片的Hint 2. 监听事件2.1 监听焦点变化123456etInput.setOnFocusChangeListener(new OnFocusChangeListener() &#123; @Override public void onFocusChange(View v, boolean hasFocus) &#123; // hasFocus 当前是否获得焦点 &#125;&#125;); 2.2 文本输入监听事件1234567891011121314etInput.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; // 文本输入之前回调 &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; // 输入过程中会频繁回调 &#125; @Override public void afterTextChanged(Editable s) &#123; // 输入结束回调 &#125;&#125;); 3. 自定义EditText背景如下图所示，当离开当前EditText时，检查输入是否有问题，输入错误会显示红色 3.1 定义背景drawable文件其他形态的背景也相对简单，只有一条线的这种背景drawable写起来还是需要研究一下的，直接上代码啦,主要是用了一个selector -&gt; layer-list -&gt; shape,在select属性改变时，改变线条的颜色。原本是一个矩形，然后将另外三个边偏移一下，只留下底边，达到线条显示的效果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_selected="true"&gt; &lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item&gt; &lt;shape android:shape="rectangle"&gt; &lt;solid android:color="@android:color/transparent" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left="-2dip" android:right="-2dip" android:top="-2dip"&gt; &lt;shape&gt; &lt;solid android:color="@android:color/transparent" /&gt; &lt;stroke android:width="1dip" android:color="@color/red" android:dashGap="0dp" android:dashWidth="0dip" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt; &lt;item&gt; &lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item&gt; &lt;shape android:shape="rectangle"&gt; &lt;solid android:color="@android:color/transparent" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left="-2dip" android:right="-2dip" android:top="-2dip"&gt; &lt;shape&gt; &lt;solid android:color="@android:color/transparent" /&gt; &lt;stroke android:width="1dip" android:color="@color/colorPrimary" android:dashGap="0dp" android:dashWidth="0dip" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt;&lt;/selector&gt; 3.2 焦点改变时改变背景123456789101112etInput.setOnFocusChangeListener(new OnFocusChangeListener() &#123; @Override public void onFocusChange(View v, boolean hasFocus) &#123; String trim = etInput.getText().toString().trim(); // 没有焦点&amp;&amp;有文字 if (!hasFocus &amp;&amp; trim.length() &gt; 0) &#123; etInput.setSelected(true); &#125; else &#123; etInput.setSelected(false); &#125; &#125; &#125;); 4. 带图片的Hint如下图所示，实现带有图片的hint，使用 SpannableString实现 ，但是开始的效果不是很理想，图片不能很好的居中，使用重写ImageSpan的方法解决了这个问题 4.1 图片垂直居中的span1234567891011121314151617181920212223242526272829303132333435class VerticalCenterImageSpan extends ImageSpan &#123; VerticalCenterImageSpan(Drawable drawable) &#123; super(drawable); &#125; public int getSize(Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fontMetricsInt) &#123; Drawable drawable = getDrawable(); Rect rect = drawable.getBounds(); if (fontMetricsInt != null) &#123; Paint.FontMetricsInt fmPaint = paint.getFontMetricsInt(); int fontHeight = fmPaint.bottom - fmPaint.top;// 计算文字的高度 int drHeight = rect.bottom - rect.top;// 计算图片的高度 int top = drHeight / 2 - fontHeight / 4; int bottom = drHeight / 2 + fontHeight / 4; fontMetricsInt.ascent = -bottom; fontMetricsInt.top = -bottom; fontMetricsInt.bottom = top; fontMetricsInt.descent = top; &#125; return rect.right; &#125; @Override public void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom, Paint paint) &#123; Drawable drawable = getDrawable(); canvas.save(); int transY; transY = ((bottom - top) - drawable.getBounds().bottom) / 2 + top; canvas.translate(x, transY); drawable.draw(canvas); canvas.restore(); &#125; &#125; 4.2 设置hint123456789// 设置图文hint private void initEditText(EditText editText) &#123; SpannableString msp = new SpannableString("图片 写点什么吧..."); Drawable drawable = ContextCompat.getDrawable(getContext(), R.drawable.icon_hint_edit); drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight()); // 这里从start = 0开始，end = 2结束，图片取代了两个字的位置，上面的字符串中国年的图片两个字会被替代 msp.setSpan(new VerticalCenterImageSpan(drawable), 0, 2, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); editText.setHint(msp); &#125; 5 修改键盘的回车键在xml配置 12android:imeOptions="actionSearch"android:inputType="text" 或在java代码中配置 12editText.setImeOptions(EditorInfo.IME_ACTION_SEARCH);editText.setInputType(EditorInfo.TYPE_CLASS_TEXT); 实现监听，进行相关操作 12345678910editText.setOnEditorActionListener(new TextView.OnEditorActionListener() &#123; public boolean onEditorAction(TextView v, int actionId, KeyEvent event) &#123; if (actionId == EditorInfo.IME_ACTION_SEND || (event != null &amp;&amp; event.getKeyCode() == KeyEvent.KEYCODE_ENTER)) &#123; //do something; return true; &#125; return false; &#125;&#125;);]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端与服务器token机制]]></title>
    <url>%2Farticle%2F1482489498%2F</url>
    <content type="text"><![CDATA[移动端与服务器token机制]]></content>
      <categories>
        <category>Android</category>
        <category>todo</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义控件-仿QQ相册滑动选中]]></title>
    <url>%2Farticle%2F3936083469%2F</url>
    <content type="text"><![CDATA[显示相册在app中是一个比较常见的操作，大致的操作就是通过ContentProvider获取多媒体资源进行展示，我综合了一下QQ 的和微信的显示效果，实现了一下,仿微信QQ显示手机相册，在QQ的相册选择时是支持滑动选中的，即手指碰到哪个就选中哪张照片，正好公司的项目中用到了这个功能，在网上找了找没有很好的解决方案，所以通过自定义控件处理事件，这篇文章主要介绍这个功能的实现。 自定义控件SlidingSelectLayout的源代码点击这里获取 大体思路自定义控件将会作为 RecyclerView 的父控件，这样使他可以优先于RecyclerView 捕捉事件 当手指竖向滑动时，父控件不作处理，RecyclerView处理事件，进行滑动。当手指横向滑动达到阈值时自定义父控件会截断事件自己进行进行处理。 根据手指的滑动MotionEvent获取x,y坐标，使用RecycelrView的findViewUnder(float x,float y) 的方法，可以直接获取制定位置的View，再使用tag从view中拿到之前使用mScl.markView()方法绑定的pos和data数据 使用该方法就不会因为动态计算距离而局限于RecyclerView的布局，九宫格模式下仍然可以很好的支持。 初始化参数在处理事件获取手指滑动的位置时，需要使用RecyclerView的LayoutManager等，为了尽量对外简化使用的流程，在控件内部使用遍历子控件的方式来获取RecyclerView和GridLayoutManager的列数等参数，初始化一些值。 获取 RecyclerView 1234567891011121314151617181920212223242526/** * 获取RecyclerView */private void ensureTarget() &#123; if (mTargetRv != null) return; View findView = searchInViewGroup(this); if (findView == null) &#123; Logger.e(TAG, "can not find RecyclerView"); &#125; else &#123; mTargetRv = (RecyclerView) findView; &#125;&#125;private View searchInViewGroup(ViewGroup viewGroup) &#123; View rstView = null; for (int i = 0; i &lt; viewGroup.getChildCount(); i++) &#123; View childAt = viewGroup.getChildAt(i); if (childAt instanceof RecyclerView) &#123; rstView = childAt; &#125; else if (childAt instanceof ViewGroup) &#123; rstView = searchInViewGroup((ViewGroup) childAt); &#125; &#125; return rstView;&#125; 处理LayoutManager，初始化xTouchSlop，这个值是滑动多大距离触发水平滑动，根据GridLayoutManager的列数来动态设置。 12345678910111213141516private void ensureLayoutManager() &#123; if (mTargetRv == null || itemSpanCount != INVALID_PARAM) return; RecyclerView.LayoutManager lm = mTargetRv.getLayoutManager(); if (lm == null) return; if (lm instanceof GridLayoutManager) &#123; GridLayoutManager glm = (GridLayoutManager) lm; itemSpanCount = glm.getSpanCount(); &#125; else &#123; Logger.e(TAG,"暂时不支持其他布局类型，请使用GridLayoutManager"); itemSpanCount = 4; &#125; int size = (int) (getResources().getDisplayMetrics().widthPixels / (itemSpanCount * 1.0f)); xTouchSlop = yTouchSlop = size * TOUCH_SLOP_RATE;&#125; 拦截事件12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 如果RecyclerView没有获取到，不进行事件的拦截private boolean isReadyToIntercept() &#123; return mTargetRv != null &amp;&amp; mTargetRv.getAdapter() != null &amp;&amp; itemSpanCount != INVALID_PARAM;&#125;@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; if (!isEnabled()) return super.onInterceptTouchEvent(ev); // 不支持多点触摸 int pointerCount = ev.getPointerCount(); if (pointerCount &gt; 1) &#123; return super.onInterceptTouchEvent(ev); &#125; // 获取RecyclerView ensureTarget(); // 初始化参数 ensureLayoutManager(); if (!isReadyToIntercept()) return super.onInterceptTouchEvent(ev); int action = MotionEventCompat.getActionMasked(ev); switch (action) &#123; case MotionEvent.ACTION_DOWN: // init mInitialDownX = ev.getX(); mInitialDownY = ev.getY(); break; case MotionEvent.ACTION_UP: // stop isBeingSlide = false; break; case MotionEvent.ACTION_MOVE: // handle float xDiff = Math.abs(ev.getX() - mInitialDownX); float yDiff = Math.abs(ev.getY() - mInitialDownY); if (yDiff &lt; yTouchSlop &amp;&amp; xDiff &gt; xTouchSlop) &#123; isBeingSlide = true; &#125; break; &#125; return isBeingSlide;&#125; 触摸事件处理Touch事件123456789101112131415161718@Overridepublic boolean onTouchEvent(MotionEvent ev) &#123; int action = MotionEventCompat.getActionMasked(ev); switch (action) &#123; case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_UP: // re init 手指抬起时重置 isBeingSlide = false; preViewPos = INVALID_PARAM; break; case MotionEvent.ACTION_MOVE: // 滑动过程中，触发监听事件 publishSlidingCheck(ev); break; &#125; return isBeingSlide;&#125; 获取数据123456789101112131415// 从View中使用getTag(int key)获取tag，也就是之前在onBindViewHolder中设置的数据// 从Tag中获取posprivate int getPos(View parentView) &#123; int pos = INVALID_PARAM; Object tag = parentView.getTag(tagPosKey); if (tag != null) pos = (int) tag; return pos; &#125; // 从tag中获取dataprivate Object getData(View parentView) &#123; return parentView.getTag(tagDataKey);&#125; 触发监听使用监听向外发布事件,将获取的pos和data通过监听发布 12345678910111213141516171819202122232425/** * 发布结果 * * @param event 事件 */private void publishSlidingCheck(MotionEvent event) &#123; float x = generateX(event.getX()); float y = generateY(event.getY()); View childViewUnder = mTargetRv.findChildViewUnder(x, y); // fast stop if (onSlidingSelectListener == null || childViewUnder == null) return; int pos = getPos(childViewUnder); Object data = getData(childViewUnder); // fast stop 当前触摸的点与上一次触摸的点相同 || 没有pos || 没有数据 if (preViewPos == pos || pos == INVALID_PARAM || data == null) return; try &#123; // 这里使用范型强制转换 onSlidingSelectListener.onSlidingSelect(pos, childViewUnder, data); preViewPos = pos; &#125; catch (ClassCastException e) &#123; Log.e("SlidingSelect", "ClassCastException:填写的范型有误，无法转换"); &#125;&#125; 效果演示普通模式演示视频 九宫格模式演示视频 使用xml 中使用1234567891011&lt;com.march.slidingselect.SlidingSelectLayout android:id="@+id/scl" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recyclerview" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; &lt;/com.march.slidingselect.SlidingSelectLayout&gt; java 代码中配置在Adapter的onBindViewHolder方法中将pos和data与view进行绑定，之所以这样做是为了可以在手指划过Item时将对应的数据和位置通过监听发送回来。 123456789private SlidingSelectLayout mScl;mScl = getView(R.id.scl);class MyAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;&#123; @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; mScl.markView(holder.itemView,position,demos.get(position)); &#125;&#125; 监听回调使用范型获得手指触摸到的位置和当前位置对应的数据进行更新adapter 1234567mScl.setOnSlidingSelectListener(new SlidingSelectLayout.OnSlidingSelectListener&lt;Demo&gt;() &#123; @Override public void onSlidingSelect(int pos, View parentView, Demo data) &#123; demos.get(pos).isChanged = !demos.get(pos).isChanged; adapter.notifyItemChanged(pos); &#125; &#125;); 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251package com.march.dev.widget;import android.content.Context;import android.support.v4.view.MotionEventCompat;import android.support.v7.widget.GridLayoutManager;import android.support.v7.widget.RecyclerView;import android.util.AttributeSet;import android.util.Log;import android.view.MotionEvent;import android.view.View;import android.view.ViewGroup;import android.widget.FrameLayout;import com.march.dev.R;import com.march.dev.helper.Logger;/** * Project : CommonLib * Package : com.march.lib.view * CreateAt : 2016/9/12 * Describe : 滑动选中 * * @author chendong */public class SlidingSelectLayout extends FrameLayout &#123; public static final String TAG = SlidingSelectLayout.class.getSimpleName(); private static final float TOUCH_SLOP_RATE = 0.15f;// 初始化值 private static final int INVALID_PARAM = -1; public SlidingSelectLayout(Context context) &#123; this(context, null); &#125; public SlidingSelectLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); setTagKey(R.id.sliding_pos, R.id.sliding_data); itemSpanCount = INVALID_PARAM; preViewPos = INVALID_PARAM; &#125; private RecyclerView mTargetRv;// 内部的rv private int offsetTop; private float xTouchSlop;// 横轴滑动阈值，超过阈值表示触发横轴滑动 private float yTouchSlop;// 纵轴滑动阈值，超过阈值表示触发纵轴滑动 private int itemSpanCount;// 横向的item数量 private float mInitialDownX;// down 事件初始值 private float mInitialDownY;// down 事件初始值 private boolean isBeingSlide;// 是否正在滑动 private int tagPosKey; private int tagDataKey; private int preViewPos; private OnSlidingSelectListener onSlidingSelectListener;// 滑动选中监听 @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; if (!isEnabled()) return super.onInterceptTouchEvent(ev); // 不支持多点触摸 int pointerCount = ev.getPointerCount(); if (pointerCount &gt; 1) &#123; return super.onInterceptTouchEvent(ev); &#125; // 获取RecyclerView ensureTarget(); // 初始化参数 ensureLayoutManager(); if (!isReadyToIntercept()) return super.onInterceptTouchEvent(ev); int action = MotionEventCompat.getActionMasked(ev); switch (action) &#123; case MotionEvent.ACTION_DOWN: // init mInitialDownX = ev.getX(); mInitialDownY = ev.getY(); break; case MotionEvent.ACTION_UP: // stop isBeingSlide = false; break; case MotionEvent.ACTION_MOVE: // handle float xDiff = Math.abs(ev.getX() - mInitialDownX); float yDiff = Math.abs(ev.getY() - mInitialDownY); if (yDiff &lt; yTouchSlop &amp;&amp; xDiff &gt; xTouchSlop) &#123; isBeingSlide = true; &#125; break; &#125; return isBeingSlide; &#125; private float generateX(float x) &#123; return x; &#125; private float generateY(float y) &#123; return y - offsetTop; &#125; private void setTargetRv(RecyclerView mTargetRv) &#123; this.mTargetRv = mTargetRv; &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; int action = MotionEventCompat.getActionMasked(ev); switch (action) &#123; case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_UP: // re init 手指抬起时重置 isBeingSlide = false; preViewPos = INVALID_PARAM; break; case MotionEvent.ACTION_MOVE: // 滑动过程中，触发监听事件 publishSlidingCheck(ev); break; &#125; return isBeingSlide; &#125; /** * 初始化参数 */ private void ensureLayoutManager() &#123; if (mTargetRv == null || itemSpanCount != INVALID_PARAM) return; RecyclerView.LayoutManager lm = mTargetRv.getLayoutManager(); if (lm == null) return; if (lm instanceof GridLayoutManager) &#123; GridLayoutManager glm = (GridLayoutManager) lm; itemSpanCount = glm.getSpanCount(); &#125; else &#123; Logger.e(TAG, "暂时不支持其他布局类型，请使用GridLayoutManager"); itemSpanCount = 4; &#125; int size = (int) (getResources().getDisplayMetrics().widthPixels / (itemSpanCount * 1.0f)); xTouchSlop = yTouchSlop = size * TOUCH_SLOP_RATE; &#125; /** * 发布结果 * * @param event 事件 */ private void publishSlidingCheck(MotionEvent event) &#123; float x = generateX(event.getX()); float y = generateY(event.getY()); View childViewUnder = mTargetRv.findChildViewUnder(x, y); // fast stop if (onSlidingSelectListener == null || childViewUnder == null) return; int pos = getPos(childViewUnder); Object data = getData(childViewUnder); // fast stop 当前触摸的点与上一次触摸的点相同 || 没有pos || 没有数据 if (preViewPos == pos || pos == INVALID_PARAM || data == null) return; try &#123; // 这里使用范型强制转换 onSlidingSelectListener.onSlidingSelect(pos, childViewUnder, data); preViewPos = pos; &#125; catch (ClassCastException e) &#123; Log.e("SlidingSelect", "ClassCastException:填写的范型有误，无法转换"); &#125; &#125; private void setTagKey(int tagPosKey, int tagDataKey) &#123; this.tagPosKey = tagPosKey; this.tagDataKey = tagDataKey; &#125; /** * 设置pos和data作为View的tag * @param parentView * @param pos * @param data */ public void markView(View parentView, int pos, Object data) &#123; parentView.setTag(tagPosKey, pos); parentView.setTag(tagDataKey, data); &#125; private int getPos(View parentView) &#123; int pos = INVALID_PARAM; Object tag = parentView.getTag(tagPosKey); if (tag != null) pos = (int) tag; return pos; &#125; private Object getData(View parentView) &#123; return parentView.getTag(tagDataKey); &#125; /** * 是否可以开始拦截处理事件，当recyclerView数据完全ok之后开始 * * @return 是否可以开始拦截处理事件 */ private boolean isReadyToIntercept() &#123; return mTargetRv != null &amp;&amp; mTargetRv.getAdapter() != null &amp;&amp; itemSpanCount != INVALID_PARAM; &#125; /** * 获取RecyclerView */ private void ensureTarget() &#123; if (mTargetRv != null) return; View findView = searchInViewGroup(this); if (findView == null) &#123; Logger.e(TAG, "can not find RecyclerView"); &#125; else &#123; mTargetRv = (RecyclerView) findView; &#125; &#125; private View searchInViewGroup(ViewGroup viewGroup) &#123; View rstView = null; for (int i = 0; i &lt; viewGroup.getChildCount(); i++) &#123; View childAt = viewGroup.getChildAt(i); if (childAt instanceof RecyclerView) &#123; rstView = childAt; &#125; else if (childAt instanceof ViewGroup) &#123; rstView = searchInViewGroup((ViewGroup) childAt); &#125; &#125; return rstView; &#125; public void setOffsetTop(int offsetTop) &#123; this.offsetTop = offsetTop; &#125; public &lt;D&gt; void setOnSlidingSelectListener(OnSlidingSelectListener&lt;D&gt; onSlidingCheckListener) &#123; this.onSlidingSelectListener = onSlidingCheckListener; &#125; public interface OnSlidingSelectListener&lt;D&gt; &#123; void onSlidingSelect(int pos, View parentView, D data); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NestedScrolling交互]]></title>
    <url>%2Farticle%2F2940188893%2F</url>
    <content type="text"><![CDATA[前言交互 触发时机 NestedScrollChild NestedScrollParent Down startNestScroll onStartNestScroll onNestScrollAccept Move dispatchNestPreScroll onNestPreScroll dispatchNestScroll onNestScroll Up stopNest]]></content>
      <categories>
        <category>Android</category>
        <category>todo</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android事件交互]]></title>
    <url>%2Farticle%2F3766638624%2F</url>
    <content type="text"><![CDATA[Android事件交互,当用户手指触碰屏幕时会触发onTouchEvent(MotionEven event)方法。 推荐阅读简书－MotionEvent详解 常用事件1234567MotionEvent.ACTION_DOWN: 0MotionEvent.ACTION_UP: 1MotionEvent.ACTION_MOVE: 2MotionEvent.ACTION_CANCEL: 3MotionEvent.ACTION_OUTSIDE: 4MotionEvent.ACTION_POINTER_DOWN: 5MotionEvent.ACTION_POINTER_UP: 6 获取事件 event.getAction()和event.getActionMasked()和MotionEventCompat.getActionMasked(event)都可以获取事件类型。带有Mask标志的方法是针对多点触控的情况拿到的掩码。多点触控时，获取Action会返回每个触摸点的事件，其中使用pointerIndex区分每个触摸点。 为了能表示每个pointerIndex对应的事件，以及更方便转化，每个获取的action实际上是pointerIndex和event拼接成的16进制表示，比如第二个点的Move事件，返回的值是0x0100,01表示pointerIndex,00表示Down事件，所以返回的action的值为256. 单点触摸时只有一个pointerIndex = 0,所以获取的到的action实际上是0x0000(Down事件)，0x0001(UP事件)。。。所以结果和事件的值是一样的。 当多点触摸时，第一个点的Down事件0x0000,第二个点的Down事件0x0100,此时简单的getAction()方法并不能获取正确的事件值。 getActionMasked()方法是将getAction()的值与ACTION_MASK做‘与’运算，例如当有一个事件是0x0102,获取掩码时可以过滤掉pointerIndex的值获取event的值，event.getActionMasked()原理大致相同。 描述 值 getAction()十六进制表示 0x0101 ACTION_MASK十六进制表示 0x00ff getAction()二进制表示 000001 000001 ACTION_MASK二进制表示 000000 011111 getActionMasked()二进制表示 000000 000001 getActionMasked()十六进制表示 0x0001(Move事件) 1234public static final int ACTION_MASK = 0xff;public static int getActionMasked(MotionEvent event) &#123; return event.getAction() &amp; ACTION_MASK;&#125; MotionEventCompat.getActionMasked()是对版本兼容的方法。推荐使用这个类进行相关操作达到兼容版本的目的。 Pointer pointer , pointerIndex , event , action , poiterId pointer代表一个触摸点 pointerIndex是pointer在MotionEvent中的索引 event代表事件，比如0(Down),1(UP)… action是pointerIndex和event拼接的十六进制形式 pointerId是一个pointer的唯一标示，他在整个事件流中是不会改变的，但是pointerIndex的值会改变，比如，先后放置三个指头在屏幕上会接收到0x0000(第一个指头Down事件),0x0105(第二个指头Pointer_Down事件),0x0205(第三个指头Pointer_Down事件),抬起第二个指头时会触发0x0106(Pointer_Up),再抬起第三个指头也会触发0x0106(Pointer_Up),也就是说抬起第二个指头之后第三个指头的index由02变成了01,所以index只是MotionEvnet中每个事件的下标，与事件不能形成标志性的关系。 MotionEventCompat MotionEventCompat是一个针对事件处理提供的辅助类，内部做了版本兼容。 getActionIndex(MotionEvent event)获取该事件的索引，有点类似于MotionEventCompat.getActionMasked(),都使用‘与’运算，只不过一个取的是高位的pointerIndex,后者取得是低位的event事件。 1234public static int getActionIndex(MotionEvent event) &#123; return (event.getAction() &amp; ACTION_POINTER_INDEX_MASK) &gt;&gt; ACTION_POINTER_INDEX_SHIFT; &#125; getPointerId(MotionEvent event, int pointerIndex)在一个MotionEvent中根据触摸点pointerIndex的值获取pointerId 123public static int getPointerId(MotionEvent event, int pointerIndex) &#123; return IMPL.getPointerId(event, pointerIndex);&#125; findPointerIndex(MotionEvent event, int pointerId)在一个MotionEvent中根据pointerId获取pointerIndex 123public static int findPointerIndex(MotionEvent event, int pointerId) &#123; return IMPL.findPointerIndex(event, pointerId);&#125; 从一个MotionEvent中根据pointerIndex获取对应触摸点的XY坐标 123456public static float getX(MotionEvent event, int pointerIndex) &#123; return IMPL.getX(event, pointerIndex);&#125;public static float getY(MotionEvent event, int pointerIndex) &#123; return IMPL.getY(event, pointerIndex);&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析SwipeRefreshLayout实现自定义刷新]]></title>
    <url>%2Farticle%2F308486771%2F</url>
    <content type="text"><![CDATA[前言 分析SwipeRefreshLayout的源代码来深入的理解一下关于刷新的事件处理和NestedScrolling机制的使用。Android5.0之后官方推出了SwipeRefreshLayout来实现下拉刷新，当然还有很多其他控件，因为像下拉刷新，抽屉效果，tabLayout效果几乎是每个App都需要的，在之前的版本中Android没有定义这些控件，因此GitHub上也涌现了大量的自定控件的库，大家可以很方便的引用这些库实现效果，比如很火的pull-to-refresh以及后来的ultra-pull-to-refresh。Android在推出SwipeRefreshLayout之后并没有在国内得到很好的使用，大家还是在用自己的刷新和开源库来实现。可能是因为： SwipeRefreshLayout的效果跟以前的刷新效果有些出入，大家接受了以前的效果对新的效果不太满意。 SwipeRefreshLayout自定义度不强，每个App都想有自己的特色，自然不愿意采用大众的做法。 这篇文章的目的就是，理解SwipeRefreshLayout 的实现，基于SwipeRefreshLayout实现类似传统的刷新效果并支持自定义。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SourceCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NestedScrollingParent分析]]></title>
    <url>%2Farticle%2F1655050953%2F</url>
    <content type="text"><![CDATA[前言 对NestedScrollingParent接口进行分析，主要是文档的翻译和一些理解，以及每个方法触发的时机。 NestedScrollingParent接口 This interface should be implemented by {@link android.view.ViewGroup ViewGroup} subclassesthat wish to support scrolling operations delegated by a nested child view. 翻译：这个接口被ViewGroup的子类实现来支持处理nest子视图的滑动操作。 Classes implementing this interface should create a final instance of a {@link NestedScrollingParentHelper} as a field and delegate any View or ViewGroup methodsto the NestedScrollingParentHelper methods of the same signature. 翻译：实现这个接口的类应该创建一个final类型的NestedScrollingParentHelper实例作为一个属性，来代理NestedScrollingParent中与NestedScrollingParentHelper具有相同方法名字的操作。 Views invoking nested scrolling functionality should always do so from the relevant {@link ViewCompat}, {@link ViewGroupCompat} or {@link ViewParentCompat} compatibility shim static methods. This ensures interoperability with nested scrolling views on Android 5.0 Lollipop and newer. 翻译：View调用嵌套滑动的相关功能时应该从相关的ViewCompat，ViewGroupCompat，ViewParentCompat调用兼容的静态方法，这保证了在5.0或者更新版本中与嵌套滑动的互用性。 onStartNestedScroll方法1public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes); 参数和返回值 12345678//ViewParent包涵的直接的子View@param child Direct child of this ViewParent containing target //启动嵌套滑动操作的View@param target View that initiated the nested scroll //flag垂直滑动还是水平滑动@param nestedScrollAxes Flags consisting of &#123;@link ViewCompat#SCROLL_AXIS_HORIZONTAL&#125;, &#123;@link ViewCompat#SCROLL_AXIS_VERTICAL&#125; or both //如果返回true代表父View接受消耗这个滑动操作。@return true if this ViewParent accepts the nested scroll operation React to a descendant view initiating a nestable scroll operation, claiming the nested scroll operation if appropriate. 翻译：对一个派生View的嵌套滑动操作作出反应，如果需要的话将会拦截（消耗）这个滑动操作。 This method will be called in response to a descendant view invoking ink ViewCompat#startNestedScroll(View, int)}. Each parent up the view hierarchy will be given an opportunity to respond and claim the nested scrolling operation by returning true. 翻译：这个方法将会被作为派生View调用ViewCompat.startNestedScroll(View, int)时的回复响应，每个上层的父视图如果这个方法返回true,都将有机会响应和拦截（消耗）这个嵌套滑动操作. onNestedScrollAccepted方法1public void onNestedScrollAccepted(View child, View target, int nestedScrollAxes); React to the successful claiming of a nested scroll operation. 翻译：对嵌套滑动操作的成功声明作出响应， This method will be called after {@link #onStartNestedScroll(View, View, int) onStartNestedScroll} returns true. It offers an opportunity for the view and its superclasses to perform initial configuration for the nested scroll. Implementations of this method should always call their superclass’s implementation of this method if one is present. 翻译：这个方法将会在 onStartNestedScroll方法返回true时被调用。这个方法提供给View和他的父类一个对嵌套滑动操作进行初始化配置的机会。如果父类对该方法有操作，实现此方法应该调用父类的实现。 onStopNestedScroll方法1public void onStopNestedScroll(View target); 参数和返回值 12//触发嵌套滑动的View@param target View that initiated the nested scroll React to a nested scroll operation ending. 翻译：对嵌套滑动结束做出响应 Perform cleanup after a nested scrolling operation.This method will be called when a nested scroll stops, for example when a nested touch scroll ends with a {@link MotionEvent#ACTION_UP} or {@link MotionEvent#ACTION_CANCEL} event. Implementations of this method should always call their superclass’s implementation of this method if one is present. 翻译：确认在嵌套滑动操作结束之后的清理操作，比如一些参数的重新初始化，这个方法将会在嵌套滑动操作结束后调用，比如嵌套滑动操作因为ACTION_UP，ACTION_CANCEL事件被终止。如果父类对该方法有操作，实现此方法应该调用父类的实现。 onNestedScroll方法1public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed); 参数和返回值 12345678910// 控制嵌套滑动的子View@param target The descendent view controlling the nested scroll// 子View水平滑动消耗的距离@param dxConsumed Horizontal scroll distance in pixels already consumed by target// 子View垂直滑动消耗的距离@param dyConsumed Vertical scroll distance in pixels already consumed by target// 子View水平滑动没有消耗的距离@param dxUnconsumed Horizontal scroll distance in pixels not consumed by target// 子View水平滑动没有消耗的距离@param dyUnconsumed Vertical scroll distance in pixels not consumed by target React to a nested scroll in progress. 翻译：对滑动过程作出响应 This method will be called when the ViewParent’s current nested scrolling child view dispatches a nested scroll event. To receive calls to this method the ViewParent must have previously returned true for a call to {@link #onStartNestedScroll(View, View, int)}. 翻译：这个方法将会在ViewParent中当前正在嵌套滑动的子View分发嵌套滑动事件时被调用。为了能够接受到调用这个方法，ViewParent必须事先在onStartNestedScroll返回true。 Both the consumed and unconsumed portions of the scroll distance are reported to the ViewParent. An implementation may choose to use the consumed portion to match or chase scroll position of multiple child elements, for example. The unconsumed portion may be used to allow continuous dragging of multiple scrolling or draggable elements, such as scrolling a list within a vertical drawer where the drawer begins dragging once the edge of inner scrolling content is reached. 翻译：消耗部分和没有消耗部分的嵌套滑动的距离都被上报给ViewParent。一个实现可以选择使用消耗的部分来匹配或追逐多个子元素的滚动位置，例如。未使用的部分可以用来允许连续滚动或拖动拖动多元素，如在一个垂直的抽屉内滚动一个列表，抽屉开始拖动滚动达到内容的边缘。 onNestedPreScroll方法1public void onNestedPreScroll(View target, int dx, int dy, int[] consumed); 参数和返回值 12345678// 发起嵌套滑动的子View@param target View that initiated the nested scroll// 水平滑动的距离@param dx Horizontal scroll distance in pixels// 垂直滑动的距离@param dy Vertical scroll distance in pixels// 输出,水平滑动和垂直滑动被父View消耗的距离@param consumed Output. The horizontal and vertical scroll distance consumed by this parent React to a nested scroll in progress before the target view consumes a portion of the scroll. 滑动过程中在发起嵌套滑动的子View消耗滑动距离之前作出反应 When working with nested scrolling often the parent view may want an opportunity to consume the scroll before the nested scrolling child does. An example of this is a drawer that contains a scrollable list. The user will want to be able to scroll the list fully into view before the list itself begins scrolling. 在进行嵌套滑动时，通常父View希望获得机会在子View之前消耗滑动距离。例如，抽屉里面包含一个可以滑动的list,用户将希望能够在列表本身开始滚动之前将列表完全滚动到视图中。 onNestedPreScroll is called when a nested scrolling child invokes {@link View#dispatchNestedPreScroll(int, int, int[], int[])}. The implementation should report how any pixels of the scroll reported by dx, dy were consumed in the consumed array. Index 0 corresponds to dx and index 1 corresponds to dy. This parameter will never be null. Initial values for consumed[0] and consumed[1] will always be 0. onNestedPreScroll 方法在子View调用dispatchNestedPreScroll方法时被调用。这个方法的实现应该报告对dx和dy进行了多少消耗。consumed[0]代表消耗的dx,consumed[1]代表消耗的dy,这个参数不会为空，consumed[0]和consumed[1]初始值为0。 onNestedFling方法1public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed); 参数和返回值 12345678910// 发起嵌套滑动的子View@param target View that initiated the nested scroll// 横向滑动的速度@param velocityX Horizontal velocity in pixels per second// 竖向滑动的速度@param velocityY Vertical velocity in pixels per second// 如果是true表示这个子View消耗了这个滑动@param consumed true if the child consumed the fling, false otherwise// 返回true表示，父View消耗滑动或其他情况@return true if this parent consumed or otherwise reacted to the fling Request a fling from a nested scroll. 需要嵌套滑动发生fling事件 This method signifies that a nested scrolling child has detected suitable conditions for a fling. Generally this means that a touch scroll has ended with a {@link VelocityTracker velocity} in the direction of scrolling that meets or exceeds the {@link ViewConfiguration#getScaledMinimumFlingVelocity() minimum fling velocity} along a scrollable axis. 这个方法意味着嵌套滑动的子View监测到一个适合fling的情况。通常意味着触摸事件在一个可滑动的轴上在一个方向上以一定速度结束，这个速度超过了ViewConfiguration#getScaledMinimumFlingVelocity()的值。 If a nested scrolling child view would normally fling but it is at the edge of its own content, it can use this method to delegate the fling to its nested scrolling parent instead. The parent may optionally consume the fling or observe a child fling. 如果一个子View在嵌套滑动但是到达了他的内容边缘，它可以使用这个方法将处理fling事件代理给父View,父View可以选择性的消耗fling事件或者观察子View的fling事件。 onNestedPreFling方法1public boolean onNestedPreFling(View target, float velocityX, float velocityY); 参数和返回值 12345678// 触发嵌套滑动的子View@param target View that initiated the nested scroll// 水平方向滑动速度@param velocityX Horizontal velocity in pixels per second// 垂直方向滑动速度@param velocityY Vertical velocity in pixels per second// 如果父View要处理这个fling事件返回true@return true if this parent consumed the fling ahead of the target view React to a nested fling before the target view consumes it. 在子View对嵌套fling事件消耗之前作出响应 This method siginfies that a nested scrolling child has detected a fling with the given velocity along each axis. Generally this means that a touch scroll has ended with a {@link VelocityTracker velocity} in the direction of scrolling that meets or exceeds the {@link ViewConfiguration#getScaledMinimumFlingVelocity() minimum fling velocity} along a scrollable axis. 这个方法意味着嵌套滑动的子View在每个轴上给定的速度上发生了fling事件，通常意味着触摸事件在一个可滑动的轴上在一个方向上以一定速度结束，这个速度超过了ViewConfiguration#getScaledMinimumFlingVelocity()的值。 If a nested scrolling parent is consuming motion as part of a {@link #onNestedPreScroll(View, int, int, int[]) pre-scroll}, it may be appropriate for it to also consume the pre-fling to complete that same motion. By returning true from this method, the parent indicates that the child should not fling its own internal content as well. 如果父View在onNestedPreScroll方法中消耗了嵌套滑动，那么他可能同样也想在fling事件中进行消耗操作，来完成处理嵌套滑动的请求。这个方法返回true表明子View应该只在它自己的区域内滑动。 getNestedScrollAxes()方法1public int getNestedScrollAxes(); 参数和返回值 12345// 表明滑动轴方向的flag@return Flags indicating the current axes of nested scrolling@see ViewCompat#SCROLL_AXIS_HORIZONTAL@see ViewCompat#SCROLL_AXIS_VERTICAL@see ViewCompat#SCROLL_AXIS_NONE A NestedScrollingParent returning something other than {@link ViewCompat#SCROLL_AXIS_NONE}］is currently acting as a nested scrolling parent for one or more descendant views in the hierarchy. 如果没有返回ViewCompat#SCROLL_AXIS_NONE，表明有子View在进行嵌套滑动。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SourceCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 6.0 权限动态申请]]></title>
    <url>%2Farticle%2F2939773101%2F</url>
    <content type="text"><![CDATA[minSdkVersion minSdkVersion指的是你的应用可以兼容到的最低版本，比如你只使用了2.X的API，那minSdkVersion就可以尽量小，以适配更多机型，小于minSdkVersion的机型将无法安装。 maxSdkVersion maxSdkVersion指的是你的应用可以支持到的最高版本，高于这个版本的机型将不能安装应用，但是这个不需要我们自己去写，Android系统默认向下兼容的。 targetSdkVersion targetSdkVersion如果设置了此属性，那么在程序执行时，如果目标设备的API版本正好等于此数值，他会告诉Android平台：此程序在此版本已经经过充分测，没有问题。不必为此程序开启兼容性检查判断的工作了。 介绍 由于Android M对隐私权限必须动态申请，当你的targetSdkVersion&gt;=23时就需要进行权限申请了，否则将获得不了权限。不过当targetSdkVersion&lt;23时，由于Android版本向下兼容性，你的应用将运行在&lt;23的环境中，不会出现问题。 Git上已经有很多开源库供大家使用了，确实方便简单，PermissionGen这个库好评率还是蛮高的，使用注解简化了很多操作，网上很多博客都推荐它，不过，我觉得不能遇到啥问题就引个别人的库进来， 一方面如果库的定制性不高，自定义起来也是麻烦，另一方面，像这种比较简单的问题，还是自己写比较好，可以了解一下是如何实现的，对自己的学习也有好处。别人封装的再好也不是自己的，以后只能说我会使用XX,XXX…类库.那就尴尬了。扯远了～ Android权限 Android M之后将权限分为了两类，Normal和Dangerous Permission,Dangerous Permission大都是跟用户隐私相关的权限，如下表，更详细见Android文档－Permissions Permission Group Permissions CALENDAR READ _ CALENDAR WRITE _ CALENDAR CAMERA CAMERA CONTACTS READ _ CONTACTS WRITE _ CONTACTS GET _ ACCOUNTS LOCATION ACCESS FINE LOCATION ACCESS COARSE LOCATION MICROPHONE RECORD _ AUDIO PHONE READ PHONE STATE CALL _ PHONE READ CALL LOG WRITE CALL LOG ADD _ VOICEMAIL USE _ SIP PROCESS OUTGOING CALLS SENSORS BODY _ SENSORS SMS SEND _ SMS RECEIVE _ SMS READ _ SMS RECEIVE WAP PUSH RECEIVE _ MMS STORAGE READ EXTERNAL STORAGE WRITE EXTERNAL STORAGE 思路和API 涉及到的核心方法context.requestPermissions(String[] permissions,int reqCode);该方法必须在Android M以上可以使用。大体的思路就是： 当前手机版本是不是大于Android M ？ 是否有私有权限需要申请？ 该权限是不是已经同意了 弹个dialog告诉用户我们将要申请哪些权限，现在市面上app大都是这么做的 开始申请 处理申请结果 PermissionHelper 为了方便操作，我将部分核心方法抽象出来了，调用checkPermission()申请权限，返回值会告诉你是不是需要申请，调用onRequestPermissionsResult()会格式化处理返回的数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * com.march.baselib.helper * CommonLib * Created by chendong on 16/8/17. * Copyright © 2016年 chendong. All rights reserved. * Desc : */public class PermissionHelper &#123; public static final int REQ_PERMISSION_CODE = 0x12; /** * 动态申请权限 * @param context 上下文 * @param permissions 需要申请的权限 * @return 是不是需要申请 */ public static boolean checkPermission(Activity context, String[] permissions) &#123; //6.0以上 if (AppHelper.isOverMarshmallow()) &#123; //没有权限需要申请时 if (permissions == null || permissions.length &lt;= 0) return true; //检查权限是不是已经授予 List&lt;String&gt; noOkPermissions = new ArrayList&lt;&gt;(); for (String permission : permissions) &#123; if (context.checkSelfPermission(permission) == PackageManager.PERMISSION_DENIED) &#123; noOkPermissions.add(permission); &#125; &#125; //该权限已经授予，不再申请 if (noOkPermissions.size() &lt;= 0) return true; //6.0以上需要申请权限 context.requestPermissions(noOkPermissions.toArray(new String[noOkPermissions.size()]), REQ_PERMISSION_CODE); return false; &#125; //6.0以下下不需要申请 return true; &#125; /** * 处理权限申请的结果，返回结构化的数据 * @param requestCode 请求码 * @param permissions 被请求的权限 * @param grantResults 请求结果 * @param listener 监听 */ public static void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults, OnPermissionHandleOverListener listener) &#123; if (requestCode != REQ_PERMISSION_CODE) return; Map&lt;String, Integer&gt; result = new HashMap&lt;&gt;(); boolean isHavePermissionNotOk = false; for (int i = 0; i &lt; Math.min(permissions.length, grantResults.length); i++) &#123; result.put(permissions[i], grantResults[i]); //有权限没有同意 if (grantResults[i] == PackageManager.PERMISSION_DENIED) &#123; isHavePermissionNotOk = true; &#125; &#125; //如果权限全部同意，继续执行 if (listener != null) listener.onHandleOver(!isHavePermissionNotOk, result); &#125; public interface OnPermissionHandleOverListener &#123; void onHandleOver(boolean isOkExactly, Map&lt;String, Integer&gt; result); &#125;&#125; BaseActivity 一般权限监测是在Activity进行，在基类中监测要简单方便 1234567891011121314151617181920212223242526272829303132333435@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mSaveBundle = savedInstanceState; mActivity = this; mContext = getApplicationContext(); createViewShow(); //如果不需要监测，会立刻执行invokeCommonMethod()开始Activity操作，如果需要就会发起申请 if (PermissionHelper.checkPermission(mActivity, getPermission2Check())) invokeCommonMethod(mSaveBundle); &#125; //抽象方法，由子类来决定哪些权限需要申请protected abstract String[] getPermission2Check();//子类实现决定处理结果protected boolean handlePermissionResult(Map&lt;String, Integer&gt; resultNotOk) &#123; return true;&#125;//处理返回结果@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); PermissionHelper.onRequestPermissionsResult(requestCode, permissions, grantResults, new PermissionHelper.OnPermissionHandleOverListener() &#123; @Override public void onHandleOver(boolean isOkExactly, Map&lt;String, Integer&gt; result) &#123; //权限ok或者子类要求直接执行 if (isOkExactly || handlePermissionResult(result)) invokeCommonMethod(mSaveBundle); &#125; &#125;); &#125; 子类12345678910111213141516//哪些权限需要申请@TargetApi(Build.VERSION_CODES.JELLY_BEAN)@Overrideprotected String[] getPermission2Check() &#123; return new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;;&#125;//如果权限没有获得如何处理@Overrideprotected boolean handlePermissionResult(Map&lt;String, Integer&gt; resultNoOk) &#123; if (resultNoOk.get(Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_DENIED) &#123; Toaster.get().show("您没有允许读取存储卡，不能继续操作"); return false; &#125; return true;&#125; 以上]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现单例]]></title>
    <url>%2Farticle%2F3789624758%2F</url>
    <content type="text"><![CDATA[单例装饰器 在网上查到很多方式，选择一种比较pythonic的方式 123456789def singleton(cls, *args, **kwargs): instances = &#123;&#125; def _singleton(): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return _singleton 使用12345678@singletonclass HttpHelper: def __init__(self): pass name = 'http helper' ...... ....]]></content>
      <categories>
        <category>Study</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python普通方法、静态方法、类方法]]></title>
    <url>%2Farticle%2F1727896955%2F</url>
    <content type="text"><![CDATA[开始123456789101112131415161718192021222324# -*-coding:utf-8-*-# 普通方法,类方法,静态方法的区别__metaclass__ = typeclass Tst: name = 'tst' data = 'this is data' # 普通方法 def normalMethod(self, name): print self.data, name # 类方法,可以访问类属性 @classmethod def classMethod(cls, name): print cls.data, name # 静态方法,不可以访问类属性 @staticmethod def staticMethod(name): print name 测试 三种方法都可以通过实例来调用，但是静态方法和类方法无法访问实例属性，所以更改了tst.data仅对普通方法起了作用 12345678910tst = Tst()tst.data = 'this is new'tst.normalMethod('name')tst.staticMethod('name')tst.classMethod('name')#结果this is new namenamethis is data name 区别 普通方法不能通过类名调用，但是静态方法和类方法是可以的 12345678# error普通方法必须通过实例调用# Tst.normalMethod(&apos;name&apos;)Tst.classMethod(&apos;name&apos;)Tst.staticMethod(&apos;name&apos;)#结果this is data namename 总结 普通方法,可以通过self访问实例属性 1def normalMethod(self,data) 类方法,可以通过cls访问类属性 12@classmethoddef classMethod(cls,data) 静态方法,不可以访问,通过传值的方式 12@staticmethoddef staticMethod(data)]]></content>
      <categories>
        <category>Study</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Json相关]]></title>
    <url>%2Farticle%2F2150468451%2F</url>
    <content type="text"><![CDATA[开始12345678910111213141516171819202122232425# -*-coding:utf-8-*-import jsonfrom httptst.Singleton import singleton@singletonclass JsonHelper(object): name = 'json helper' def convert_to_builtin_type(obj): print 'default(', repr(obj), ')' dict = &#123;&#125; dict.update(obj.__dict__) return dict # obj 转 json def getJson(self, obj): data = json.dumps(obj, sort_keys=True, default=self.convert_to_builtin_type) return data # json str 转dict def parse(self, jsonStr): jsonDict = json.loads(jsonStr) return jsonDict]]></content>
      <categories>
        <category>Study</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android添加快捷方式]]></title>
    <url>%2Farticle%2F3591670187%2F</url>
    <content type="text"><![CDATA[权限12&lt;uses-permission android:name="com.android.launcher.permission.INSTALL_SHORTCUT"/&gt;&lt;uses-permission android:name="com.android.launcher.permission.UNINSTALL_SHORTCUT"/&gt; 配置 快捷方式要打开一个界面，需要一个Intent配置这些信息 1234567891011121314/*** 获取Intent** @param thisActivity 当前activity* @param goActivity 点击打开的activity* @return 创建的Intent*/private static Intent getShortCutIntent(Activity thisActivity, Class goActivity) &#123; // 使用MAIN，可以避免部分手机(比如华为、HTC部分机型)删除应用时无法删除快捷方式的问题 Intent intent = new Intent(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGORY_DEFAULT); intent.setClass(thisActivity, goActivity); return intent;&#125; Action1234// Action 添加Shortcutpublic static final String ACTION_ADD_SHORTCUT = "com.android.launcher.action.INSTALL_SHORTCUT";// Action 移除Shortcutpublic static final String ACTION_REMOVE_SHORTCUT = "com.android.launcher.action.UNINSTALL_SHORTCUT"; 添加快捷方式123456789101112131415161718192021222324252627282930/*** 添加快捷方式** @param activity context* @param name name* @param goActivity 要启动的界面* @param allowRepeat 是否允许重复,建议false* @param iconBitmap 快捷方式图标*/public static void addShortcut(Activity activity, Class goActivity, String name,boolean allowRepeat, Bitmap iconBitmap) &#123; Intent addShortcutIntent = new Intent(ACTION_ADD_SHORTCUT); // 是否允许重复创建 addShortcutIntent.putExtra("duplicate", allowRepeat); // 快捷方式的标题 addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_NAME, name); // 快捷方式的图标 addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_ICON, iconBitmap); // 快捷方式的动作 Intent shortCutIntent = getShortCutIntent(activity, goActivity); addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortCutIntent); activity.sendBroadcast(addShortcutIntent);&#125;public static void addShortcut(Activity activity, Class goActivity, String name, boolean allowRepeat, int res) &#123; BitmapFactory.Options options = new BitmapFactory.Options(); Bitmap bitmap = BitmapFactory.decodeResource(activity.getResources(), res); addShortcut(activity, goActivity, name, allowRepeat, bitmap);&#125; 移除快捷方式12345678910111213141516/** * 移除快捷方式 * * @param activity context * @param goActivity 要启动的Activity * @param name name */public static void removeShortcut(Activity activity, Class goActivity, String name) &#123; Intent intent = new Intent(ACTION_REMOVE_SHORTCUT); intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, name); //intent.addCategory(Intent.CATEGORY_LAUNCHER); intent.putExtra("duplicate", false); Intent shortCutIntent = getShortCutIntent(activity, goActivity); intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortCutIntent); activity.sendBroadcast(intent);&#125; 附全部代码，亲测可用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * com.march.libs.helper * CdLibsTest * Created by chendong on 16/7/29. * Copyright © 2016年 chendong. All rights reserved. * Desc : */public class ShortCutHelper &#123; // Action 添加Shortcut public static final String ACTION_ADD_SHORTCUT = "com.android.launcher.action.INSTALL_SHORTCUT"; // Action 移除Shortcut public static final String ACTION_REMOVE_SHORTCUT = "com.android.launcher.action.UNINSTALL_SHORTCUT"; /** * 获取Intent * * @param thisActivity 当前activity * @param goActivity 点击打开的activity * @return 创建的Intent */ private static Intent getShortCutIntent(Activity thisActivity, Class goActivity) &#123; // 使用MAIN，可以避免部分手机(比如华为、HTC部分机型)删除应用时无法删除快捷方式的问题 Intent intent = new Intent(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGORY_DEFAULT); intent.setClass(thisActivity, goActivity); return intent; &#125; /** * 添加快捷方式 * * @param activity context * @param name name * @param goActivity 要启动的界面 * @param allowRepeat 是否允许重复 * @param iconBitmap 快捷方式图标 */ public static void addShortcut(Activity activity, Class goActivity, String name, boolean allowRepeat, Bitmap iconBitmap) &#123; Intent addShortcutIntent = new Intent(ACTION_ADD_SHORTCUT); // 是否允许重复创建 addShortcutIntent.putExtra("duplicate", allowRepeat); // 快捷方式的标题 addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_NAME, name); // 快捷方式的图标 addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_ICON, iconBitmap); // 快捷方式的动作 Intent shortCutIntent = getShortCutIntent(activity, goActivity); addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortCutIntent); activity.sendBroadcast(addShortcutIntent); &#125; public static void addShortcut(Activity activity, Class goActivity, String name, boolean allowRepeat, int res) &#123; BitmapFactory.Options options = new BitmapFactory.Options(); Bitmap bitmap = BitmapFactory.decodeResource(activity.getResources(), res); addShortcut(activity, goActivity, name, allowRepeat, bitmap); &#125; /** * 移除快捷方式 * * @param activity context * @param goActivity 要启动的Activity * @param name name */ public static void removeShortcut(Activity activity, Class goActivity, String name) &#123; Intent intent = new Intent(ACTION_REMOVE_SHORTCUT); intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, name); //intent.addCategory(Intent.CATEGORY_LAUNCHER); intent.putExtra("duplicate", false); Intent shortCutIntent = getShortCutIntent(activity, goActivity); intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortCutIntent); activity.sendBroadcast(intent); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 范型]]></title>
    <url>%2Farticle%2F2053934834%2F</url>
    <content type="text"><![CDATA[关于如何继承带有范型的基类 继承父类的范型12345678910111213141516171819202122232425262728293031public class GenericityTst &#123; public class Temp &#123; &#125; //具有泛型的ClassA public class ClassA&lt;T&gt;&#123; T t; &#125; //继承泛型 public class ClassB&lt;T&gt; extends ClassA&lt;T&gt;&#123; T t; &#125; //缩小泛型的范围，是准许的，但是不允许扩大泛型的范围 public class ClassC&lt;T extends Temp&gt; extends ClassA&lt;T&gt;&#123; T t; &#125; //具有泛型的类ClassD,泛型具有父类约束 public class ClassD&lt;T extends Temp&gt; &#123; T t; &#125; //继承ClassD,声明泛型时至少具有父类同样的约束 public class ClassE&lt;T extends Temp&gt; extends ClassD&lt;T&gt;&#123; T t; &#125;&#125;]]></content>
      <categories>
        <category>Study</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 AS 中使用 Lambda 表达式]]></title>
    <url>%2Farticle%2F4229621729%2F</url>
    <content type="text"><![CDATA[配置 AndroidStudio 支持 Lambda 表达式 根目录下gradle文件配置 在project / build.gradle中配置 123456789buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.1.3&apos; classpath &apos;me.tatarka:gradle-retrolambda:3.2.5&apos; &#125;&#125; app下gradle文件配置 在project / app / build.gradle顶部配置插件 12apply plugin: &apos;me.tatarka.retrolambda&apos;... 在android{…}中配置12345678910111213android &#123; ...... // 注释冲突 packagingOptions &#123; exclude &apos;META-INF/services/javax.annotation.processing.Processor&apos; &#125; // 使用Java1.8 compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125; ......&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>DevEnvironment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORM框架－GreenDao2.0]]></title>
    <url>%2Farticle%2F3564593419%2F</url>
    <content type="text"><![CDATA[GreenDao官网官网 -&gt; http://greendao-orm.com GitHubGitHub -&gt; https://github.com/greenrobot/greenDAO 性能对比 介绍 GreenDao采用的是用java代码直接生成Bean（实体）和Dao（Data Access Object数据访问对象）的方式，都不用自己写实体了，也是一大好处，不过这也造成了理解上的难度，我刚开始用的时候就有点蒙。 首先创建一个Java的Library,一定是Java的，命名为daogenerator（可以起别的名字，为了后面叙述方便）。在app下面和’java’目录同级创建’java-gen’目录，将会用来放置生成的Bean和Dao。Dao也就是数据访问对象，实体类只能描述一个对象的属性和行为，想与数据库交流就需要Dao对象，它包含对应的数据库字段和增删改查方法。 生成文件 在daogenerator库里创建’ExampleDaoGenerator.java’文件,包含main方法，构建schema，生成目录和文件 123456789101112131415161718192021public static void main(String[] args) throws Exception&#123; operate();&#125;private static void operate() throws Exception &#123; // Schema对象，可以用来生成实体和dao // 两个参数分别代表：数据库版本号与自动生成bean代码的包路径。 Schema schema = new Schema(2, "com.march.bean"); // 默认的dao目录 schema.setDefaultJavaPackageDao("com.march.dao"); // 模式（Schema）同时也拥有两个默认的 flags，分别用来标示 entity 是否是 activie 以及是否使用 keep sections。 // 可以激活预热实体，使读写更迅速 schema.enableActiveEntitiesByDefault(); // 这个是为了你可以在自动生成的实体类中添加自己的custom代码 schema.enableKeepSectionsByDefault(); // 一旦你拥有了一个 Schema 对象后，你便可以使用它添加实体（Entities）了。这里只是一个假的方法表示一下，生成实体在下一节 generateBean(schema); // 最后我们将使用 DAOGenerator 类的 generateAll() 方法自动生成代码，此处你需要根据自己的情况更改输出目录（既之前创建的 java-gen)。 // 其实，输出目录的路径可以在 build.gradle 中设置，有兴趣的朋友可以自行搜索，这里就不再详解。 new DaoGenerator().generateAll(schema, "/Users/march/AndroidPro/Reaper/app/src/main/java-gen");&#125; 如何生成实体12345678910111213private static void addNote(Schema schema) &#123; // 一个实体（类）就关联到数据库中的一张表，此处表名为「Note」（既类名） Entity note = schema.addEntity("Note"); // greenDAO 会自动根据实体类的属性值来创建表字段，并赋予默认值 // 接下来你便可以设置表中的字段,又很多链式编程的方法，结合数据库的create table操作可以设置相关的字段及约束 note.addIdProperty().autoincrement(); note.addBooleanProperty("isYes").primaryKey().unique(); note.addStringProperty("text").notNull(); // 与在 Java 中使用驼峰命名法不同，默认数据库中的命名是使用大写和下划线来分割单词的。 // For example, a property called “creationDate” will become a database column “CREATION_DATE”. note.addStringProperty("comment"); note.addDateProperty("date");&#125; 自定义生成的代码 当重新执行java代码时会覆盖生成新的文件，如果你修改了生成的类，就会被重新覆盖，解决这个问题，设置note.setHasKeepSections(true);会在文件中生成一些注释，在注释中间的代码将不会被覆盖，也可以设置继承，实现等。。。这样就不需要每次都修改代码了 1234567891011121314151617181920// KEEP INCLUDES - put your custom includes hereimport com.march.quickrvlibs.inter.RvQuickInterface;// KEEP INCLUDES END// KEEP FIELDS - put your custom fields herepublic static final int TYPE_SHU = 0;public static final int TYPE_HENG = 1;// KEEP FIELDS END// KEEP METHODS - put your custom methods here@Overridepublic int getRvType() &#123; if (height &gt; width) return 0; else return 1;&#125;// KEEP METHODS END 12345678//设置支持自定义代码（或schema.enableKeepSectionsByDefault();）note.setHasKeepSections(true);//设置实现的接口note.implementsInterface("RvQuickInterface", "java.io.Serializable");//设置继承的父类note.setSuperclass("Album");//你也可以重新给表命名note.setTableName("NODE"); 初始化数据库123456789101112131415private DaoSession mDaoSession;public void setupDatabase(Context context) &#123; // 通过 DaoMaster 的内部类 DevOpenHelper，你可以得到一个便利的 SQLiteOpenHelper 对象。 // 可能你已经注意到了，你并不需要去编写「CREATE TABLE」这样的 SQL 语句，因为 greenDAO 已经帮你做了。 // 注意：默认的 DaoMaster.DevOpenHelper 会在数据库升级时，删除所有的表，意味着这将导致数据的丢失。 // 所以，在正式的项目中，你还应该做一层封装，来实现数据库的安全升级。 DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(context, "notes-db", null); SQLiteDatabase db = helper.getWritableDatabase(); // 注意：该数据库连接属于 DaoMaster，所以多个 Session 指的是相同的数据库连接。 DaoMaster daoMaster = new DaoMaster(db); mDaoSession = daoMaster.newSession(); // 在 QueryBuilder 类中内置两个 Flag 用于方便输出执行的 SQL 语句与传递参数的值 QueryBuilder.LOG_SQL = true; QueryBuilder.LOG_VALUES = true;&#125; 获取Dao123public WholeAlbumItemDao getWholeAlbumItemDao() &#123; return mDaoSession.getWholeAlbumItemDao();&#125; 增12345678910//这两个方法提供简单的插入和不存在则插入存在则更新的操作DaoHelper.get().getAlbumDetailDao().insert();DaoHelper.get().getAlbumDetailDao().insertOrReplace();//这两个方法是上面两个方法的加强版，支持iterable类型多个对象的插入和更新，同时是基于事务的。DaoHelper.get().getAlbumDetailDao().insertInTx();DaoHelper.get().getAlbumDetailDao().insertOrReplaceInTx();//官方解释:Insert an entity into the table associated with a concrete DAO &lt;b&gt;without&lt;/b&gt; setting key property.//Warning: This may be faster, but the entity should not be used anymore. The entity also won't be attached to identity scope.//大概意思就是小心点用，虽然速度快，但是插进去可能就拿不出来了DaoHelper.get().getAlbumDetailDao().insertWithoutSettingPk() 删1234567891011//与insert方法大同小异DaoHelper.get().getAlbumDetailDao().delete();DaoHelper.get().getAlbumDetailDao().deleteInTx();//根据主键删除元素DaoHelper.get().getAlbumDetailDao().deleteByKey();DaoHelper.get().getAlbumDetailDao().deleteByKeyInTx();//删除全部DaoHelper.get().getAlbumDetailDao().deleteAll();//也是删除，具体的区别还没弄明白DaoHelper.get().getAlbumDetailDao().detach()DaoHelper.get().getAlbumDetailDao().detachAll(); 改12DaoHelper.get().getAlbumDetailDao().update();DaoHelper.get().getAlbumDetailDao().updateInTx(); 查 关于Query的操作相对复杂， 下面只是比较基本的，更多的使用方法可以参照Query文档 12345678910111213141516171819// 获取querybuilderQueryBuilder&lt;RecommendAlbumItem&gt; queryBuilder = DaoHelper.get().getRecommendAlbumItemDao().queryBuilder();// 查询条件，大于小于，and,orqueryBuilder.where( RecommendAlbumItemDao.Properties.Album_type.eq(""), queryBuilder.or(RecommendAlbumItemDao.Properties.Album_cover.gt(""), queryBuilder.and(RecommendAlbumItemDao.Properties.Album_cover.ge("") ,RecommendAlbumItemDao.Properties.Album_cover.eq(""))));// offset limmit queryBuilder.offset(10).limit(10);//排序queryBuilder.orderAsc();queryBuilder.orderCustom(null,null);queryBuilder.orderDesc();queryBuilder.build();//查询数量queryBuilder.count();//返回listqueryBuilder.list();]]></content>
      <categories>
        <category>Android</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 安装 Mongdb]]></title>
    <url>%2Farticle%2F3372882306%2F</url>
    <content type="text"><![CDATA[MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。 在高负载的情况下，添加更多的节点，可以保证服务器性能。MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 特点:高性能、易部署、易使用，存储数据非常方便。 安装 MongoDb安装homebrew 1$ /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 更新homebrew 1$ brew update 安装mongodb 1$ brew install mongodb 配置环境变量1234$ open ~/.bash_profile # 写入以下路径# mongodbexport PATH=$&#123;PATH&#125;:/usr/local/Cellar/mongodb/3.2.6/bin 根据配置启动mongodb使用该命令将会使用mongod.conf文件的相关配置来启动mongodb 文件的路径在 /usr/local/etc/mongod.conf（Mac） 从配置文件可以看到数据库的路径以及log的路径等。 1234567891011$ mongod --config /usr/local/etc/mongod.conf# mongod.conf 文件内容systemLog: destination: file path: /usr/local/var/log/mongodb/mongo.log logAppend: truestorage: dbPath: /usr/local/var/mongodbnet: bindIp: 127.0.0.1 直接启动直接启动快捷简单，数据将会存储在/data/db下,其中/data路径与/usr路径是同级的。 123456789数据会存放在/data/db 目录下，需要首先创建目录，并更改目录权限$ mkdir -p /data/db $ sudo chown -R march /data启动mongodb服务$ mongod输入 mongo ，连接到mongo服务，即可进入命令行操作$ mongo]]></content>
      <categories>
        <category>Study</category>
        <category>Db</category>
      </categories>
      <tags>
        <tag>Database</tag>
        <tag>MongoDb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Django服务器搭建初体验]]></title>
    <url>%2Farticle%2F1002618664%2F</url>
    <content type="text"><![CDATA[前言 安装的部分工具，我是在Mac下使用，其他的平台自己搜索一下如何安装。现在默认你已经安装了Python环境，我的是Python2.7 安装pip包管理器 pip包管理器是python下安装模块的工具 1234567$ curl -O https://raw.github.com/pypa/pip/master/contrib/get-pip.py$ [sudo] python get-pip.py# 安装包$ pip install django# 卸载包$ pip uninstall django 安装ipython ipython是一个增强式的python交互式操作命令工具，有自动提示和补全的功能 1$ pip install ipython 安装django1$ pip install django 简单尝试12345678910111213141516171819# 创建一个项目$ django -admin startproject mysite# 开启服务$ python manage.py runserver# 出现如下字样May 14, 2016 - 00:00:21Django version 1.9.6, using settings 'mysite.settings'Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C.Not Found: /[14/May/2016 00:00:32] "GET / HTTP/1.1" 200 1767Not Found: /favicon.ico[14/May/2016 00:00:32] "GET /favicon.ico HTTP/1.1" 404 1936# 打开浏览器输入`http://127.0.0.1:8000/`就可以看到It worked字样，一个简单的web服务就好了# 你可以使用`python manage.py`查看更多的命令 各个文件的简单介绍12345678910$ cd mysite/$ lsmanage.py mysite# manage.py是一个管理工具，使用它可以管理服务器，比如开启服务等# mysite是你的工程目录$ cd mysite/__init__.py settings.py urls.py wsgi.py__init__.pyc settings.pyc urls.pyc wsgi.pyc# settings.py 是一些配置信息# urls.py 是url的映射，他表示不同的url会映射到不同的网页 建立app django是使用app的形式来配置模块，你可以建立新的模块 12345678910111213$ python manage.py startapp blog# 可以发现在mysite目录下有了blog和mysite两个文件夹# 在mysite/mysite/settings.py中配置这个app模块# Application definitionINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'blog'] 构建一个简单的网页123456789101112131415161718192021222324252627$ cd blog/$ ls_init__.py admin.pyc models.py views.py__init__.pyc apps.py models.pyc views.pycadmin.py migrations tests.py# blog目录下的文件，我们现在只使用views.py，他是用来构建输出html 页面的一个类#（1）打开views.py 定义一个简单的html页面from django.shortcuts import renderfrom django.http import HttpResponse# Create your views here.def hello(request): return HttpResponse('&lt;html&gt;hello world&lt;/html&gt;') # (2) 打开mysite/mysite/urls.py 配置url映射from django.conf.urls import urlfrom django.contrib import adminurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'hello','blog.views.hello')]# (3) 启动服务,在浏览器输入http://127.0.0.1:8000/hello,可以获得返回的网页$ python manage.py runserver]]></content>
      <categories>
        <category>Study</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js基础1]]></title>
    <url>%2Farticle%2F3697016025%2F</url>
    <content type="text"><![CDATA[基本工具的配置检测xcode是否安装12$ xcode-select -p/Applications/Xcode.app/Contents/Developer 检测python和ruby版本12$ python -v$ ruby -v 安装homebrew1$ /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装node.js1$ brew install node 第一个web应用创建连接12345678910111213141516//新建一个文件，为server.js,内容如下const http = require('http');const hostname = '127.0.0.1';const port = 3000;const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello World\n');&#125;);server.listen(port, hostname, () =&gt; &#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;); 启动服务 到相应目录下运行命令,打开浏览器输入http://127.0.0.1:3000/可以看到服务已经起来了，使用ctrl+c停止服务 1$ node server.js]]></content>
      <categories>
        <category>Study</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift基础2]]></title>
    <url>%2Farticle%2F1243741076%2F</url>
    <content type="text"><![CDATA[可选型的概念 数据类型＋？将会构成一种新的类型，可选型，String?为字符串可选型，，在swift中，空的概念略有不同，java中，如果一个对象变量，没有指向，为null；一个int类型的变量如果没有初始化，值为0，null和0 意为没有，在swift中，空是一种完全独立的数据类型，nil的位置和Int，String的地位是一样的，他不是对象或者数据的一种特殊状态，而是一种新的对象。这也就意味着代码中(1)的部分是编译错误的，会提示，nil类型是不能和String类型进行的比较的，该设计的目的是为了使swift更具安全性，因为任何对象都不能设置为nil,就如同String类型的数据不能设置为int类型的数据，他们是完全不同的对象，可以避免潜在空指针的发生。 123456789101112131415161718192021222324//(1)var str = "abc"if(str == nil)&#123;&#125;//String? 为String可选型，他意味着这种类型，可以为nil,还是那句话，可选型和nil不是一个类型的特殊状态，他是一种新的类型。//2var optionalStr:String? = "hello"optionalStr = "world"print(optionalStr == nil) var greet = "hey"if let name = optionalStr&#123; greet = "hello \(name)";&#125;print(greet) if(optionalStr != nil)&#123; print("optional str is not nil")&#125; where与模式匹配1234567891011121314151617181920212223242526272829303132333435//switch中使用where语句let point = (3,3)switch point &#123; case let(x,y) where x == y: print("x == y") case let(x,y) where x == -y: print("x == -y") default: print("rst is \(point.0) , \(point.1)")&#125;//switch中使用运算符 let age = 19switch age&#123; case 10 ... 19: print("teenager") default: print("not teenager")&#125; //if中使用模式 if case 10...19 = age where age &gt; 18&#123; print("teenager and in colldge")&#125; //if中使用模式和where语句let vector = (4,0)if case (let x,0) = vector where x &gt; 2 &amp;&amp; x &lt; 5&#123; print("it is vector")&#125; //if中使用模式＋where+运算符 for case let i in 1 ... 100 where i % 3==0&#123; print("i is \(i)")&#125; guard关键字12345678910111213//guard else 防止数据错误，也可以认为是需要满足的一种先决条件//例如下面money&gt;price,capacity &gt; volume是必须满足的条件，简化语法，防止错误func buy(money:Int,price:Int,capacity:Int,volume:Int) -&gt; Bool&#123; guard money &gt; price else &#123; print("not money") return false &#125; guard capacity &gt; volume else&#123; print("not volume") return false &#125; return true&#125; String类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//字符串var originStr = "this is str"originStr = "this is new str"//定义一个空字符串let emptyStr = ""//判空操作print(emptyStr.isEmpty)//合并字符串var rstStr = originStr + emptyStr//使用+=,此时rstStr必须是变量rstStr += originStr//字符串插值rstStr = "this is new str and insert \(100)"//转义字符 \//遍历字符串for c in originStr.characters&#123; print(c)&#125; //Characterlet cc:Character = "!"originStr.append(cc) //字符串长度，基于unicode码，也就是说不管是3个汉字或者3个字母，它的count都是3let englishLetter = "abc"let chinseLetter = "慕课网"let emojiLetter = "😢😢😢"let unicodeLetter = "\u&#123;1f60e&#125;\u&#123;0301&#125;"print(englishLetter.characters.count)print(chinseLetter.characters.count)print(emojiLetter.characters.count)print("enlish is \(englishLetter) chinse is \(chinseLetter) emoji is \(emojiLetter) unicode is \(unicodeLetter)") //索引访问字符串，需要使用String.Index类来访问//[startIndex,endIndex)let startIndex = originStr.startIndexlet endIndex = originStr.endIndexprint("index is \(startIndex) and content is \(originStr[startIndex])")//向后n个startIndex.advancedBy(6)//前面一个位置endIndex.predecessor()//后面一个位置startIndex.successor() //String的一些API//Range&lt;Index&gt;类型let range = startIndex.advancedBy(3) ..&lt; endIndexoriginStr.replaceRange(range, with: "!!!")originStr.appendContentsOf("xxx")originStr.insert("z", atIndex: originStr.endIndex) originStr.removeAtIndex(originStr.endIndex.predecessor()) originStr.removeRange(originStr.endIndex.advancedBy(-2)..&lt;originStr.endIndex) print("upper \(originStr.uppercaseString) low \(originStr.lowercaseString) First up \(originStr.capitalizedString)")originStr.containsString("")originStr.hasSuffix("")originStr.hasPrefix("") //NSString let s2 = NSString(format: "one third is %.2f",1.0/3.0)print("转换 \(s2 as String)") let nsStr:NSString = "one third is 0.33"nsStr.substringFromIndex(4)nsStr.substringFromIndex(3)nsStr.substringWithRange(NSMakeRange(4, 5)) let s6 = " --- Hello --- " as NSString//去掉空格和－print(s6.stringByTrimmingCharactersInSet(NSCharacterSet(charactersInString:" -"))]]></content>
      <categories>
        <category>Study</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防止app闪白屏或闪黑屏]]></title>
    <url>%2Farticle%2F3133739946%2F</url>
    <content type="text"><![CDATA[App启动时需要加载应用进程，就算你的软件在 Appliation 中什么也没做仍旧会有延时，会显示白屏或者黑屏，很难看。本文主要介绍去掉闪屏，白屏或黑屏的几种方案。 透明 Theme 使用透明Theme解决，原理就是虽然程序启动了，但是没有显示出来，你看到的还是桌面，目前主流的产品都是用的这种方式，比如QQ，微信。缺点就是等待的时间长，造成程序启动慢的感觉。 1234&lt;style name="Theme.AppStartUseTransparent" parent="Theme.AppCompat.NoActionBar"&gt; &lt;item name="android:windowIsTranslucent"&gt;true&lt;/item&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt;&lt;/style&gt; 图片 Theme 使用图片Theme解决，原理就是设置一张背景图，在你的程序没有加载完成的时候会显示这张背景图，你也可以用shape自定义或者使用图片，优点就是启动很快，显示的效果取决于你的图片。 1234&lt;style name="Theme.AppStartUseDrawable" parent="Theme.AppCompat.NoActionBar"&gt; &lt;item name="android:windowBackground"&gt;@drawable/shape_maincolor&lt;/item&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt;&lt;/style&gt; 在 manifest.xml 使用 我是AppCompat的风格，你可以对parent＝“”做适当修改。 123456789 &lt;activity android:name=".activity.LoadingActivity" android:theme="@style/Theme.AppStartUseTransparent"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView添加Header和Footer的基本原理]]></title>
    <url>%2Farticle%2F4007050602%2F</url>
    <content type="text"><![CDATA[介绍 采用的基本原理就是Header和Footer作为RecyclerView的一个Item，只是显示的方式特别一点，ListView实际也是这么做的所以添加了Header之后，数据的位置会错乱。 由于使用不同的LayoutManager时显示效果也不一样， 所以针对不同的LayoutManager需要做不同的操作。 分析一下，LinearLayoutManager比较简单，只需要将Header和Footer作为一项就可以了，GridLayoutManager和StaggeredGridLayoutManager在这个基础上还需要将Header和Footer所在的Item充满他所在的这一行。 变量和方法123456789101112131415161718//Header和Footer,以及对应的Typeprivate View mHeaderView;private View mFooterView;private int TYPE_HEADER = -1;private int TYPE_FOOTER = -2;//一些辅助的方法public int getHeaderCount() &#123; return isHasHeader() ? 1 : 0;&#125;private boolean isHasHeader() &#123; return mHeaderView != null;&#125;private boolean isHasFooter() &#123; return mFooterView != null;&#125; 根据是否有Header和Footer获取数据Size123456789101112//根据是否有Header和Footer返回不同的Size@Overridepublic int getItemCount() &#123; int pos = datas.size(); if (isHasHeader()) pos++; if (isHasFooter()) pos++; return pos;&#125; 根据是否有Header和Footer获取Type12345678910111213141516171819202122//获取item的type，基本逻辑是如果有header又是位于第一个的则返回HeaderType,如果pos超出了data的size，又是最后一个，则返回FooterType@Overridepublic int getItemViewType(int position) &#123; //如果没有header没有footer直接返回 if (!isHasHeader() &amp;&amp; !isHasFooter()) return datas.get(position).getRvType(); //有header且位置0 if (isHasHeader() &amp;&amp; position == 0) return TYPE_HEADER; //pos超出 if (isHasFooter() &amp;&amp; position == getItemCount() - 1) return TYPE_FOOTER; //如果有header,下标减一个 if (isHasHeader()) return datas.get(position - 1).getRvType(); else //没有header 按照原来的 return datas.get(position).getRvType();&#125; 根据是否有Header和Footer创建Holder123456789101112//根据返回的不同的type使用HeaderView和FooterView初始化Holder,至此已经可以对LinearLayoutManager添加Header和Footer@Overridepublic RvViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; RvViewHolder holder; if (isHasFooter() &amp;&amp; viewType == TYPE_FOOTER) &#123; holder = new RvFooterHolder(mFooterView); &#125; else if (isHasHeader() &amp;&amp; viewType == TYPE_HEADER) &#123; holder = new RvHeaderHolder(mHeaderView); &#125; else &#123; holder = new RvViewHolder(getInflateView(Res4Type.get(viewType).getResId(), return holder;&#125; LinearLayoutManager 由于LinearLayoutManager是连续排列的，所以只需要创建不同的holder就可以实现header+footer GridLayoutManager 首先如何知道是否是GridLayoutManager,重写onAttachedToRecyclerView方法获取Manager,调用gridLayoutManager.setSpanSizeLookup（）方法，设置他跨越的宽度。 12345678910111213141516171819202122@Overridepublic void onAttachedToRecyclerView(RecyclerView recyclerView) &#123; super.onAttachedToRecyclerView(recyclerView); Log.e("chendong","onAttachedToRecyclerView"); RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager(); if (layoutManager instanceof GridLayoutManager) &#123; final GridLayoutManager gridLayoutManager = (GridLayoutManager) layoutManager; gridLayoutManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() &#123; @Override public int getSpanSize(int position) &#123; return getItemViewType(position) == TYPE_HEADER || getItemViewType(position) == TYPE_FOOTER ? gridLayoutManager.getSpanCount() : 1; &#125; &#125;); return; &#125; //判断是不是StaggeredGridLayoutManager if(layoutManager instanceof StaggeredGridLayoutManager)&#123; isStaggeredGridLayoutManager = true; &#125;&#125; StaggeredGridLayoutManager 主要使用StaggeredGridLayoutManager.LayoutParams的 layoutParams.setFullSpan(true);方法设置 123456789101112131415161718192021222324252627282930@Overridepublic RvViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; RvViewHolder holder; if (isHasFooter() &amp;&amp; viewType == TYPE_FOOTER) &#123; holder = new RvFooterHolder(mFooterView); &#125; else if (isHasHeader() &amp;&amp; viewType == TYPE_HEADER) &#123; holder = new RvHeaderHolder(mHeaderView); &#125; else &#123; holder = new RvViewHolder(getInflateView(Res4Type.get(viewType).getResId(), parent)); if (clickListener != null) &#123; holder.setOnItemClickListener(clickListener); &#125; if (longClickListenter != null) &#123; holder.setOnItemLongClickListener(longClickListenter); &#125; &#125; //关键代码 if (isStaggeredGridLayoutManager &amp;&amp; (holder instanceof RvHeaderHolder || holder instanceof RvFooterHolder)) &#123; Log.e("chendong","瀑布流设置满行"); StaggeredGridLayoutManager.LayoutParams layoutParams = new StaggeredGridLayoutManager.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); layoutParams.setFullSpan(true); holder.getParentView().setLayoutParams(layoutParams); &#125; bindListener4View(holder, viewType); return holder;&#125; QuickAdapter 最后贴一下整个QuickAdapter的源代码，涉及相关具体的类可以去这里查看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317package com.march.quickrvlibs;import android.content.Context;import android.support.v7.widget.GridLayoutManager;import android.support.v7.widget.RecyclerView;import android.support.v7.widget.StaggeredGridLayoutManager;import android.util.Log;import android.util.SparseArray;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import com.march.quickrvlibs.inter.OnRecyclerItemClickListener;import com.march.quickrvlibs.inter.OnRecyclerItemLongClickListener;import com.march.quickrvlibs.inter.RvQuickInterface;import java.util.Collections;import java.util.List;/** * Created by 陈栋 on 15/12/28. * 功能: */public abstract class RvQuickAdapter&lt;D extends RvQuickInterface&gt; extends RecyclerView.Adapter&lt;RvViewHolder&gt; &#123; protected List&lt;D&gt; datas; protected LayoutInflater mLayoutInflater; protected Context context; protected SparseArray&lt;RvAdapterConfig&gt; Res4Type; private OnRecyclerItemClickListener&lt;RvViewHolder&gt; clickListener; private OnRecyclerItemLongClickListener&lt;RvViewHolder&gt; longClickListenter; private View mHeaderView; private View mFooterView; private int TYPE_HEADER = -1; private int TYPE_FOOTER = -2; private int adapterId;//使用此标志来判断当前adapter的类型 private boolean isStaggeredGridLayoutManager = false; public int getAdapterId() &#123; return adapterId; &#125; /** * 设置adapterId标示 * @param adapterId adapter标示 */ public void setAdapterId(int adapterId) &#123; this.adapterId = adapterId; &#125; /** * 使用标记判断,是否是该adaper * @param adapter adapter * @return boolean */ public boolean isThisAdapter(RvQuickAdapter adapter) &#123; if (adapter == null) &#123; return false; &#125; else if (adapter.getAdapterId() == adapterId) &#123; return true; &#125; return false; &#125; /** * 多类型适配,需要调用addType()方法配置参数 * * @param context context * @param datas 数据源 */ public RvQuickAdapter(Context context, List&lt;D&gt; datas) &#123; this.datas = datas; this.mLayoutInflater = LayoutInflater.from(context); this.context = context; &#125; public RvQuickAdapter(Context context, D[] ds) &#123; Collections.addAll(datas, ds); this.mLayoutInflater = LayoutInflater.from(context); this.context = context; &#125; /** * 单类型适配 * * @param context context * @param datas 数据源 * @param res layout资源 */ public RvQuickAdapter(Context context, List&lt;D&gt; datas, int res) &#123; this.datas = datas; this.mLayoutInflater = LayoutInflater.from(context); this.context = context; this.Res4Type = new SparseArray&lt;&gt;(); Res4Type.put(0, new RvAdapterConfig(0, res)); &#125; public RvQuickAdapter(Context context, D[] ds, int res) &#123; Collections.addAll(datas, ds); this.mLayoutInflater = LayoutInflater.from(context); this.context = context; this.Res4Type = new SparseArray&lt;&gt;(); Res4Type.put(0, new RvAdapterConfig(0, res)); &#125; public void setClickListener(OnRecyclerItemClickListener&lt;RvViewHolder&gt; listener) &#123; if (listener != null) &#123; this.clickListener = listener; &#125; &#125; public void setLongClickListener(OnRecyclerItemLongClickListener&lt;RvViewHolder&gt; longClickListenter) &#123; if (longClickListenter != null) &#123; this.longClickListenter = longClickListenter; &#125; &#125; public void addHeader(View mHeaderView) &#123; this.mHeaderView = mHeaderView; &#125; public void addFooter(View mFooterView) &#123; this.mFooterView = mFooterView; &#125; public void addHeader(int mHeaderViewRes) &#123; this.mHeaderView = getInflateView(mHeaderViewRes, null); &#125; public void addFooter(int mFooterViewRes) &#123; this.mFooterView = getInflateView(mFooterViewRes, null); &#125; public View getInflateView(int resId, ViewGroup parent) &#123; return mLayoutInflater.inflate(resId, parent, false); &#125; @Override public RvViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; RvViewHolder holder; if (isHasFooter() &amp;&amp; viewType == TYPE_FOOTER) &#123; holder = new RvFooterHolder(mFooterView); &#125; else if (isHasHeader() &amp;&amp; viewType == TYPE_HEADER) &#123; holder = new RvHeaderHolder(mHeaderView); &#125; else &#123; holder = new RvViewHolder(getInflateView(Res4Type.get(viewType).getResId(), parent)); if (clickListener != null) &#123; holder.setOnItemClickListener(clickListener); &#125; if (longClickListenter != null) &#123; holder.setOnItemLongClickListener(longClickListenter); &#125; &#125; if (isStaggeredGridLayoutManager &amp;&amp; (holder instanceof RvHeaderHolder || holder instanceof RvFooterHolder)) &#123; Log.e("chendong","瀑布流设置满行"); StaggeredGridLayoutManager.LayoutParams layoutParams = new StaggeredGridLayoutManager.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); layoutParams.setFullSpan(true); holder.getParentView().setLayoutParams(layoutParams); &#125; bindListener4View(holder, viewType); return holder; &#125; @Override public void onBindViewHolder(RvViewHolder holder, int position) &#123; if (isHasFooter() &amp;&amp; position == getItemCount() - 1) &#123; bindLisAndData4Footer((RvFooterHolder) holder); &#125; else if (isHasHeader() &amp;&amp; position == 0) &#123; bindLisAndData4Header((RvHeaderHolder) holder); &#125; else &#123; int pos = judgePos(position); bindData4View(holder, datas.get(pos), pos, datas.get(pos).getRvType()); &#125; &#125; @Override public int getItemViewType(int position) &#123; //如果没有header没有footer直接返回 if (!isHasHeader() &amp;&amp; !isHasFooter()) return datas.get(position).getRvType(); //有header且位置0 if (isHasHeader() &amp;&amp; position == 0) return TYPE_HEADER; //pos超出 if (isHasFooter() &amp;&amp; position == getItemCount() - 1) return TYPE_FOOTER; //如果有header,下标减一个 if (isHasHeader()) return datas.get(position - 1).getRvType(); else //没有header 按照原来的 return datas.get(position).getRvType(); &#125; private int judgePos(int pos) &#123; if (isHasHeader()) &#123; return pos - 1; &#125; else &#123; return pos; &#125; &#125; @Override public void onAttachedToRecyclerView(RecyclerView recyclerView) &#123; super.onAttachedToRecyclerView(recyclerView); Log.e("chendong","onAttachedToRecyclerView"); RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager(); if (layoutManager instanceof GridLayoutManager) &#123; final GridLayoutManager gridLayoutManager = (GridLayoutManager) layoutManager; gridLayoutManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() &#123; @Override public int getSpanSize(int position) &#123; return getItemViewType(position) == TYPE_HEADER || getItemViewType(position) == TYPE_FOOTER ? gridLayoutManager.getSpanCount() : 1; &#125; &#125;); return; &#125; if(layoutManager instanceof StaggeredGridLayoutManager)&#123; isStaggeredGridLayoutManager = true; &#125; &#125; /** * 绑定数据 * * @param holder ViewHolder数据持有者 * @param data 数据集 * @param pos 数据集中的位置 * @param type type */ public abstract void bindData4View(RvViewHolder holder, D data, int pos, int type); /** * 绑定监听器 * * @param holder ViewHolder数据持有者 * @param type type */ public void bindListener4View(RvViewHolder holder, int type) &#123; &#125; /** * 绑定header的数据 和 监听 * * @param holder header holder */ public void bindLisAndData4Header(RvHeaderHolder holder) &#123; &#125; /** * 绑定footer的数据和监听 * * @param holder footer holder */ public void bindLisAndData4Footer(RvFooterHolder holder) &#123; &#125; @Override public int getItemCount() &#123; int pos = datas.size(); if (isHasHeader()) pos++; if (isHasFooter()) pos++; return pos; &#125; public int getHeaderCount() &#123; return isHasHeader() ? 1 : 0; &#125; public int getDataPos(int pos) &#123; return pos - getHeaderCount(); &#125; private boolean isHasHeader() &#123; return mHeaderView != null; &#125; private boolean isHasFooter() &#123; return mFooterView != null; &#125; /** * @param type 数据的类型(如果有n种类型,那么type的值需要是0 ~ n-1) * @param resId 该类型对应的资源文件的id * @return QuickTypeAdapter */ public RvQuickAdapter&lt;D&gt; addType(int type, int resId) &#123; if (this.Res4Type == null) this.Res4Type = new SparseArray&lt;&gt;(); this.Res4Type.put(type, new RvAdapterConfig(type, resId)); return this; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Adapter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Adapter</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汉字转换拼音]]></title>
    <url>%2Farticle%2F1637707051%2F</url>
    <content type="text"><![CDATA[进行汉字的字符串拼配,比较,排序的时候使用汉字很不方便,转换成拼音就可以进行首字母匹配搜索等工作了。 Api调用12345PinyinHelper.get().getPinYin("你好"));PinyinHelper.get().getPinYin("你bSfb");PinyinHelper.get().getPinYin("JHHihubbb"); 核心方法123456789101112131415161718192021//核心方法 /** * 唯一公开的方法 * * @param input 输入的文字 * @return 返回的汉字将会转化为大写英文, 如果是英文将会原样返回 */ public String getPinYin(String input) &#123; ArrayList&lt;Token&gt; tokens = get(input); StringBuilder sb = new StringBuilder(); if (tokens != null &amp;&amp; tokens.size() &gt; 0) &#123; for (Token token : tokens) &#123; if (Token.PINYIN == token.type) &#123; sb.append(token.target); &#125; else &#123; sb.append(token.source); &#125; &#125; &#125; return sb.toString(); &#125; 附源码一份123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532package com.march.libs.helper;/** * CdLibsTest com.march.libs.helper * Created by 陈栋 on 16/3/28. * 功能: */import android.text.TextUtils;import android.util.Log;import java.text.Collator;import java.util.ArrayList;import java.util.Locale;public class PinyinHelper &#123; private static final String TAG = "HanziToPinyin"; private static final boolean DEBUG = false; private static final char[] UNIHANS = &#123; '\u963f', '\u54ce', '\u5b89', '\u80ae', '\u51f9', '\u516b', '\u6300', '\u6273', '\u90a6', '\u52f9', '\u9642', '\u5954', '\u4f3b', '\u5c44', '\u8fb9', '\u706c', '\u618b', '\u6c43', '\u51ab', '\u7676', '\u5cec', '\u5693', '\u5072', '\u53c2', '\u4ed3', '\u64a1', '\u518a', '\u5d7e', '\u66fd', '\u66fe', '\u5c64', '\u53c9', '\u8286', '\u8fbf', '\u4f25', '\u6284', '\u8f66', '\u62bb', '\u6c88', '\u6c89', '\u9637', '\u5403', '\u5145', '\u62bd', '\u51fa', '\u6b3b', '\u63e3', '\u5ddb', '\u5205', '\u5439', '\u65fe', '\u9034', '\u5472', '\u5306', '\u51d1', '\u7c97', '\u6c46', '\u5d14', '\u90a8', '\u6413', '\u5491', '\u5446', '\u4e39', '\u5f53', '\u5200', '\u561a', '\u6265', '\u706f', '\u6c10', '\u55f2', '\u7538', '\u5201', '\u7239', '\u4e01', '\u4e1f', '\u4e1c', '\u543a', '\u53be', '\u8011', '\u8968', '\u5428', '\u591a', '\u59b8', '\u8bf6', '\u5940', '\u97a5', '\u513f', '\u53d1', '\u5e06', '\u531a', '\u98de', '\u5206', '\u4e30', '\u8985', '\u4ecf', '\u7d11', '\u4f15', '\u65ee', '\u4f85', '\u7518', '\u5188', '\u768b', '\u6208', '\u7ed9', '\u6839', '\u522f', '\u5de5', '\u52fe', '\u4f30', '\u74dc', '\u4e56', '\u5173', '\u5149', '\u5f52', '\u4e28', '\u5459', '\u54c8', '\u548d', '\u4f44', '\u592f', '\u8320', '\u8bc3', '\u9ed2', '\u62eb', '\u4ea8', '\u5677', '\u53ff', '\u9f41', '\u4e6f', '\u82b1', '\u6000', '\u72bf', '\u5ddf', '\u7070', '\u660f', '\u5419', '\u4e0c', '\u52a0', '\u620b', '\u6c5f', '\u827d', '\u9636', '\u5dfe', '\u5755', '\u5182', '\u4e29', '\u51e5', '\u59e2', '\u5658', '\u519b', '\u5494', '\u5f00', '\u520a', '\u5ffc', '\u5c3b', '\u533c', '\u808e', '\u52a5', '\u7a7a', '\u62a0', '\u625d', '\u5938', '\u84af', '\u5bbd', '\u5321', '\u4e8f', '\u5764', '\u6269', '\u5783', '\u6765', '\u5170', '\u5577', '\u635e', '\u808b', '\u52d2', '\u5d1a', '\u5215', '\u4fe9', '\u5941', '\u826f', '\u64a9', '\u5217', '\u62ce', '\u5222', '\u6e9c', '\u56d6', '\u9f99', '\u779c', '\u565c', '\u5a08', '\u7567', '\u62a1', '\u7f57', '\u5463', '\u5988', '\u57cb', '\u5ada', '\u7264', '\u732b', '\u4e48', '\u5445', '\u95e8', '\u753f', '\u54aa', '\u5b80', '\u55b5', '\u4e5c', '\u6c11', '\u540d', '\u8c2c', '\u6478', '\u54de', '\u6bea', '\u55ef', '\u62cf', '\u8149', '\u56e1', '\u56d4', '\u5b6c', '\u7592', '\u5a1e', '\u6041', '\u80fd', '\u59ae', '\u62c8', '\u5b22', '\u9e1f', '\u634f', '\u56dc', '\u5b81', '\u599e', '\u519c', '\u7fba', '\u5974', '\u597b', '\u759f', '\u9ec1', '\u90cd', '\u5594', '\u8bb4', '\u5991', '\u62cd', '\u7705', '\u4e53', '\u629b', '\u5478', '\u55b7', '\u5309', '\u4e15', '\u56e8', '\u527d', '\u6c15', '\u59d8', '\u4e52', '\u948b', '\u5256', '\u4ec6', '\u4e03', '\u6390', '\u5343', '\u545b', '\u6084', '\u767f', '\u4eb2', '\u72c5', '\u828e', '\u4e18', '\u533a', '\u5cd1', '\u7f3a', '\u590b', '\u5465', '\u7a63', '\u5a06', '\u60f9', '\u4eba', '\u6254', '\u65e5', '\u8338', '\u53b9', '\u909a', '\u633c', '\u5827', '\u5a51', '\u77a4', '\u637c', '\u4ee8', '\u6be2', '\u4e09', '\u6852', '\u63bb', '\u95aa', '\u68ee', '\u50e7', '\u6740', '\u7b5b', '\u5c71', '\u4f24', '\u5f30', '\u5962', '\u7533', '\u8398', '\u6552', '\u5347', '\u5c38', '\u53ce', '\u4e66', '\u5237', '\u8870', '\u95e9', '\u53cc', '\u8c01', '\u542e', '\u8bf4', '\u53b6', '\u5fea', '\u635c', '\u82cf', '\u72fb', '\u590a', '\u5b59', '\u5506', '\u4ed6', '\u56fc', '\u574d', '\u6c64', '\u5932', '\u5fd1', '\u71a5', '\u5254', '\u5929', '\u65eb', '\u5e16', '\u5385', '\u56f2', '\u5077', '\u51f8', '\u6e4d', '\u63a8', '\u541e', '\u4e47', '\u7a75', '\u6b6a', '\u5f2f', '\u5c23', '\u5371', '\u6637', '\u7fc1', '\u631d', '\u4e4c', '\u5915', '\u8672', '\u4eda', '\u4e61', '\u7071', '\u4e9b', '\u5fc3', '\u661f', '\u51f6', '\u4f11', '\u5401', '\u5405', '\u524a', '\u5743', '\u4e2b', '\u6079', '\u592e', '\u5e7a', '\u503b', '\u4e00', '\u56d9', '\u5e94', '\u54df', '\u4f63', '\u4f18', '\u625c', '\u56e6', '\u66f0', '\u6655', '\u7b60', '\u7b7c', '\u5e00', '\u707d', '\u5142', '\u5328', '\u50ae', '\u5219', '\u8d3c', '\u600e', '\u5897', '\u624e', '\u635a', '\u6cbe', '\u5f20', '\u957f', '\u9577', '\u4f4b', '\u8707', '\u8d1e', '\u4e89', '\u4e4b', '\u5cd9', '\u5ea2', '\u4e2d', '\u5dde', '\u6731', '\u6293', '\u62fd', '\u4e13', '\u5986', '\u96b9', '\u5b92', '\u5353', '\u4e72', '\u5b97', '\u90b9', '\u79df', '\u94bb', '\u539c', '\u5c0a', '\u6628', '\u5159', '\u9fc3', '\u9fc4',&#125;; private static final byte[][] PINYINS = &#123; &#123;65, 0, 0, 0, 0, 0&#125;, &#123;65, 73, 0, 0, 0, 0&#125;, &#123;65, 78, 0, 0, 0, 0&#125;, &#123;65, 78, 71, 0, 0, 0&#125;, &#123;65, 79, 0, 0, 0, 0&#125;, &#123;66, 65, 0, 0, 0, 0&#125;, &#123;66, 65, 73, 0, 0, 0&#125;, &#123;66, 65, 78, 0, 0, 0&#125;, &#123;66, 65, 78, 71, 0, 0&#125;, &#123;66, 65, 79, 0, 0, 0&#125;, &#123;66, 69, 73, 0, 0, 0&#125;, &#123;66, 69, 78, 0, 0, 0&#125;, &#123;66, 69, 78, 71, 0, 0&#125;, &#123;66, 73, 0, 0, 0, 0&#125;, &#123;66, 73, 65, 78, 0, 0&#125;, &#123;66, 73, 65, 79, 0, 0&#125;, &#123;66, 73, 69, 0, 0, 0&#125;, &#123;66, 73, 78, 0, 0, 0&#125;, &#123;66, 73, 78, 71, 0, 0&#125;, &#123;66, 79, 0, 0, 0, 0&#125;, &#123;66, 85, 0, 0, 0, 0&#125;, &#123;67, 65, 0, 0, 0, 0&#125;, &#123;67, 65, 73, 0, 0, 0&#125;, &#123;67, 65, 78, 0, 0, 0&#125;, &#123;67, 65, 78, 71, 0, 0&#125;, &#123;67, 65, 79, 0, 0, 0&#125;, &#123;67, 69, 0, 0, 0, 0&#125;, &#123;67, 69, 78, 0, 0, 0&#125;, &#123;67, 69, 78, 71, 0, 0&#125;, &#123;90, 69, 78, 71, 0, 0&#125;, &#123;67, 69, 78, 71, 0, 0&#125;, &#123;67, 72, 65, 0, 0, 0&#125;, &#123;67, 72, 65, 73, 0, 0&#125;, &#123;67, 72, 65, 78, 0, 0&#125;, &#123;67, 72, 65, 78, 71, 0&#125;, &#123;67, 72, 65, 79, 0, 0&#125;, &#123;67, 72, 69, 0, 0, 0&#125;, &#123;67, 72, 69, 78, 0, 0&#125;, &#123;83, 72, 69, 78, 0, 0&#125;, &#123;67, 72, 69, 78, 0, 0&#125;, &#123;67, 72, 69, 78, 71, 0&#125;, &#123;67, 72, 73, 0, 0, 0&#125;, &#123;67, 72, 79, 78, 71, 0&#125;, &#123;67, 72, 79, 85, 0, 0&#125;, &#123;67, 72, 85, 0, 0, 0&#125;, &#123;67, 72, 85, 65, 0, 0&#125;, &#123;67, 72, 85, 65, 73, 0&#125;, &#123;67, 72, 85, 65, 78, 0&#125;, &#123;67, 72, 85, 65, 78, 71&#125;, &#123;67, 72, 85, 73, 0, 0&#125;, &#123;67, 72, 85, 78, 0, 0&#125;, &#123;67, 72, 85, 79, 0, 0&#125;, &#123;67, 73, 0, 0, 0, 0&#125;, &#123;67, 79, 78, 71, 0, 0&#125;, &#123;67, 79, 85, 0, 0, 0&#125;, &#123;67, 85, 0, 0, 0, 0&#125;, &#123;67, 85, 65, 78, 0, 0&#125;, &#123;67, 85, 73, 0, 0, 0&#125;, &#123;67, 85, 78, 0, 0, 0&#125;, &#123;67, 85, 79, 0, 0, 0&#125;, &#123;68, 65, 0, 0, 0, 0&#125;, &#123;68, 65, 73, 0, 0, 0&#125;, &#123;68, 65, 78, 0, 0, 0&#125;, &#123;68, 65, 78, 71, 0, 0&#125;, &#123;68, 65, 79, 0, 0, 0&#125;, &#123;68, 69, 0, 0, 0, 0&#125;, &#123;68, 69, 78, 0, 0, 0&#125;, &#123;68, 69, 78, 71, 0, 0&#125;, &#123;68, 73, 0, 0, 0, 0&#125;, &#123;68, 73, 65, 0, 0, 0&#125;, &#123;68, 73, 65, 78, 0, 0&#125;, &#123;68, 73, 65, 79, 0, 0&#125;, &#123;68, 73, 69, 0, 0, 0&#125;, &#123;68, 73, 78, 71, 0, 0&#125;, &#123;68, 73, 85, 0, 0, 0&#125;, &#123;68, 79, 78, 71, 0, 0&#125;, &#123;68, 79, 85, 0, 0, 0&#125;, &#123;68, 85, 0, 0, 0, 0&#125;, &#123;68, 85, 65, 78, 0, 0&#125;, &#123;68, 85, 73, 0, 0, 0&#125;, &#123;68, 85, 78, 0, 0, 0&#125;, &#123;68, 85, 79, 0, 0, 0&#125;, &#123;69, 0, 0, 0, 0, 0&#125;, &#123;69, 73, 0, 0, 0, 0&#125;, &#123;69, 78, 0, 0, 0, 0&#125;, &#123;69, 78, 71, 0, 0, 0&#125;, &#123;69, 82, 0, 0, 0, 0&#125;, &#123;70, 65, 0, 0, 0, 0&#125;, &#123;70, 65, 78, 0, 0, 0&#125;, &#123;70, 65, 78, 71, 0, 0&#125;, &#123;70, 69, 73, 0, 0, 0&#125;, &#123;70, 69, 78, 0, 0, 0&#125;, &#123;70, 69, 78, 71, 0, 0&#125;, &#123;70, 73, 65, 79, 0, 0&#125;, &#123;70, 79, 0, 0, 0, 0&#125;, &#123;70, 79, 85, 0, 0, 0&#125;, &#123;70, 85, 0, 0, 0, 0&#125;, &#123;71, 65, 0, 0, 0, 0&#125;, &#123;71, 65, 73, 0, 0, 0&#125;, &#123;71, 65, 78, 0, 0, 0&#125;, &#123;71, 65, 78, 71, 0, 0&#125;, &#123;71, 65, 79, 0, 0, 0&#125;, &#123;71, 69, 0, 0, 0, 0&#125;, &#123;71, 69, 73, 0, 0, 0&#125;, &#123;71, 69, 78, 0, 0, 0&#125;, &#123;71, 69, 78, 71, 0, 0&#125;, &#123;71, 79, 78, 71, 0, 0&#125;, &#123;71, 79, 85, 0, 0, 0&#125;, &#123;71, 85, 0, 0, 0, 0&#125;, &#123;71, 85, 65, 0, 0, 0&#125;, &#123;71, 85, 65, 73, 0, 0&#125;, &#123;71, 85, 65, 78, 0, 0&#125;, &#123;71, 85, 65, 78, 71, 0&#125;, &#123;71, 85, 73, 0, 0, 0&#125;, &#123;71, 85, 78, 0, 0, 0&#125;, &#123;71, 85, 79, 0, 0, 0&#125;, &#123;72, 65, 0, 0, 0, 0&#125;, &#123;72, 65, 73, 0, 0, 0&#125;, &#123;72, 65, 78, 0, 0, 0&#125;, &#123;72, 65, 78, 71, 0, 0&#125;, &#123;72, 65, 79, 0, 0, 0&#125;, &#123;72, 69, 0, 0, 0, 0&#125;, &#123;72, 69, 73, 0, 0, 0&#125;, &#123;72, 69, 78, 0, 0, 0&#125;, &#123;72, 69, 78, 71, 0, 0&#125;, &#123;72, 77, 0, 0, 0, 0&#125;, &#123;72, 79, 78, 71, 0, 0&#125;, &#123;72, 79, 85, 0, 0, 0&#125;, &#123;72, 85, 0, 0, 0, 0&#125;, &#123;72, 85, 65, 0, 0, 0&#125;, &#123;72, 85, 65, 73, 0, 0&#125;, &#123;72, 85, 65, 78, 0, 0&#125;, &#123;72, 85, 65, 78, 71, 0&#125;, &#123;72, 85, 73, 0, 0, 0&#125;, &#123;72, 85, 78, 0, 0, 0&#125;, &#123;72, 85, 79, 0, 0, 0&#125;, &#123;74, 73, 0, 0, 0, 0&#125;, &#123;74, 73, 65, 0, 0, 0&#125;, &#123;74, 73, 65, 78, 0, 0&#125;, &#123;74, 73, 65, 78, 71, 0&#125;, &#123;74, 73, 65, 79, 0, 0&#125;, &#123;74, 73, 69, 0, 0, 0&#125;, &#123;74, 73, 78, 0, 0, 0&#125;, &#123;74, 73, 78, 71, 0, 0&#125;, &#123;74, 73, 79, 78, 71, 0&#125;, &#123;74, 73, 85, 0, 0, 0&#125;, &#123;74, 85, 0, 0, 0, 0&#125;, &#123;74, 85, 65, 78, 0, 0&#125;, &#123;74, 85, 69, 0, 0, 0&#125;, &#123;74, 85, 78, 0, 0, 0&#125;, &#123;75, 65, 0, 0, 0, 0&#125;, &#123;75, 65, 73, 0, 0, 0&#125;, &#123;75, 65, 78, 0, 0, 0&#125;, &#123;75, 65, 78, 71, 0, 0&#125;, &#123;75, 65, 79, 0, 0, 0&#125;, &#123;75, 69, 0, 0, 0, 0&#125;, &#123;75, 69, 78, 0, 0, 0&#125;, &#123;75, 69, 78, 71, 0, 0&#125;, &#123;75, 79, 78, 71, 0, 0&#125;, &#123;75, 79, 85, 0, 0, 0&#125;, &#123;75, 85, 0, 0, 0, 0&#125;, &#123;75, 85, 65, 0, 0, 0&#125;, &#123;75, 85, 65, 73, 0, 0&#125;, &#123;75, 85, 65, 78, 0, 0&#125;, &#123;75, 85, 65, 78, 71, 0&#125;, &#123;75, 85, 73, 0, 0, 0&#125;, &#123;75, 85, 78, 0, 0, 0&#125;, &#123;75, 85, 79, 0, 0, 0&#125;, &#123;76, 65, 0, 0, 0, 0&#125;, &#123;76, 65, 73, 0, 0, 0&#125;, &#123;76, 65, 78, 0, 0, 0&#125;, &#123;76, 65, 78, 71, 0, 0&#125;, &#123;76, 65, 79, 0, 0, 0&#125;, &#123;76, 69, 0, 0, 0, 0&#125;, &#123;76, 69, 73, 0, 0, 0&#125;, &#123;76, 69, 78, 71, 0, 0&#125;, &#123;76, 73, 0, 0, 0, 0&#125;, &#123;76, 73, 65, 0, 0, 0&#125;, &#123;76, 73, 65, 78, 0, 0&#125;, &#123;76, 73, 65, 78, 71, 0&#125;, &#123;76, 73, 65, 79, 0, 0&#125;, &#123;76, 73, 69, 0, 0, 0&#125;, &#123;76, 73, 78, 0, 0, 0&#125;, &#123;76, 73, 78, 71, 0, 0&#125;, &#123;76, 73, 85, 0, 0, 0&#125;, &#123;76, 79, 0, 0, 0, 0&#125;, &#123;76, 79, 78, 71, 0, 0&#125;, &#123;76, 79, 85, 0, 0, 0&#125;, &#123;76, 85, 0, 0, 0, 0&#125;, &#123;76, 85, 65, 78, 0, 0&#125;, &#123;76, 85, 69, 0, 0, 0&#125;, &#123;76, 85, 78, 0, 0, 0&#125;, &#123;76, 85, 79, 0, 0, 0&#125;, &#123;77, 0, 0, 0, 0, 0&#125;, &#123;77, 65, 0, 0, 0, 0&#125;, &#123;77, 65, 73, 0, 0, 0&#125;, &#123;77, 65, 78, 0, 0, 0&#125;, &#123;77, 65, 78, 71, 0, 0&#125;, &#123;77, 65, 79, 0, 0, 0&#125;, &#123;77, 69, 0, 0, 0, 0&#125;, &#123;77, 69, 73, 0, 0, 0&#125;, &#123;77, 69, 78, 0, 0, 0&#125;, &#123;77, 69, 78, 71, 0, 0&#125;, &#123;77, 73, 0, 0, 0, 0&#125;, &#123;77, 73, 65, 78, 0, 0&#125;, &#123;77, 73, 65, 79, 0, 0&#125;, &#123;77, 73, 69, 0, 0, 0&#125;, &#123;77, 73, 78, 0, 0, 0&#125;, &#123;77, 73, 78, 71, 0, 0&#125;, &#123;77, 73, 85, 0, 0, 0&#125;, &#123;77, 79, 0, 0, 0, 0&#125;, &#123;77, 79, 85, 0, 0, 0&#125;, &#123;77, 85, 0, 0, 0, 0&#125;, &#123;78, 0, 0, 0, 0, 0&#125;, &#123;78, 65, 0, 0, 0, 0&#125;, &#123;78, 65, 73, 0, 0, 0&#125;, &#123;78, 65, 78, 0, 0, 0&#125;, &#123;78, 65, 78, 71, 0, 0&#125;, &#123;78, 65, 79, 0, 0, 0&#125;, &#123;78, 69, 0, 0, 0, 0&#125;, &#123;78, 69, 73, 0, 0, 0&#125;, &#123;78, 69, 78, 0, 0, 0&#125;, &#123;78, 69, 78, 71, 0, 0&#125;, &#123;78, 73, 0, 0, 0, 0&#125;, &#123;78, 73, 65, 78, 0, 0&#125;, &#123;78, 73, 65, 78, 71, 0&#125;, &#123;78, 73, 65, 79, 0, 0&#125;, &#123;78, 73, 69, 0, 0, 0&#125;, &#123;78, 73, 78, 0, 0, 0&#125;, &#123;78, 73, 78, 71, 0, 0&#125;, &#123;78, 73, 85, 0, 0, 0&#125;, &#123;78, 79, 78, 71, 0, 0&#125;, &#123;78, 79, 85, 0, 0, 0&#125;, &#123;78, 85, 0, 0, 0, 0&#125;, &#123;78, 85, 65, 78, 0, 0&#125;, &#123;78, 85, 69, 0, 0, 0&#125;, &#123;78, 85, 78, 0, 0, 0&#125;, &#123;78, 85, 79, 0, 0, 0&#125;, &#123;79, 0, 0, 0, 0, 0&#125;, &#123;79, 85, 0, 0, 0, 0&#125;, &#123;80, 65, 0, 0, 0, 0&#125;, &#123;80, 65, 73, 0, 0, 0&#125;, &#123;80, 65, 78, 0, 0, 0&#125;, &#123;80, 65, 78, 71, 0, 0&#125;, &#123;80, 65, 79, 0, 0, 0&#125;, &#123;80, 69, 73, 0, 0, 0&#125;, &#123;80, 69, 78, 0, 0, 0&#125;, &#123;80, 69, 78, 71, 0, 0&#125;, &#123;80, 73, 0, 0, 0, 0&#125;, &#123;80, 73, 65, 78, 0, 0&#125;, &#123;80, 73, 65, 79, 0, 0&#125;, &#123;80, 73, 69, 0, 0, 0&#125;, &#123;80, 73, 78, 0, 0, 0&#125;, &#123;80, 73, 78, 71, 0, 0&#125;, &#123;80, 79, 0, 0, 0, 0&#125;, &#123;80, 79, 85, 0, 0, 0&#125;, &#123;80, 85, 0, 0, 0, 0&#125;, &#123;81, 73, 0, 0, 0, 0&#125;, &#123;81, 73, 65, 0, 0, 0&#125;, &#123;81, 73, 65, 78, 0, 0&#125;, &#123;81, 73, 65, 78, 71, 0&#125;, &#123;81, 73, 65, 79, 0, 0&#125;, &#123;81, 73, 69, 0, 0, 0&#125;, &#123;81, 73, 78, 0, 0, 0&#125;, &#123;81, 73, 78, 71, 0, 0&#125;, &#123;81, 73, 79, 78, 71, 0&#125;, &#123;81, 73, 85, 0, 0, 0&#125;, &#123;81, 85, 0, 0, 0, 0&#125;, &#123;81, 85, 65, 78, 0, 0&#125;, &#123;81, 85, 69, 0, 0, 0&#125;, &#123;81, 85, 78, 0, 0, 0&#125;, &#123;82, 65, 78, 0, 0, 0&#125;, &#123;82, 65, 78, 71, 0, 0&#125;, &#123;82, 65, 79, 0, 0, 0&#125;, &#123;82, 69, 0, 0, 0, 0&#125;, &#123;82, 69, 78, 0, 0, 0&#125;, &#123;82, 69, 78, 71, 0, 0&#125;, &#123;82, 73, 0, 0, 0, 0&#125;, &#123;82, 79, 78, 71, 0, 0&#125;, &#123;82, 79, 85, 0, 0, 0&#125;, &#123;82, 85, 0, 0, 0, 0&#125;, &#123;82, 85, 65, 0, 0, 0&#125;, &#123;82, 85, 65, 78, 0, 0&#125;, &#123;82, 85, 73, 0, 0, 0&#125;, &#123;82, 85, 78, 0, 0, 0&#125;, &#123;82, 85, 79, 0, 0, 0&#125;, &#123;83, 65, 0, 0, 0, 0&#125;, &#123;83, 65, 73, 0, 0, 0&#125;, &#123;83, 65, 78, 0, 0, 0&#125;, &#123;83, 65, 78, 71, 0, 0&#125;, &#123;83, 65, 79, 0, 0, 0&#125;, &#123;83, 69, 0, 0, 0, 0&#125;, &#123;83, 69, 78, 0, 0, 0&#125;, &#123;83, 69, 78, 71, 0, 0&#125;, &#123;83, 72, 65, 0, 0, 0&#125;, &#123;83, 72, 65, 73, 0, 0&#125;, &#123;83, 72, 65, 78, 0, 0&#125;, &#123;83, 72, 65, 78, 71, 0&#125;, &#123;83, 72, 65, 79, 0, 0&#125;, &#123;83, 72, 69, 0, 0, 0&#125;, &#123;83, 72, 69, 78, 0, 0&#125;, &#123;88, 73, 78, 0, 0, 0&#125;, &#123;83, 72, 69, 78, 0, 0&#125;, &#123;83, 72, 69, 78, 71, 0&#125;, &#123;83, 72, 73, 0, 0, 0&#125;, &#123;83, 72, 79, 85, 0, 0&#125;, &#123;83, 72, 85, 0, 0, 0&#125;, &#123;83, 72, 85, 65, 0, 0&#125;, &#123;83, 72, 85, 65, 73, 0&#125;, &#123;83, 72, 85, 65, 78, 0&#125;, &#123;83, 72, 85, 65, 78, 71&#125;, &#123;83, 72, 85, 73, 0, 0&#125;, &#123;83, 72, 85, 78, 0, 0&#125;, &#123;83, 72, 85, 79, 0, 0&#125;, &#123;83, 73, 0, 0, 0, 0&#125;, &#123;83, 79, 78, 71, 0, 0&#125;, &#123;83, 79, 85, 0, 0, 0&#125;, &#123;83, 85, 0, 0, 0, 0&#125;, &#123;83, 85, 65, 78, 0, 0&#125;, &#123;83, 85, 73, 0, 0, 0&#125;, &#123;83, 85, 78, 0, 0, 0&#125;, &#123;83, 85, 79, 0, 0, 0&#125;, &#123;84, 65, 0, 0, 0, 0&#125;, &#123;84, 65, 73, 0, 0, 0&#125;, &#123;84, 65, 78, 0, 0, 0&#125;, &#123;84, 65, 78, 71, 0, 0&#125;, &#123;84, 65, 79, 0, 0, 0&#125;, &#123;84, 69, 0, 0, 0, 0&#125;, &#123;84, 69, 78, 71, 0, 0&#125;, &#123;84, 73, 0, 0, 0, 0&#125;, &#123;84, 73, 65, 78, 0, 0&#125;, &#123;84, 73, 65, 79, 0, 0&#125;, &#123;84, 73, 69, 0, 0, 0&#125;, &#123;84, 73, 78, 71, 0, 0&#125;, &#123;84, 79, 78, 71, 0, 0&#125;, &#123;84, 79, 85, 0, 0, 0&#125;, &#123;84, 85, 0, 0, 0, 0&#125;, &#123;84, 85, 65, 78, 0, 0&#125;, &#123;84, 85, 73, 0, 0, 0&#125;, &#123;84, 85, 78, 0, 0, 0&#125;, &#123;84, 85, 79, 0, 0, 0&#125;, &#123;87, 65, 0, 0, 0, 0&#125;, &#123;87, 65, 73, 0, 0, 0&#125;, &#123;87, 65, 78, 0, 0, 0&#125;, &#123;87, 65, 78, 71, 0, 0&#125;, &#123;87, 69, 73, 0, 0, 0&#125;, &#123;87, 69, 78, 0, 0, 0&#125;, &#123;87, 69, 78, 71, 0, 0&#125;, &#123;87, 79, 0, 0, 0, 0&#125;, &#123;87, 85, 0, 0, 0, 0&#125;, &#123;88, 73, 0, 0, 0, 0&#125;, &#123;88, 73, 65, 0, 0, 0&#125;, &#123;88, 73, 65, 78, 0, 0&#125;, &#123;88, 73, 65, 78, 71, 0&#125;, &#123;88, 73, 65, 79, 0, 0&#125;, &#123;88, 73, 69, 0, 0, 0&#125;, &#123;88, 73, 78, 0, 0, 0&#125;, &#123;88, 73, 78, 71, 0, 0&#125;, &#123;88, 73, 79, 78, 71, 0&#125;, &#123;88, 73, 85, 0, 0, 0&#125;, &#123;88, 85, 0, 0, 0, 0&#125;, &#123;88, 85, 65, 78, 0, 0&#125;, &#123;88, 85, 69, 0, 0, 0&#125;, &#123;88, 85, 78, 0, 0, 0&#125;, &#123;89, 65, 0, 0, 0, 0&#125;, &#123;89, 65, 78, 0, 0, 0&#125;, &#123;89, 65, 78, 71, 0, 0&#125;, &#123;89, 65, 79, 0, 0, 0&#125;, &#123;89, 69, 0, 0, 0, 0&#125;, &#123;89, 73, 0, 0, 0, 0&#125;, &#123;89, 73, 78, 0, 0, 0&#125;, &#123;89, 73, 78, 71, 0, 0&#125;, &#123;89, 79, 0, 0, 0, 0&#125;, &#123;89, 79, 78, 71, 0, 0&#125;, &#123;89, 79, 85, 0, 0, 0&#125;, &#123;89, 85, 0, 0, 0, 0&#125;, &#123;89, 85, 65, 78, 0, 0&#125;, &#123;89, 85, 69, 0, 0, 0&#125;, &#123;89, 85, 78, 0, 0, 0&#125;, &#123;74, 85, 78, 0, 0, 0&#125;, &#123;89, 85, 78, 0, 0, 0&#125;, &#123;90, 65, 0, 0, 0, 0&#125;, &#123;90, 65, 73, 0, 0, 0&#125;, &#123;90, 65, 78, 0, 0, 0&#125;, &#123;90, 65, 78, 71, 0, 0&#125;, &#123;90, 65, 79, 0, 0, 0&#125;, &#123;90, 69, 0, 0, 0, 0&#125;, &#123;90, 69, 73, 0, 0, 0&#125;, &#123;90, 69, 78, 0, 0, 0&#125;, &#123;90, 69, 78, 71, 0, 0&#125;, &#123;90, 72, 65, 0, 0, 0&#125;, &#123;90, 72, 65, 73, 0, 0&#125;, &#123;90, 72, 65, 78, 0, 0&#125;, &#123;90, 72, 65, 78, 71, 0&#125;, &#123;67, 72, 65, 78, 71, 0&#125;, &#123;90, 72, 65, 78, 71, 0&#125;, &#123;90, 72, 65, 79, 0, 0&#125;, &#123;90, 72, 69, 0, 0, 0&#125;, &#123;90, 72, 69, 78, 0, 0&#125;, &#123;90, 72, 69, 78, 71, 0&#125;, &#123;90, 72, 73, 0, 0, 0&#125;, &#123;83, 72, 73, 0, 0, 0&#125;, &#123;90, 72, 73, 0, 0, 0&#125;, &#123;90, 72, 79, 78, 71, 0&#125;, &#123;90, 72, 79, 85, 0, 0&#125;, &#123;90, 72, 85, 0, 0, 0&#125;, &#123;90, 72, 85, 65, 0, 0&#125;, &#123;90, 72, 85, 65, 73, 0&#125;, &#123;90, 72, 85, 65, 78, 0&#125;, &#123;90, 72, 85, 65, 78, 71&#125;, &#123;90, 72, 85, 73, 0, 0&#125;, &#123;90, 72, 85, 78, 0, 0&#125;, &#123;90, 72, 85, 79, 0, 0&#125;, &#123;90, 73, 0, 0, 0, 0&#125;, &#123;90, 79, 78, 71, 0, 0&#125;, &#123;90, 79, 85, 0, 0, 0&#125;, &#123;90, 85, 0, 0, 0, 0&#125;, &#123;90, 85, 65, 78, 0, 0&#125;, &#123;90, 85, 73, 0, 0, 0&#125;, &#123;90, 85, 78, 0, 0, 0&#125;, &#123;90, 85, 79, 0, 0, 0&#125;, &#123;0, 0, 0, 0, 0, 0&#125;, &#123;83, 72, 65, 78, 0, 0&#125;, &#123;0, 0, 0, 0, 0, 0&#125;,&#125;; /** * First and last Chinese character with known Pinyin according to zh collation */ private static final String FIRST_PINYIN_UNIHAN = "\u963F"; private static final String LAST_PINYIN_UNIHAN = "\u9FFF"; private static final Collator COLLATOR = Collator.getInstance(Locale.CHINA); private static PinyinHelper sInstance; private final boolean mHasChinaCollator; public static class Token &#123; /** * Separator between target string for each source char */ public static final String SEPARATOR = " "; public static final int LATIN = 1; public static final int PINYIN = 2; public static final int UNKNOWN = 3; public Token() &#123; &#125; public Token(int type, String source, String target) &#123; this.type = type; this.source = source; this.target = target; &#125; /** * Type of this token, ASCII, PINYIN or UNKNOWN. */ public int type; /** * Original string before translation. */ public String source; /** * Translated string of source. For Han, target is corresponding Pinyin. Otherwise target is * original string in source. */ public String target; &#125; protected PinyinHelper(boolean hasChinaCollator) &#123; mHasChinaCollator = hasChinaCollator; &#125; public static PinyinHelper get() &#123; synchronized (PinyinHelper.class) &#123; if (sInstance != null) &#123; return sInstance; &#125; final Locale locale[] = Collator.getAvailableLocales(); for (int i = 0; i &lt; locale.length; i++) &#123; if (locale[i].equals(Locale.CHINA)) &#123; // Do self validation just once. if (DEBUG) &#123; Log.d(TAG, "Self validation. Result: " + doSelfValidation()); &#125; sInstance = new PinyinHelper(true); return sInstance; &#125; &#125; sInstance = new PinyinHelper(true); return sInstance; &#125; &#125; private static boolean doSelfValidation() &#123; char lastChar = UNIHANS[0]; String lastString = Character.toString(lastChar); for (char c : UNIHANS) &#123; if (lastChar == c) &#123; continue; &#125; final String curString = Character.toString(c); int cmp = COLLATOR.compare(lastString, curString); if (cmp &gt;= 0) &#123; return false; &#125; lastString = curString; &#125; return true; &#125; private Token getToken(char character) &#123; Token token = new Token(); final String letter = Character.toString(character); token.source = letter; int offset = -1; int cmp; if (character &lt; 256) &#123; token.type = Token.LATIN; token.target = letter; return token; &#125; else &#123; cmp = COLLATOR.compare(letter, FIRST_PINYIN_UNIHAN); if (cmp &lt; 0) &#123; token.type = Token.UNKNOWN; token.target = letter; return token; &#125; else if (cmp == 0) &#123; token.type = Token.PINYIN; offset = 0; &#125; else &#123; cmp = COLLATOR.compare(letter, LAST_PINYIN_UNIHAN); if (cmp &gt; 0) &#123; token.type = Token.UNKNOWN; token.target = letter; return token; &#125; else if (cmp == 0) &#123; token.type = Token.PINYIN; offset = UNIHANS.length - 1; &#125; &#125; &#125; token.type = Token.PINYIN; if (offset &lt; 0) &#123; int begin = 0; int end = UNIHANS.length - 1; while (begin &lt;= end) &#123; offset = (begin + end) / 2; final String unihan = Character.toString(UNIHANS[offset]); cmp = COLLATOR.compare(letter, unihan); if (cmp == 0) &#123; break; &#125; else if (cmp &gt; 0) &#123; begin = offset + 1; &#125; else &#123; end = offset - 1; &#125; &#125; &#125; if (cmp &lt; 0) &#123; offset--; &#125; StringBuilder pinyin = new StringBuilder(); for (int j = 0; j &lt; PINYINS[offset].length &amp;&amp; PINYINS[offset][j] != 0; j++) &#123; pinyin.append((char) PINYINS[offset][j]); &#125; token.target = pinyin.toString(); if (TextUtils.isEmpty(token.target)) &#123; token.type = Token.UNKNOWN; token.target = token.source; &#125; return token; &#125; private ArrayList&lt;Token&gt; get(final String input) &#123; ArrayList&lt;Token&gt; tokens = new ArrayList&lt;Token&gt;(); if (!mHasChinaCollator || TextUtils.isEmpty(input)) &#123; // return empty tokens. return tokens; &#125; final int inputLength = input.length(); final StringBuilder sb = new StringBuilder(); int tokenType = Token.LATIN; for (int i = 0; i &lt; inputLength; i++) &#123; final char character = input.charAt(i); if (character == ' ') &#123; if (sb.length() &gt; 0) &#123; addToken(sb, tokens, tokenType); &#125; &#125; else if (character &lt; 256) &#123; if (tokenType != Token.LATIN &amp;&amp; sb.length() &gt; 0) &#123; addToken(sb, tokens, tokenType); &#125; tokenType = Token.LATIN; sb.append(character); &#125; else &#123; Token t = getToken(character); if (t.type == Token.PINYIN) &#123; if (sb.length() &gt; 0) &#123; addToken(sb, tokens, tokenType); &#125; tokens.add(t); tokenType = Token.PINYIN; &#125; else &#123; if (tokenType != t.type &amp;&amp; sb.length() &gt; 0) &#123; addToken(sb, tokens, tokenType); &#125; tokenType = t.type; sb.append(character); &#125; &#125; &#125; if (sb.length() &gt; 0) &#123; addToken(sb, tokens, tokenType); &#125; return tokens; &#125; private void addToken( final StringBuilder sb, final ArrayList&lt;Token&gt; tokens, final int tokenType) &#123; String str = sb.toString(); tokens.add(new Token(tokenType, str, str)); sb.setLength(0); &#125; /** * 唯一公开的方法 * * @param input 输入的文字 * @return 返回的汉字将会转化为大写英文, 如果是英文将会原样返回 */ public String getPinYin(String input) &#123; ArrayList&lt;Token&gt; tokens = get(input); StringBuilder sb = new StringBuilder(); if (tokens != null &amp;&amp; tokens.size() &gt; 0) &#123; for (Token token : tokens) &#123; if (Token.PINYIN == token.type) &#123; sb.append(token.target); &#125; else &#123; sb.append(token.source); &#125; &#125; &#125; return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>Study</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android系统分享的注册和调起]]></title>
    <url>%2Farticle%2F3733894393%2F</url>
    <content type="text"><![CDATA[系统相册照片长按时会弹出分享发送选项，可以选择分享到QQ，微信等，本文主要介绍： 如何将自己的应用注册到系统分享中，使用户可以将照片视频文件等发送到自己的应用中。 如何接受解析系统分享发送过来的数据。 如何唤醒系统分享，分享照片视频文件到别的应用。 注册系统的分享需要在 AndroidManifest.xml 文件声明 &lt;intent-filter&gt;，使得你可以在用户点击分享/发送按钮时调起你的应用，将图片和文字等分享到你的App。 关于 mimeType 的相关类型，请查看 MimeUtils.java 文件。 12345678910111213141516171819&lt;activity android:name=".activity.HandleShareActivity"&gt; &lt;intent-filter&gt; &lt;!--接受单个文件分享--&gt; &lt;action android:name="android.intent.action.SEND"/&gt; &lt;!--接受多个文件分享--&gt; &lt;action android:name="android.intent.action.SEND_MULTIPLE"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;!--接受图片类文件分享 image/jpeg" "image/bmp" "image/gif" "image/jpg" "image/png"--&gt; &lt;data android:mimeType="image/*"/&gt; &lt;!--接受文本分享 text/plain--&gt; &lt;data android:mimeType="text/*"/&gt; &lt;!--接受视频分享 video/wav video/mp4--&gt; &lt;data android:mimeType="video/*"/&gt; &lt;!--接受声音文件分享--&gt; &lt;data android:mimeType="audio/*"/&gt; &lt;!--接受压缩文件和其他各种文件分享--&gt; &lt;data android:mimeType="application/*"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 接受分享的数据当直接长按选中某些文本分享时拿到的数据有些不一样，是存储在 Intent.EXTRA_TEXT 中的，因此单独处理一下。 12345678910111213141516171819/** * 处理分享页面发来的intent */public static void handleIntent(Activity context) &#123; Intent intent = context.getIntent(); String type = intent.getType(); if (type == null) return; // 当文件格式无法识别或选择了多种类型的文件时，type会变成 */* LogUtils.e("type " + type); //type可能为的类型是 image/* | video/* | audio/* | text/* | application/* | */* if (type.startsWith("text") &amp;&amp; intent.getStringExtra(Intent.EXTRA_TEXT) != null) &#123; // 当直接选中文本分享时，会存放在EXTRA_TEXT里面，选择文本文件时，仍然存放在EXTRA_STREAM里面 LogUtils.e("获取到分享的文本 " + intent.getStringExtra(Intent.EXTRA_TEXT)); &#125; else &#123; List&lt;String&gt; sharePaths = getSharePaths(context, intent); LogUtils.e("获取到分享的文件的路径 " + sharePaths.toString()); &#125;&#125; 区分多个文件和单个文件分享，获取分享过来的路径列表 123456789101112131415161718192021222324252627282930/** * 获取分享过来的路径 * * @param context 上下文 * @param intent intent * @return 路径列表 */private static List&lt;String&gt; getSharePaths(Context context, Intent intent) &#123; String action = intent.getAction(); List&lt;String&gt; paths = new ArrayList&lt;&gt;(); // 单个文件 if (Intent.ACTION_SEND.equals(action)) &#123; Uri imageUri = intent.getParcelableExtra(Intent.EXTRA_STREAM); if (imageUri != null) &#123; String realPathFromURI = getRealPathFromURI(context, imageUri); if (realPathFromURI != null) paths.add(realPathFromURI); &#125; &#125; // 多个文件 else if (Intent.ACTION_SEND_MULTIPLE.equals(action)) &#123; ArrayList&lt;Uri&gt; imageUris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM); if (imageUris != null) &#123; for (Uri uri : imageUris) &#123; paths.add(getRealPathFromURI(context, uri)); &#125; &#125; &#125; return paths;&#125; 如何从 uri 中获取存储路径，将 uri 进行转换。 123456789101112131415161718192021222324252627/** * 从uri获取path * * @param uri uri * @return path */private static String getRealPathFromURI(Context context, Uri uri) &#123; final String scheme = uri.getScheme(); String data = null; if (ContentResolver.SCHEME_FILE.equals(scheme)) &#123; data = uri.getPath(); &#125; else if (ContentResolver.SCHEME_CONTENT.equals(scheme)) &#123; Cursor cursor = context.getContentResolver() .query(uri, new String[]&#123;MediaStore.Images.ImageColumns.DATA&#125; , null, null, null); if (null != cursor) &#123; if (cursor.moveToFirst()) &#123; int index = cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA) if (index &gt; -1) &#123; data = cursor.getString(index); &#125; &#125; cursor.close(); &#125; &#125; return data;&#125; 唤醒系统分享12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 分享文字 * * @param context 上下文 * @param title 文字标题 * @param content 文字内容 */public static void shareText(Context context, String title, String content) &#123; Intent shareIntent = new Intent(); shareIntent.setAction(Intent.ACTION_SEND); shareIntent.putExtra(Intent.EXTRA_TEXT, content); shareIntent.putExtra(Intent.EXTRA_TITLE, title); shareIntent.setType("text/plain"); //设置分享列表的标题，并且每次都显示分享列表 context.startActivity(Intent.createChooser(shareIntent, "分享到"));&#125;/** * 分享单张图片 * * @param context 上下文 * @param path 图片的路径 */public static void shareImage(Context context, String path) &#123; //由文件得到uri Uri imageUri = Uri.fromFile(new File(path)); Intent shareIntent = new Intent(); shareIntent.setAction(Intent.ACTION_SEND); shareIntent.putExtra(Intent.EXTRA_STREAM, imageUri); shareIntent.setType("image/*"); context.startActivity(Intent.createChooser(shareIntent, "分享到"));&#125;/** * 分享多张图片 * * @param context 上下文 * @param paths 路径的集合 */public static void shareImages(Context context, List&lt;String&gt; paths) &#123; ArrayList&lt;Uri&gt; uriList = new ArrayList&lt;&gt;(); for (String path : paths) &#123; uriList.add(Uri.fromFile(new File(path))); &#125; Intent shareIntent = new Intent(); shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE); shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, uriList); shareIntent.setType("image/*"); context.startActivity(Intent.createChooser(shareIntent, "分享到"));&#125; 附源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/** * CreateAt : 16/8/13 * Describe : 唤醒系统分享 * * @author chendong */public class ShareUtils &#123; /** * 分享文字 * * @param context 上下文 * @param title 文字标题 * @param content 文字内容 */ public static void shareText(Context context, String title, String content) &#123; Intent shareIntent = new Intent(); shareIntent.setAction(Intent.ACTION_SEND); shareIntent.putExtra(Intent.EXTRA_TEXT, content); shareIntent.putExtra(Intent.EXTRA_TITLE, title); shareIntent.setType("text/plain"); //设置分享列表的标题，并且每次都显示分享列表 context.startActivity(Intent.createChooser(shareIntent, "分享到")); &#125; /** * 分享单张图片 * * @param context 上下文 * @param path 图片的路径 */ public static void shareImage(Context context, String path) &#123; //由文件得到uri Uri imageUri = Uri.fromFile(new File(path)); Intent shareIntent = new Intent(); shareIntent.setAction(Intent.ACTION_SEND); shareIntent.putExtra(Intent.EXTRA_STREAM, imageUri); shareIntent.setType("image/*"); context.startActivity(Intent.createChooser(shareIntent, "分享到")); &#125; /** * 分享多张图片 * * @param context 上下文 * @param paths 路径的集合 */ public static void shareImages(Context context, List&lt;String&gt; paths) &#123; ArrayList&lt;Uri&gt; uriList = new ArrayList&lt;&gt;(); for (String path : paths) &#123; uriList.add(Uri.fromFile(new File(path))); &#125; Intent shareIntent = new Intent(); shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE); shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, uriList); shareIntent.setType("image/*"); context.startActivity(Intent.createChooser(shareIntent, "分享到")); &#125; /** * 处理分享页面发来的intent */ public static void handleIntent(Activity context) &#123; Intent intent = context.getIntent(); String type = intent.getType(); if (type == null) return; // 当文件格式无法识别或选择了多种类型的文件时，type会变成 */* LogUtils.e("type " + type); //type可能为的类型是 image/* | video/* | audio/* | text/* | application/* if (type.startsWith("text") &amp;&amp; intent.getStringExtra(Intent.EXTRA_TEXT) != null) &#123; // 当直接选中文本分享时，会存放在EXTRA_TEXT里面，选择文本文件时，仍然存放在EXTRA_STREAM里面 LogUtils.e("获取到分享的文本 " + intent.getStringExtra(Intent.EXTRA_TEXT)); &#125; else &#123; List&lt;String&gt; sharePaths = getSharePaths(context, intent); LogUtils.e("获取到分享的文件的路径 " + sharePaths.toString()); &#125; &#125; /** * 获取分享过来的路径 * * @param context 上下文 * @param intent intent * @return 路径列表 */ private static List&lt;String&gt; getSharePaths(Context context, Intent intent) &#123; String action = intent.getAction(); List&lt;String&gt; paths = new ArrayList&lt;&gt;(); // 单个文件 if (Intent.ACTION_SEND.equals(action)) &#123; Uri imageUri = intent.getParcelableExtra(Intent.EXTRA_STREAM); if (imageUri != null) &#123; String realPathFromURI = getRealPathFromURI(context, imageUri); if (realPathFromURI != null) paths.add(realPathFromURI); &#125; &#125; // 多个文件 else if (Intent.ACTION_SEND_MULTIPLE.equals(action)) &#123; ArrayList&lt;Uri&gt; imageUris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM); if (imageUris != null) &#123; for (Uri uri : imageUris) &#123; paths.add(getRealPathFromURI(context, uri)); &#125; &#125; &#125; return paths; &#125; /** * 从uri获取path * * @param uri uri * @return path */ private static String getRealPathFromURI(Context context, Uri uri) &#123; final String scheme = uri.getScheme(); String data = null; if (ContentResolver.SCHEME_FILE.equals(scheme)) &#123; data = uri.getPath(); &#125; else if (ContentResolver.SCHEME_CONTENT.equals(scheme)) &#123; Cursor cursor = context.getContentResolver() .query(uri, new String[]&#123;MediaStore.Images.ImageColumns.DATA&#125; , null, null, null); if (null != cursor) &#123; if (cursor.moveToFirst()) &#123; int index = cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA); if (index &gt; -1) &#123; data = cursor.getString(index); &#125; &#125; cursor.close(); &#125; &#125; return data; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义控件-ViewPager广告板轮播]]></title>
    <url>%2Farticle%2F149273814%2F</url>
    <content type="text"><![CDATA[GitHub GitHub地址 Gradle compile &#39;com.march.billboardview:billboardview:2.0.6-beta4&#39; xml 里面使用12345678910111213xml 里面使用&lt;com.march.billboardview.BillBoardView android:id="@+id/billboard" android:layout_width="match_parent" android:layout_height="250dp" board:isAutoRun="true" board:isLoopIt="true" board:intervalTime="2000" /&gt;属性：isAutoRun:是不是自动播放，不需要滑动，默认trueisLoopIt:是不是无限循环播放，默认是trueintervalTime:播放间隔时间，每隔多长时间走一页 构建实体12//实体类实现获取url和title的接口public class Demo implements BoardConfig&#123;&#125; 定义加载工具1234567//初始化图片加载的工具,你可以自定义使用Picasso还是Glide等图片加载库加载BillBoard.init(new BillBoard.BillLoadImg() &#123; @Override public void loadImg(Context context, String title, String url, ImageView imageView) &#123; imageView.setImageResource(Integer.parseInt(url)); &#125; &#125;); 使用SimpleBoardAdapter1234private BillBoardView billBoardView;private SimpleBoardAdapter&lt;Demo&gt; mBoardAdapter;mBoardAdapter = new SimpleBoardAdapter&lt;&gt;(getActivity(), demos);billBoardView.setAdapter(mBoardAdapter); 配置BillBoardView123456789billBoardView .setAdapter(mBoardAdapter) .setSwipeRefreshLayout(sw) .click(new OnBoardClickListener() &#123; @Override public void clickBillBoard(int pos, BoardConfig b) &#123; Log.e(&quot;chendong&quot;, &quot;click pos &quot; + pos + &quot; title is &quot; + b.getTitle()); &#125; &#125;).show(); 数据更新1mBoardAdapter.notifyDataSetChanged(demos); 开放停止和开始播放的方法12public void startPlay()public void stopPlay() SwipeRefreshLayout冲突 当与SwipeRefreshLayout嵌套使用时，解决SwipeRefreshLayout冲突 1public void setSwipeRefreshLayout(SwipeRefreshLayout sw) 轮播动画和时间 下面是可选的插值器,可自定义插值器 12//设置动画的方法public BillBoardView setAnimation(int duration, Interpolator interpolator) 插值器 描述 new AccelerateInterpolator() 开始慢后面加速,由于距离较近效果不明显,有点像是匀速 new AccelerateDecelerateInterpolator() 两头速度慢,中间加速,由于距离较近效果不明显,有点像是匀速 new DecelerateInterpolator() 开始快后面慢,由于距离较近效果不明显,有点像是匀速 new BounceInterpolator() 到达末尾跳跃弹起 new AnticipateInterpolator() 先甩一下在移动 new AnticipateOvershootInterpolator() 先甩一下到达终点后过界在后退 new OvershootInterpolator() 过界后返回 new LinearInterpolator() 常量变速 new LinearOutSlowInInterpolator() 开始快后面慢 其他API12345//BillBoardView//重新定义ViewPager的将停public void setOnBoardPageChangeListener(OnPageChangeListener onPageChangeListener)//获取内部的ViewPagerpublic ViewPager getViewPager() BoardAdapter12345678//一些变量，你可以在子类中访问protected Context mContext;protected int mLyRes;protected int preIndex = -1;//上一个被选中的protected List&lt;B&gt; datas;protected boolean isLoop;protected View mRootView;protected BillBoardView mBoardView; 基于SimpleBoardAdapter1234567891011121314//为了方便使用定义了SimpleBoardAdapter//获取TitleView用于改变字体，颜色，背景，文字大小等public TextView getTitleView()//获取底部Bar,用于改变背景，高度等public ViewGroup getBotLy()//获取导航条public LinearLayout getGuideLy()//设置选中和未选中的资源public void setSelectRes(int selectRes, int unSelectRes)//设置标题的位置POS_LEFT = 0, POS_CENTER = 1, POS_RIGHT = 2public void setTitleGravity(int gravity)//设置导航栏的位置POS_LEFT = 0, POS_CENTER = 1, POS_RIGHT = 2public void setGuideLyGravity(int gravity) 如何自定义Adapter12345678910111213141516171819202122232425262728293031//Adapter做的工作是，覆盖在BillBoardView上面，随着BillBoardView的变化，修改UIpublic class MyAdapter extends BoardAdapter&lt;Demo&gt; &#123; public MyAdapter(Context mContext, List&lt;Demo&gt; datas) &#123; super(mContext, datas); &#125; //资源ID.高度建议Match_parent @Override protected int getLayoutId() &#123; return 0; &#125; //获取控件，findById()或者一些初始化的操作 @Override protected void initAdapterViews() &#123; &#125; //当划到pos位置。更改界面显示 @Override public void changeItemDisplay(int pos, Demo demo) &#123; &#125; //当adapter连接到billboardView时，触发 @Override public void onBillBoardViewAttached(BillBoardView billBoardView) &#123; super.onBillBoardViewAttached(billBoardView); &#125;&#125; 优化 当你的页面退出时,暂定轮播将是优化的一个很好选择 123456789101112131415161718@Overrideprotected void onResume() &#123; super.onResume(); if(billBoardView!=null) billBoardView.startPlay();&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); billBoardView.stopPlay();&#125;@Overrideprotected void onPause() &#123; super.onPause(); billBoardView.stopPlay();&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift基础语法1]]></title>
    <url>%2Farticle%2F1996349588%2F</url>
    <content type="text"><![CDATA[从今天开始学习Swift－2016-3-16； 先学习简单语法，不涉及详细API Swift 3.0已经移除i++方法，请使用i+=1 快捷键123456//格式化代码 ctrl+i//删除一行 command+delete//注释一行command+/ 一些琐碎1234567891011121314151617181920212223242526272829303132//swift是一门安全的语言//不支持隐式类型转换//不支持空值，nil是一种单独的类型//数据类型后面带有数字，表示使用几位来表示，Int8最大为127var int8:Int8print(Int8.max)//二进制，八进制，16进制的表示var two = 0b111var eight = 0o111var sixTeen = 0x111print("\(two) \(eight) \(sixTeen)")//下划线表示忽略,更清晰的数据定义方式var bigNum = 1_000_000var _ = 100//轻量级的数据聚合，元组，元组可以存储任意类型的数据//指定类型var yuanzu0:(Int,String,Int,String) = (100,"0909",30,"222")print("\(yuanzu0.1)")//不指定类型，使用下标访问var yuanzu1 = (100,"0909",30,"222")print("\(yuanzu1.1)")//标志位，访问var yuanzu2 = (x:100,y:"aaa")print("\(yuanzu2.x)")//解包访问，不关心的数据可以使用_代替var (m,_) = yuanzu2print("\(m) ") 常量和变量1234567891011print("hello world");//常量(let)和变量(var)，未赋值的变量常量显示声明类型,赋值的变量常量会自动推断数据类型let contast = 1;print(contast)var a:Int//10进制a = 1000var str = "this is a str" //使用\(变量常量)可以直接打印变量常量出来var rst = "this is a rst = \(a)"print(rst) ##数组和字典123456789101112131415161718192021222324//定义数组，使用［］访问元素var list = [1,2,3,4,5];print(list);print(list[0]);//定义字典，使用key访问var map = ["a":1,"b":2,"c":3];print(map);print(map["a"])print(map["a"]! + 100) //如果列表和字典的类型可以被推断出来，可以不使用类型，也不用带（），在下面，shoplist首先被声明为String类型的数组，后又重新赋值，此时可以推断shoplist 是［String］var shoplist = [String]()shoplist = []//跟常量和变量的定义一样，如果类型可以被推断时，可以不使用类型声明，上面的list和map类型已经可以推断，当将它重新指向空的数组和字典list = []map = [:] //定义空的数组和字典var emptyList = [String]()var emptyMap = [String:Int]()print(emptyList.count)print(emptyMap.count) 控制流for1234567891011121314151617181920212223242526let testList = [1,2,3,4,5,6,7,8];//简单for循环for var i=0;i&lt;8;i+=1 &#123; print("for this is \(testList[i])")&#125;//for in 循环//注意这里的x是常量，不能修改它的值，所以下面（1）是错误的for x in testList&#123; print("for in this is \(x)") //(1) x = 1&#125;//遍历字典中的数组let map2scan = [ "a":[1,2,3,4,5], "b":["a","b","c"]] for (key,value) in map2scan&#123; print("key is \(key)") for num in value&#123; print("num is \(num)") &#125;&#125; if关键字123456789101112131415161718//涉及可选型的概念，后面单独介绍var optionalStr:String? = "hello"optionalStr = "world"print(optionalStr == nil) var greet = "hey"if let name = optionalStr&#123; greet = "hello \(name)";&#125;print(greet) if(optionalStr != nil)&#123; print("optional str is not nil")&#125;if score &gt;= 10&#123;&#125; switch关键字1234567891011121314151617181920212223242526272829303132333435363738394041//swift支持任意数据类型的switch比较，不仅限于Int和enum//break语句,不需要显式添加，默认语句后面都会break;//default语句,是不可以省略的,除非所有的值都被穷举出来了；//fallthrough语句，当满足某个case之后仍旧想使它匹配下一个case，使用 fallthrough，则不会被截断let vegetable = "red peper"switch vegetable&#123;//因为每个case之后都会有break，所以每个case之后必须至少有一行可执行语句，当需要多个匹配时，可以像下面这样case "b","B" print("this is b/B")case "a": print("this is a") fallthroughcase let x where x.hasSuffix("peper"): print("has suffix " + x)default: print("default")&#125;//高级用法//区间let num = 100switch num&#123; case 0 ..&lt; 100: print("小于100")&#125;//元组let point = (1,1)switch point&#123; case (_,0): print("x aliaxs"); fallthrough case (0,_): print("y aliaxs") fallthrough case (0,0): print("origin point") fallthrough case (-2 ... 2,-2 ... 2): print("near by origin point")&#125; while/repeat…while1234567891011//while/repeat...while循环, 当while语句成立时，语句体会执行。var num = 0;while num &lt; 100&#123; num+=1&#125;print("while num is \(num)") repeat&#123; num-=1;&#125;while num &gt; 0print("repeat num is \(num)") 操作符可选值操作符(??)12345//有点类似三目运算符,??表示默认值,当前面的值为空时将会使用后面的let nickName?String = "a"let fullName = "b"let name = "hello \(nickName ?? fullName)"print(name) 范围操作符(..&gt;／…)1234567891011//提供一种更简单实现循环的方式,...包含上界//0 1 2 3for x in 0..&lt;4&#123; print("x is \(x)")&#125;//0 1 2 3 4for x in 0...4&#123; print("x is is \(x)")&#125; 强制解包操作符(!)123//强制解包 unwrap 解包的概念会在可变型中介绍var num = 100var name = "this is " + num! 函数和闭包简述1函数是一个可以被抽取调用的封闭代码块，是可以被传递的数据类型 一个简单函数123456789//函数使用func关键字命名//使用 [参数名:参数类型] ...的方式定义参数//调用函数时，要用 [参数名:值] 的方式传递//func 函数名（参数列表（参数名:参数类型））-&gt; 返回类型 &#123;// 函数体｝func firstFun (name:String,pwd:String,newParams:String)-&gt;Bool &#123; print("name is \(name) and pwd is \(pwd)") return true&#125;firstFun("chendong",pwd:"1234567",newParams:"new params"); 返回多个值1234567891011121314151617181920//可以使用元组返回多个值，实际上是以元组作为值传递的方式//使用元组实现多个返回值//元组可以使用键访问，rst.max,也可以使用下标访问，rst.2func getMultiBackFun(scores:[Int])-&gt;(max:Int,min:Int,sum:Int)&#123; var sum = 0 var min = scores[0] var max = scores[0] for score in scores&#123; sum += score; if(score &gt; max)&#123; max = score; &#125; if(score &lt; min)&#123; min = score &#125; &#125; return (max,min,sum)&#125;let rst = getMultiBackFun([4,8,1,7,4,0,6,3,7])print("max is \(rst.max) min is \(rst.min) sum is \(rst.sum) rst.2 is \(rst.2)") 可变长度参数函数123456789101112//跟所有的语言一样，支持可变长度参数，本质是数组的传递//一个求均值的函数func changeParamFun(params :Int...)-&gt;Void&#123; var sum = 0; for x in params&#123; sum+=x &#125; print("averge is \(sum/(params.count))")&#125; changeParamFun(1,2,3,4)changeParamFun(0,9,8,7) ###函数嵌套定义1234567891011//函数可以嵌套定义,被嵌套的函数作用域有限，只能在嵌套它的｛｝中被访问，比如下面（1）中的代码是编译错误的，被嵌套的函数可以访问外面函数的变量或者全局变量，func aOutFun() -&gt; Void&#123; var num = 100 func aInFun()-&gt;String&#123; return "chendong \(num)" &#125; print(aInFun())&#125;aOutFun()//1 编译错误aInFun() 函数作为返回值123456789//函数作为返回值,下面的函数表示一个无参函数，返回值是一个（参数为Int,返回值是String的）函数类型，在函数returnFuncFun中定义内嵌函数并返回，在外部可以使用该函数func returnFuncFun()-&gt;(Int-&gt;String)&#123; func INTSTRING(num:Int)-&gt;String&#123; return "this num is \(num)" &#125; return INTSTRING&#125;let funINTSTR = returnFuncFun();print("func return is \(funINTSTR(1000))") 函数作为参数传递123456789101112//函数作为参数，下面的函数表示一个参数为Int类型，一个参数为（Int-&gt;String）的函数类型，返回值Stringfunc funParamFun(num:Int,param : Int -&gt; String)-&gt;String&#123; return "funparamfun + \(param(num))"&#125;func paramFunc(num:Int)-&gt;String&#123; return "paramfunc + \(num)"&#125;print("rst is \(funParamFun(100, param: paramFunc))")//结果是 rst is funparamfun + paramfunc + 100 匿名函数闭包12345678910111213141516171819//匿名闭包（in 前面是参数类型，in后面的是函数体）let numbers = [1,2,3,4,5];let get = numbers.map(&#123; （in 前面是函数参数和返回值，in后面的是函数体） (number:Int)-&gt;Int in let rst = number*2; return 3 + rst;&#125;)print("rst is \(get)")//如果一个闭包的类型已知，比如作为一个回调函数，你可以忽略参数的类型和返回值。单个语句闭包会把它语句的值当做结果返回.numbers.map(&#123; number in number * 3&#125;)//使用参数位置代指参数 numbers.sort(&#123;$0&gt;$1&#125;)let get2 = numbers.map(&#123;$0*2&#125;)print("numbers is \(get2)")]]></content>
      <categories>
        <category>Study</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将自己写的库发布到 JitPack]]></title>
    <url>%2Farticle%2F2091453987%2F</url>
    <content type="text"><![CDATA[JitPack优缺 在使用Jcenter发布库代码时，需要先上传到Bintray网站，比较麻烦，不过我之前已经给出了简化的方案,根据这篇文章发布自己的库到JCenter可以很快的配置好项目。本文介绍另外一种发布自己的库代码的方式，使用JitPack发布代码更简单一些。 AndroidStudio创建项目时没有默认生成JitPack的依赖，当使用库时需要添加如下依赖1234repositories &#123; jcenter() maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125; 创建工程新建Library Module,这些就不仔细说了，大家都会，需要注意的一点是，使用JCenter时，库的名字是跟你的Module name有关的，但是JitPack是与你的Project name有关的,所以给你的项目起一个好名字，他将作为库的名称。 配置插件与发布到JCenter一样，需要插件,这里说一下这个插件，该插件的GitHub地址，在发布到JCenter时也用到了这个插件，现在的最新版本1.4.1，我试了一下，编译不成功，看了Issues,大概是因为gradle需要提升到2.14.1才可以，关于这个问题可以自己去查一下，像我下面这样的配置是ok的，版本的对应可以去Git上看看。12345678910buildscript &#123; repositories &#123; jcenter() mavenCentral() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.1.2&apos; classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.3&apos; &#125;&#125; 配置Module的build.gradle123456//默认就有的apply plugin: &apos;com.android.library&apos;//这个跟Jcenter一样的插件apply plugin: &apos;com.github.dcendents.android-maven&apos;//你的Github用户名替换一下group=&apos;com.github.chendongMarch&apos; 发布到GitHub 接下来就去GitHub上打开你的项目－&gt;点击release－&gt;点击创建新的release版本－&gt;书写版本号和release信息－&gt;就会看见到此就完成了发布。如下 JitPack发布 最后去JitPack,会看见如下界面,输入你的项目地址，会看到版本号，点击get it，下面会出现compile地址 完成 AS依赖 1compile &apos;com.github.chendongMarch:JitPackLibs:1.0.2&apos;]]></content>
      <categories>
        <category>Android</category>
        <category>Publish</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Publish</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Mac 下配置 Gradle 命令]]></title>
    <url>%2Farticle%2F2863351425%2F</url>
    <content type="text"><![CDATA[推荐阅读Mac 下配置 Sdk,Gradle 相关下载下载gradle http://gradle.org/downloads/ 配置环境变量 打开.bash-profile 12touch .bash-profileopen -e .bash_profile 打开 bash_profile，配置环境变量。 12345//不使用ndk可以不配置export NDK_PATH=&quot;/Users/Bob_ge/Documents/android_dev/ndk/android-ndk-r10d&quot;export SDK_PATH=&quot;/Users/Bob_ge/Library/Android/sdk/platform-tools&quot;export GRADLE_HOME=&quot;/Users/Bob_ge/Documents/android_dev/gradle/gradle-2.4/bin&quot;export PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/usr/local/ant/bin:/opt/reverse:$&#123;SDK_PATH&#125;:$&#123;NDK_PATH&#125;:$&#123;GRADLE_HOME&#125; 更新 bash_profile 1source .bash-profile 输入adb 检测是否配置正确 1gradle -version]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>DevEnvironment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将自己写的库发布到Jcenter]]></title>
    <url>%2Farticle%2F3189961703%2F</url>
    <content type="text"><![CDATA[本文主要介绍如何最简单的将自己的 Library 发布到 jcenter。 2017.6.16 更新为使用远程上传脚本打包上传，简化操作流程 使用 gradle 开发过程中，我们可以使用 compile 命令，依赖 Library，这种做法的好处时，我们不需要再去关注一堆 jar 文件，当我们需要升级 Library 时，只需要改变依赖的版本号，就可以完成升级。 我们之所以可以使用一句 gradle 脚本完成依赖的下载，升级，是因为这些 Library 都被存储在了一个公共的服务器上，通过 compile 命令可以唯一的映射到服务器存储的 Library。 jcenter 就是一个这样的服务，AndroidStudio 现在新建项目都会默认依赖 repositories {jcenter()}，当执行 compile 脚本时，就会去 jcenter 检查对应的 Library 进行下载和依赖。 踩过的坑 删除 gradle.properties 里面会有 systemProp.http.proxyHost=127.0.0.1 systemProp.http.proxyPort=1080字段，使用代理可能会导致无法上传发布。 打包 javadoc 时会出问题，因为他会将你所有的注释打包进去，如果注释写的不规范就会报错，不过这个是有提示的，按照提示改掉就好了，注释要符合要求。 如果出现了 gradle commond not found ,说明你的 gradle 路径没有配置，mac可以参考这篇文章进行配置。 你的 library 中的 manifest 文件有 allowback 属性最好删掉， 当别人或者你的别的工程引用这个库时，需要进行 manifest 的 merge 操作，如果某些属性冲突了会导致合并失败，因此库文件的 manifest 文件只保留必要的属性，即可。 注册账号我们要发布自己的库到 JCenter,首先要将代码发布到 maven 库，官方网站www.bintray.com ，进去网站注册登录就好了，注册之后可以拿到你的用户名和 apikey。 apiKey 的获取方法 －&gt; 右上角点击头像 －&gt; your profile-&gt; 头像下面edit -&gt; 最下面的 APIkey 就可以获取了，后面有用。 构建项目使用 AS 开发你的项目应该是有多个 module 的，通常你的项目至少应该有 app 这个 module ，创建一个 library 类型的 module（点击工具栏 File - &gt; new moudle -&gt; library,就可以建立一个library moudle)，因为我们要发布到 maven 的是你的 library，所以这个 moudle 需要有。然后你应该把这个项目发布到 github上去，后续需要填写项目的地址，当然这不是必选的。 配置 project/build.gradle配置这个文件主要是依赖一些必要的插件来完成后续的打包上传操作，可能当你看到时下面的插件版本已经不是最新的了，你可以自己依赖最新的插件。 123456789101112131415161718//最后写完应该是这样的buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.2.3' //主要是下面的两行 classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0' classpath 'com.github.dcendents:android-maven-gradle-plugin:1.4.1' &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125; 配置 module/build.gradle需要在 ext{} 内配置项目的相关信息，在每个信息上我都加了比较详细的注释。 完整的配置文件如下，引用了我 git 上面远程的一个上传脚本，当然你也将全部内容复制到本地进行修改，使用远程脚本是为了简化书写脚本的流程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546apply plugin: 'com.android.library'android &#123; ...&#125;dependencies &#123; ...&#125;ext &#123; // 项目的主页 yourSiteUrl = 'https://github.com/chendongMarch/LightAdapterExample' // Git仓库的url yourGitUrl = 'https://github.com/chendongMarch/LightAdapterExample' // issue 地址 YourIssueTrackerUrl = 'https://github.com/chendongMarch/LightAdapterExample/issues' // 项目的名称，将会显示在bintray yourProName = 'LightAdapter' // 项目的描述 yourProDesc = 'Java Recyclerview Library' // bintrayID yourId = 'chendongmarch' // nickName yourName = 'chendong' // email yourEmail = 'helloworld4x@gmial.com' // 最后生成依赖 compile 'yourGroup:yourArtifactId:yourVersion' // 最后生成依赖 compile 'com.march.lightadapter:lightadapter:1.0.1-beta1' yourGroup = 'com.march.lightadapter' yourArtifactId = 'lightadapter' yourVersion = '1.0.1-beta4' // 此文件中存储的是 bintray 的敏感信息，用户名和key // 你需要在该文件中如下声明 // bintray.user=xxxx // bintray.apikey=xxxx // 你可以使用项目中的 local.properties yourBintrayUserPath = '/Users/march/AndroidRes/file/common_local.properties'&#125;apply from: 'https://raw.githubusercontent.com/chendongMarch/Resource/master/jcenter/bintrayUpload.gradle' 需要注意的点下面配置的三个值，决定了你最后生成的依赖是什么样的，我用我现在的库举了个例子，这个是可以后期修改的。 12345// 最后生成依赖 compile 'yourGroup:yourArtifactId:yourVersion'// 最后生成依赖 compile 'com.march.lightadapter:lightadapter:1.0.1-beta1'yourGroup = 'com.march.lightadapter'yourArtifactId = 'lightadapter'yourVersion = '1.0.1-beta4' 用户名和 key，这些敏感信息是不应该被传到 git 上面的， 你应该在 .gitignore 中避免上传这个文件，习惯的做法你可以将这些信息写在 local.properties 中，路径配置为 yourBintrayUserPath = &#39;local.properties&#39;，我的做法是写在本地文件中然后使用绝对路径引用。 然后你在文件中需要按照如下格式声明 bintray.user 和 bintray.apikey； 123456// 此文件中存储的是 bintray 的敏感信息，用户名和key// 你需要在该文件中如下声明// bintray.user=xxxx// bintray.apikey=xxxx// 你可以使用项目中的 local.propertiesyourBintrayUserPath = '/Users/march/AndroidRes/file/common_local.properties' 发布类库我在 mac 下开发，相关命令可能有所差异。 打开 terminal，运行 install 命令 1./gradlew install 成功后运行上传命令 1./gradlew bintrayUpload 当提示 Build Success 后，去网站打开所在的项目，注意右上角有个链接，类似 https://dl.bintray.com/chendongmarch/maven，这是你 maven库的链接，也就是你私有的空间。注意左下角有三个很小的选项 maven、gradle、lvy，点击 gradle 可以看到一个依赖地址，这是 compile 的地址，就算大功告成啦。 在私有空间使用类库此时你已经可以使用这个类库了，但是因为你的类库没有发布到共有空间，因此使用时需要在 project/build.gradle 声明你的私有空间。 12345678910111213//在 project/build.gradle 文件中添加你私有 maven 空间allprojects &#123; repositories &#123; jcenter() // 现在之所以添加这一句是因为你的类库只是发布到了maven // 但是没有发布到JCenter // 因此需要单独依赖你的私有空间的地址。 maven &#123;url &apos;https://dl.bintray.com/chendongmarch/maven&apos;&#125; &#125;&#125;//在app/build.gradle文件中依赖compile &apos;com.march.lightadapter:lightadapter:1.0.1-beta1&apos; 发布到 jcenter然后我们将类库发布到公共空间让别人可以快速使用，还是在网站查看项目右下角可以看到 Add to jcenter 点击之后可以很简单的添加你的库到 JCenter,但是审核需要时间，第一次会慢一点，以后会很快。等到审核通过，就可以将 maven{url=&quot;&quot;} 这一块去掉，直接 compile，因为已经可以在 jcenter 找到你的类库了， 不需要使用私有空间了。 在本地空间使用类库单单运行 ./gradlew install 任务， gradle 会在 maven 的本地仓库中生成工件，只需将 mavenLocal 添加到 repositories，我们可以像发布到 JCenter 一样引用自己的库，方便打包那些多个项目共享又不想发布的私有库, 在project/build.gradle 文件添加下面的依赖，可以使用本地库，类比上面的私有空间，这个应该算本地空间。 123456allprojects &#123; repositories &#123; mavenLocal() jcenter() &#125;&#125; 一些理解总体来说，最最重要的是打包上传的脚本，他负责打包源文件，生成 aar，生成 doc 然后上传到 bintray，我之前采用过别的方式打包类库，本文介绍的方法有个很大的优点就是把这个任务独立出来，写在 bintrayUpload.gradle 文件中，使用远程脚本，需要打包上传的 library 只需要配置一下类库相关信息，引用这个脚本就可以上传，不需要进行复杂的配置。]]></content>
      <categories>
        <category>Android</category>
        <category>Publish</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Publish</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Android平台下合成Gif]]></title>
    <url>%2Farticle%2F3121499733%2F</url>
    <content type="text"><![CDATA[最近在做合成 gif 的工作，在网上搜到了很多资料，总结一下，总共找到了两种方法，分别是使用 jni 和 java 算法实现。测试表明 java 算法比 so 文件更快，大约快两倍。 java算法合成 Java算法源代码 网上流传很广的就是下面在java中的算法，修改了一些bug AnimatedGifEncoder.java LZWEncoder.java NeuQuant.java C算法 C的源代码 网上有很多关于gifflen合成gif的文章 可以很轻松的get到C源代码，但是需要ndk进行编译 当然也可以用现成的so文件，但是需要将utils类建立在指定包下 一份合成好的so文件 so文件 加载so文件时需要将jni接口写在指定的包下，目前com.xingye.gif 合成好的jar文件 jar文件下载 结合so文件可以直接使用，不需要自己建包 GitHub 详见该类 总结 java的库很简单，有那几个合成的类，定制一个工具类就好了，C的库比较繁琐，虽然效率还没有java快，总结一下就是 自己用C代码合成so 用我合成的so,但是你需要按照编译好的con.xingye.gif包下的GifUtil 来执行代码 更简单，jar文件已经打包好，集成so文件和jar文件，编译可以使用,就是自定义不方便了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView Adapter 4]]></title>
    <url>%2Farticle%2F2414640248%2F</url>
    <content type="text"><![CDATA[GitHub库代码链接 Gradlecompile &#39;com.march.adapterlibs:adapterlibs:1.0.6&#39; 前言 基于前端时间总结的EasyAdapter（看原理的可以看这些博客）重新构建了代码，基本思想还是一样的，目的是对外开放更加简单的API,其中的原理，想知晓的可以去看我以前的博客。现在的版本已经与以前的版本独立开了。 单类型抽象适配QuickAdapter123456789101112QuickAdapter&lt;Demo&gt; adapter =new QuickAdapter&lt;Demo&gt;(BaseApplication.getInst(), R.layout.item_quickadapter, data) &#123; @Override public void bindData4View(ViewHolder holder, Demo data, int pos) &#123; holder.setText(R.id.item_quickadapter_title, data.getmDemoTitle()); &#125; @Override public void bindListener4View(ViewHolder holder, Demo data, int pos) &#123; //在这里给内部控件绑定监听不是必须实现的 &#125; &#125;; 使用QuickTypeAdapter QuickTypeAdapter的带layout资源参数构造方法,注意不要调用addType了,实体类需要实现QuickInterface接口 1234567891011QuickTypeAdapter&lt;Demo&gt; typeAdapter =new QuickTypeAdapter&lt;Demo&gt;(BaseApplication.getInst(), data,R.layout.item_a) &#123; @Override public void bindData4View(ViewHolder holder, Demo data, int type, int pos) &#123; //单类型,type一直返回0 &#125; @Override public void bindListener4View(ViewHolder holder, Demo data, int type, int pos) &#123; //在这里给内部控件绑定监听不是必须实现的 &#125;&#125;; 多类型适配1234567891011121314151617181920212223//实体类需要实现QuickInterface接口QuickTypeAdapter&lt;Demo&gt; typeAdapter = new QuickTypeAdapter&lt;Demo&gt;(BaseApplication.getInst(), data) &#123; @Override public void bindData4View(ViewHolder holder, Demo data, int type, int pos) &#123; switch (type) &#123; case Demo.CODE_DETAIL: holder.setText(R.id.item_quickadapter_type_title, data.getmDemoTitle()); break; case Demo.JUST_TEST: holder.setText(R.id.item_quickadapter_title, data.getmDemoTitle()); break; &#125; &#125; @Override public void bindListener4View(ViewHolder holder, Demo data, int type, int pos) &#123; //在这里给内部控件绑定监听不是必须实现的 &#125; &#125;;//添加每种类型的xml文件typeAdapter.addType(Demo.CODE_DETAIL, R.layout.item_quickadapter_type) .addType(Demo.JUST_TEST, R.layout.item_quickadapter); 加载网络图片 可以提前创建图片加载工具,然后调用ViewHodler.setImg()方法可以直接加载 12345678//你可以在Activity或者Application调用这段代码进行全局配置,第二次调用会将以前的设置覆盖,所以只需要执行一次Quick.init(new Quick.QuickLoad() &#123; @Override public void load(Context context, String url, ImageView view) &#123; Log.e("chendong","加载图片"); Glide.with(context).load("http://www.fresco-cn.org/static/fresco-logo.png").into(view); &#125; &#125;); 更新使用方法12345678910111213//Demo类是我的实体类//如果你使用的控件ViewHolder没有为你集成,如何避免强转?使用泛型解决 holder.&lt;Button&gt;getView(R.id.abc).setText("");//设置监听事件public ViewHolder setLis(int resId,View.OnClickListener listener,Object tag)//带有tag监听public ViewHolder setLis(int resId,View.OnClickListener listener)//不带tag监听public ViewHolder setTag(int resId, Object tag)//给控件设置tagpublic &lt;T&gt; T getTag(int resId)//从ViewHolder获取tag,包含泛型,你可以这样holder.&lt;Demo&gt;getTag(R.id.xxx)//如果你在控件中设置了tag,当你在适配器外部使用tag时务必使用改方法获取,用来替代view.getTag()方法,包含泛型,你可以这样用 Quick.&lt;Demo&gt;getTagOutOfAdapter(listView);Quick.getTagOutOfAdapter(View view)]]></content>
      <categories>
        <category>Android</category>
        <category>Adapter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ListView</tag>
        <tag>Adapter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android物理按键及物理连接]]></title>
    <url>%2Farticle%2F4013192295%2F</url>
    <content type="text"><![CDATA[本文主要介绍 Android 手机物理按键触发监听，以及外接蓝牙，耳机等设备的检测。 事件分发 拦截按键按下抬起时的事件分发 12345678@Override public boolean dispatchKeyEvent(KeyEvent event) &#123; //如果是长按事件交给onKeyLongPress处理 if (event.getRepeatCount() &gt; 0) return onKeyLongPress(event.getKeyCode(), event); return super.dispatchKeyEvent(event); &#125; 返回按键12345//返回键的监听很常见，android提供了简便的方法@Overridepublic void onBackPressed() &#123; finishThisPage();&#125; 按键按下事件处理 (音量，耳机按键，back键) 123456789101112131415161718192021222324//home键和power键没有监听到//我当时需要的是音量键和耳机按键可以拍照，是可以监听到的@Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; L.info(event.toString()); switch (keyCode) &#123; case KeyEvent.KEYCODE_VOLUME_DOWN: L.info("KEYCODE_VOLUME_DOWN-音量键减小声音"); return true; case KeyEvent.KEYCODE_VOLUME_UP: L.info("KEYCODE_VOLUME_UP-音量键增加声音"); return true; case KeyEvent.KEYCODE_VOLUME_MUTE: L.info("KEYCODE_VOLUME_MUTE-音量键静音"); return true; case KeyEvent.KEYCODE_HEADSETHOOK: L.info("KEYCODE_HEADSETHOOK-耳机线按键"); return true; case KeyEvent.KEYCODE_BACK: L.info("KEYCODE_BACK-返回键"); return true; &#125; return super.onKeyDown(keyCode, event); &#125; 其他事件1234567891011121314151617181920212223242526272829303132// 使用快捷键可以快速选中菜单中的某一项，在Android没有什么卵用@Override public boolean onCreateOptionsMenu(Menu menu) &#123; MenuItem add = menu.add(""); add.setShortcut('A','A'); return super.onCreateOptionsMenu(menu); &#125;@Override public boolean onKeyShortcut(int keyCode, KeyEvent event) &#123; L.info("onKeyShortcut " + event.toString()); return super.onKeyShortcut(keyCode, event); &#125;@Override public boolean onKeyLongPress(int keyCode, KeyEvent event) &#123; L.info("onKeyLongPress " + event.toString()); return super.onKeyLongPress(keyCode, event); &#125; //暂时没有用到，网上有说在手写和汉字输入时会触发@Override public boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event) &#123; L.info("onKeyMultiple " + event.toString()); return super.onKeyMultiple(keyCode, repeatCount, event); &#125;//按键抬起时会触发@Override public boolean onKeyUp(int keyCode, KeyEvent event) &#123; L.info("onKeyUp " + event.toString()); return super.onKeyUp(keyCode, event); &#125; 外设监测 检测耳机线，蓝牙耳机是否连接 1234567891011121314151617181920212223242526272829303132private boolean checkControlIsConnected() &#123; //检测耳机线是否连接 AudioManager am = (AudioManager) getSystemService(AUDIO_SERVICE); //这个方法已经过时，api介绍仅仅用来检测是否连接，可以注册广播接收者接受耳机插拔的广播 if (am.isWiredHeadsetOn()) &#123; //耳机插入 return true; &#125; //检测蓝牙设备是否连接 BluetoothAdapter ba = BluetoothAdapter.getDefaultAdapter(); //蓝牙适配器是否存在，即是否发生了错误 if (ba == null || !ba.isEnabled()) &#123; //蓝牙不可用 return false; &#125; else if (ba.isEnabled()) &#123; Set&lt;BluetoothDevice&gt; bondedDevices = ba.getBondedDevices(); if (bondedDevices == null || bondedDevices.size() &lt;= 0) &#123; //当前没有设备连接 return false; &#125; else &#123; for (BluetoothDevice d : bondedDevices) &#123; if (d.getBondState() == BluetoothDevice.BOND_BONDED) &#123; //当前有设备接入并处于连接状态 return true; &#125; &#125; &#125; &#125; return false; &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础1]]></title>
    <url>%2Farticle%2F1811789999%2F</url>
    <content type="text"><![CDATA[前言 我使用的Pycharm编译器，刚开始就遇到了一个问题，不能输入中文，解决办法就是在文件头部添加代码#-*- coding:utf8 -*- Python交互12345678910111213141516171819# 使用python交互模式# 在命令行界面输入｀python｀进入交互模式# ｀help()｀进入帮助模式# 尝试｀keywords｀获取关键字帮助#｀help("modules")｀查看modules# ｀quit｀ 退出帮助模式#dir(object) 它返回传递给它的任何对象的属性名称经过排序的列表#dir()当前倒入的模块#下面以内建函数id为例#获取文档介绍,｀id.__doc__｀#获取名称,并不是所有的都有`id.__name__`属性#`hasattr(dir,'__doc__')`,`getattr(dir,'__doc__')`获取一个对象的属性#callable可调用性`callable("a")` false,`callable(dir)` true#`isinstance("python", str)`,`issubclass(child.father)` 数据类型12345678# 列表(同类型数据构成的数组)list ＝ ［1，2，3，4］# 元组（数据类型可以不同，简单方便的数据聚合，类似结构体）tuple = (1,"second",1.2)# set（数据不重复，使用list构建，无序，不能使用索引访问）set = set([1,2,3,4])# 字典（键值对存储数据）dict ＝ ｛"a":"b","c":"d"｝ 基础语法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218# 打印# 自动追加换行符print "hello world"# 将不会打印换行符号print "hello world",＃ 使用匹配符num = 100num2 = 200print "num is %d"%numprint "num is %d,num2 is %d"%(num,num2)# 内建函数id()和type()a = 3# 获取内存地址print "id(a) is ", id(a)# 获取变量类型print "type(a) is ", type(a)# 运算符(两个比较特殊的)# 级数乘2的3次方print "use ** = ", 2 ** 3# 除后取整print "use // = ", 9 // 4# 逻辑运算 and | or | notif a == 0 and b == 0: a = 2# for in 循环for i in [1, 2, 3, 4]: print i,# 模块的导入的几种方式import mathfrom math import powfrom math import pow,absfrom math import *print pow(10, 3)from math import pow as pingfangprint pingfang(10, 3)# 赋值# 多个赋值可以直接顺序写，会挨个自动赋值x, y, z = 1, "abc", [1, 2, 3]print x, y, z# 自动创建元组，将后面的数据,装入元组xx = 1, 2, 3, 4, "qqq"print xx# 交换数据的方式yy, zz = 3, 4print yy, zzyy, zz = zz, yyprint yy, zz# 链式赋值,两个变量指向统一空间,id()一样的m = n = 123print m, nprint m is n# 判断结构xxx = 1if xxx == 1: print "this is test ", 1elif xxx == 2: print "this is test ", 2else: print "this is test ", 100#获取控制台输入inputNum = raw_input()# 三元运算# A = X if B else Y# 如果B为真,执行A = X,否则执行A = Ymm, nn = 1, 2rstStr = "abc" if mm &gt; nn else "def"print rstStr# for循环和内建函数range(start,stop,step),range(start,stop,1),range(0,stop,1)返回的是数字元素的列表start开始,stop结束,每次增加step个strx = "abcdefg"for i in range(len(strx)): print strx[i],range(9)range(3, 9)range(3, 9, 4)＃ 一个可迭代的对象可以直接转换为序列对象print list(strx)print set(strx)print tuple(strx)# 遍历字典dictStr = &#123;"a": "b", "c": "d"&#125;# 不建议使用,效率相对低for key in dictStr: print "1key value is ", key, dictStr[key]# 遍历keyfor key in dictStr.keys(): print "2key value is ", key, dictStr[key] for key, value in dictStr.items(): print "3key value is ", key, value# 更优for key, value in dictStr.iteritems(): print "4key value is ", key, value # 单独取value使用下面的方法效率更高for value in dictStr.values(): print "5value is ", value# 内建函数zip(),将两个序列数据类型,每一项取出来,合并为一个元组,构成元组的liststr1 = "abcdef"str2 = "12345"print zip(str1, str2, str2)# [('a', '1', '1'), ('b', '2', '2'), ('c', '3', '3'), ('d', '4', '4'), ('e', '5', '5')]# 交换key,value,每个item是两个元素的tuple的list可以直接转换为dictdict1 = &#123;"a": "1", "b": "2", "c": "3"&#125;print dict(zip(dict1.values(), dict1.keys()))# 内建函数enumerate()生成的是（item为下标和元素构成的两元元组）的可迭代对象，可以直接转换为列表mList = ["a", "b", "c", "d", "e"]for (i, j) in enumerate(mList): print i, " -- ", jprint list(enumerate(mList, start=1))#[(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e')]# 替换字符串中的字符,字符串正则分割originStr = "Do u like Canglaoshi? Canglaoshi is a good teather!"splitStrs = originStr.split(" ")for i, s in enumerate(splitStrs): if "Canglaoshi" in s: splitStrs[i] = "Python"# list解析,去掉元素前后空格,list解析可以简单快捷的修改每一个元素，生成新的listoriginList = [" abc", " vbf ", "rtg "]afterList = [one.strip() for one in originList]print afterList# list切片[start = 0,stop = len(list),step = 1],一个简单从list提取部分数据的方式list2cut = [1,2,3,4,5,6,7]listRst = list2cut[0:5:2]print "list2Rst is " ,listRst# 一个猜数字的小程序，简单介绍循环结构和判断结构的简单实用import randomnumber = random.randint(1,100)while(True): print "请输入一个数字,猜测约定的数字是多少?" input = raw_input() if (int)(input) == number: print "正确!" break elif (int)(input) &lt; number: print "太小了!" else: print "太大了!"# for... else 和 while... else# 跳出循环结构之后执行else语句for i in range(1,100): print i,else: print "end"# 迭代list2Iter = [1,2,3,4,5,6]iterIt = iter(list2Iter)# 这里会提示一个警告while True: print iterIt.next()# 文件迭代#f其实是一个可以迭代的对象,可以使用列表操作list2File = [line for line in open(fileName)]print "list2File is ",list2File# 可以更简单list2File = list(open(fileName))print "list2File2 is ",list2File 文件简单操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455文件操作fileName = "/Users/march/123.txt"# 以一种模式打开文件获取可迭代索引file = open(fileName, "rw")for line in file: print line,file.close()#打开文件的模式r 以读方式打开文件，可读取文件信息。w 以写方式打开文件，可向文件写入信息。如文件存在，则清空该文件，再写入新内容a 以追加模式打开文件（即一打开文件，文件指针自动移到文件末尾），如果文件不存在则创建r+ 以读写方式打开文件，可对文件进行读和写操作。w+ 消除文件内容，然后以读写方式打开文件。a+ 以读写方式打开文件，并把文件指针移到文件尾。b 以二进制模式打开文件，而不是以文本模式。该模式只对 Windows 或 Dos 有效，类 Unix 的文件是用二进制模式进行操作的。# 不需要关闭的安全方法with open("/Users/march/123.txt", "a") as ff: ff.write("this is new line")# 获取文件状态import osfileStatus = os.stat(fileName)print fileStatusimport timeprint time.localtime(fileStatus.st_ctime)# 指定size时读取指定size的数据,否则读取全文，下面的所有方法都遵循这一规则file = open(fileName)# 读取字节file.read()file.read(100)# 读取一行file.readline()file.readline(100)# 读取所有数据存储在列表中file.readlines()file.readlines(100)# 移动指针file.seek(10)# 当前指针的位置file.tell()# 另外一种简化的读取文件的方式import fileinputfor line in fileinput.input(fileName): print "use fileinput print is " , line 列表操作12345678910111213141516171819charList = ['1A','2','3','4','5','6','7','8','9','10','11','11']strList = ["1","2","3","4","5","6","7","8","9","10","11","11"]charList.append("new_a")#在指定位置添加元素,指定位置之后的元素向后移动一个,长度+1charList.insert(1,12)#当前元素在列表中的位置print("pos of 3 ",charList.index("3"))#当前元素在列表中出现的次数print("total num of 11 ",charList.count('11'))#将当前字符串\列表(可迭代类型的数据)拆分成单个字符添加在末尾，返回值是noneprint(charList.extend(strList))#从末尾弹出一个元素,或从指定位置弹出,返回值 是该元素print(charList.pop(2))#移除指定元素,不能使用下标做参数charList.remove('1A')#列表反向charList.reverse()#针对第一个字母或数字排序,更多参数比较复杂charList.sort()]]></content>
      <categories>
        <category>Study</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android图像处理相关]]></title>
    <url>%2Farticle%2F2699277879%2F</url>
    <content type="text"><![CDATA[Bitmap和Drawable转换12345678910111213141516//drawable 转 bitmappublic static Bitmap drawableToBitmap(Drawable drawable) &#123; int width = drawable.getIntrinsicWidth(); int height = drawable.getIntrinsicHeight(); Bitmap bitmap = Bitmap.createBitmap(width, height, drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565); Canvas canvas = new Canvas(bitmap); drawable.setBounds(0, 0, width, height); drawable.draw(canvas); return bitmap; &#125; //bitmap 转 drawablepublic static Drawable bitmapToDrawble(Bitmap bitmap,Context mcontext)&#123; Drawable drawable = new BitmapDrawable(mcontext.getResources(), bitmap); return drawable; &#125; 获取图片创建的时间1234567891011121314151617181920212223//文件修改的时间File file = new File("");file.lastModified();//获取照片拍摄的时间// MediaStore.Images.Media下面有DATE_TAKEN,DATE_ADD,DATE_MODIFIED的参数，分别是照片拍摄的时间，添加到ContentProvider的时间，最后修改的时间，经过测试显示，DATE_TAKEN这个字段下面的时间是最靠谱的，不说他是不是准确，但是系统相册也是使用的这个时间作为照片信息，亲测。另外，有趣的是，只有DATE_TAKEN这个字段下是毫秒级的，另外两个都是秒级的。public static long getImgCreateTime(Context context, String path) &#123; long createTime = -1; Uri mImageUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI; ContentResolver mContentResolver = context.getContentResolver(); Cursor mCursor = mContentResolver.query(mImageUri, new String[]&#123;MediaStore.Images.Media.DATE_TAKEN&#125;, MediaStore.Images.Media.DATA + "=?", new String[]&#123;path&#125;, MediaStore.Images.Media.DATE_TAKEN); if (mCursor == null) &#123; return -1; &#125; while (mCursor.moveToNext()) &#123; //获取图片的路径 String str = mCursor.getString(mCursor .getColumnIndex(MediaStore.Images.Media.DATE_TAKEN)); createTime = Long.parseLong(str); &#125; return createTime ; &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler源码分析]]></title>
    <url>%2Farticle%2F541527599%2F</url>
    <content type="text"><![CDATA[Handler意思是处理者，它是android特有的用来消息处理的一个类。使用它可以解决很多android中常见的问题. Handler体现的是一种消息的发送与处理异步进行的机制，消息发送时即刻返回，将消息加入队列中，另一端looper负责循环取出消息进行操作。 需要注意的是Handler可以发送Message也可以发送Runnable对象。但是消息处理必定是在Handler所在的线程中，也就是说UI线程中的Handler发送的消息也是在UI线程中执行，所以同样不能执行耗时操作。 使用场景： 发送延时消息，执行延时任务，使用线程睡眠的方式过于粗糙。。通常是用Handler发送延时消息或者使用Timer来完成延时操作。 在子线程“操作”UI，众所周知子线程是不能操作UI的，想要在子线程的任务执行完之后更改UI,就需要在子线程向主线程发送消息让主线程来修改UI。 结合异步任务实现任务回调，这个实际上是等同于2的，因为异步任务内部也是子线程，使用Handler+异步任务可以实现请求的回调，但是通常我们更加偏向于接口回调的方式，而不是传递Handler。 在子线程中使用Handler,对任务进行串行化处理，可以更加高效的管理任务的执行。 Handler原理图解： Looper类介绍 Looper类负责在消息队列的另一端取出消息进行处理，Handler采用消息的先进先出原则。 成员变量 Looper中的成员变量ThreadLocal，提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。查了很多资料，这里有很好的的解释，大家可以去膜拜一下。 Looper类中，首先ThreadLocal变量是private static的，每个线程只能有一个Looper对象，在我看来，使用ThreadLocal是为了对每个线程的Looper进行管理。使用ThreadLocal存储Looper就可以很方便的隔离其他线程随时存取本线程的Looper对象，结合后面的代码，发现创建Looper时会使用当前线程为键，新创建的Looper为值存放到ThreadLocal中，prepare()又会进行判断是否已经创建了该线程的Looper,这么说可能有些抽象，建议看完后面的代码，再回来看这段也许会更加清晰一点。 123456//ThreadLocal.get() will return null unless you've called prepare().static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();private static Looper sMainLooper; // guarded by Looper.class（被这个类保护）final MessageQueue mQueue;final Thread mThread; 构造方法 构造方法,私有化的构造方法，并不允许外部调用，做的操作是创建一个MessageQueue和将mThread对象指向了本线程。这里有个重要的地方是，MessageQueue是Looper创建并首先持有的。 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 在Looper之中有一个private static Looper sMainLooper;变量，这个变量代表主线程（UI）的Looper，这也就是我们不需要在UI线程显式调用Looper.prepare()方法的原因，看下面的代码及注释： 12345678910111213141516171819202122/**//初始化当前线程Looper,将它标记为应用的主要Looper。应用程序的主Looer是Android环境创建的 ,所以你应该不需要自己调用这个函数* Initialize the current thread as a looper, marking it as an* application's main looper. The main looper for your application* is created by the Android environment, so you should never need* to call this function yourself. See also: &#123;@link #prepare()&#125;*/public static void prepareMainLooper() &#123;//进行一次准备并且是不允许打断的prepare(false);synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125;//获取这个loopersMainLooper = myLooper();&#125;&#125;//myLooper返回的是本线程的Looperpublic static Looper myLooper() &#123;return sThreadLocal.get();&#125; 成员方法 prepare方法,创建Looper放入sThreadLocal，同时要求每个线程只能有一个Looper对象，多创建会报异常。 123456789public static void prepare() &#123;prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123;if (sThreadLocal.get() != null) &#123;throw new RuntimeException("Only one Looper may be created per thread");&#125;sThreadLocal.set(new Looper(quitAllowed));&#125; loop方法，使用该方法循环取出MessageQueue的消息。死循环取出消息，进行处理，处理完之后，同时消息会被回收掉，使用这个机制可以进行消息对象的复用，这里loop()结合MessageQueue的next()方法，形成了一个轮询的过程，详细的内容会在MessageQueue类的分析中来看，到时候会解释死循环轮询消息的机制。这里有其他对象的部分方法，暂且不去考虑，做下标记，看到Message的源码自然就会明白。 ###留下的问题： Message msg = queue.next();msg.target.dispatchMessage(msg);msg.recycleUnchecked();稍后我们会去解决。 123456789101112131415161718192021222324public static void loop() &#123;final Looper me = myLooper();if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");&#125;final MessageQueue queue = me.mQueue;// Make sure the identity of this thread is that of the local process,// and keep track of what that identity token actually is.Binder.clearCallingIdentity();final long ident = Binder.clearCallingIdentity();//死循环取出消息，进行处理，当取不到消息时，return掉，等待下次调用loop(),同时消息会被回收掉，使用这个机制可以进行消息对象的复用，这里涉及了Message对象的部分方法，暂且不去考虑，做下标记，看到Message的源码自然就会明白for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123;// No message indicates that the message queue is quitting. return;&#125;msg.target.dispatchMessage(msg);// Make sure that during the course of dispatching the// identity of the thread wasn't corrupted.final long newIdent = Binder.clearCallingIdentity();msg.recycleUnchecked(); &#125;&#125; Message类成员变量 Message类十分类似于Bean类，毕竟它是用来承载消息的。 what,arg1,arg2,obj都是预设好用来盛放简单消息内容的变量，原文的注释中使用了lower-cost表示使用这些变量可以降低开销，就是不用自己创建维护这些变量，而且消息是可以被复用的，确实降低了开销。 target变量，是一个Handler,后面的代码中会具体介绍他的作用，这个变量也算这个类的核心了。 Runnable callback,代表一个任务，前面说过Handler可以发送简单消息也可以发送任务。 Message next，代表下一个Message的引用，由此形成了一个链表的结构。 还有很多常量，变量不做一一介绍。下面有注释，不太详细，大家可以看完后面的再回来看也许会更加清晰。感兴趣的可以仔细去看源码注释。 123456789101112131415161718192021public int what;//消息标示public int arg1; public int arg2;public Object obj;public Messenger replyTo;public int sendingUid = -1;//标示该消息正在使用之中static final int FLAG_IN_USE = 1 &lt;&lt; 0;static final int FLAG_ASYNCHRONOUS = 1 &lt;&lt; 1;tatic final int FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE;int flags;long when;Bundle data;Handler target;//Handler重点哦Runnable callback;//一个任务可以用来发送，类似于Bean的一个属性Message next;//下一个Message，用于构成链表private static final Object sPoolSync = new Object();//同步对象private static Message sPool;//链表根节点，他维护了一个空的Message队列用来复用private static int sPoolSize = 0;//链表的长度private static final int MAX_POOL_SIZE = 50;//链表最大数量private static boolean gCheckRecycle = true; 成员方法obtain() Message类中实现了obtain()的8个重载方法，提供了各种各样的参数，为的只是我们在外部用起来好用，所以大家使用Message时不妨多去用用其他方法，我到现在为止一般都是偏用参数为空的方法，其他的重载基本没看过，另外Handler也提供了大量的obtain方法，是的Message的重用和管理更加的方便了，所以千万不要去new Message。其他的方法也会回调空参方法然后进行一下外围的初始化，所以我们就来看看空参方法。 代码不多，解释一下，首先这个变量sPoolSync，看名字就知道他是用来同步操作的，目的是当一个操作在获取Message是进行同步操作，避免其他的操作再来创建Message，否则会怎么样？Message本身形成了一个链表的结构，不进行同步就会，出现多个头，或者一个Message后面接入多个Message，那么后接入的就会覆盖掉，是这样吗？还是出错误。 接下来是一个判断，我们看到sPool这个变量，它是一个Message对象，经过我的研究它是这个链表的头指针，同时sPool维护的是一个曾经创建过的空的可复用的Message队列，了解这一点至关重要，这是Message可复用的关键。看看他是怎么操作的 如果这个根sPool为空，则返回一个新的Message，Message的构造方法我看了，是个空的，所有的属性都在外部或者发送的那一刻设置。 如果不是空，那么表示可复用Message队列可用，则取出头部的MessageMessage m = sPool,同时指针向后移动一位sPool = m.next;此时m是等于sPool的，以此表示sPool后移一位，然后将取出的Message.next置为null，因为这个消息是要拿来发送的，他此时可是指向的可复用Message队列的头，所以将它的next置为null，不然会怎么样？我们看Looper源码时，循环何时终止呢，就是在next==null时终止，如果不置为null,for循环是不会停止的，会把空的Message队列遍历一遍。最后可复用的链表长度减一sPoolSize--; 其他的obtain方法我们不再去研究，大同小异吧。12345678910111213public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message();&#125; Message的回收方法 看一下代码，了解了上面说的机制，这个代码不难理解。解释一下，如何回收一个Message,要有一个概念就是Message调用该方法回收的是自己，首先将自己的next指向sPoolnext = sPool;也就是说。此时自己已经链接到了可复用的Message队列头部（每次都叫他。可复用的Message队列。真麻烦），然后sPool = this;sPool指针又指向了 可复用的Message队列头部，队列长度++完成了消息的回收。在Looper中提到的msg.recycleUnchecked();这个方法就是在这里实现的。 12345678910 void recycleUnchecked() &#123;.....//这里进行了好多代码，做了一个操作，将成员变量清空。 synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125; &#125; ###补充 Message实现了Parcelable接口表明它是可以传输的。 1public final class Message implements Parcelable &#123;&#125; MessageQueue类介绍 内部通过链接Message形成了一个消息队列，有两个比较核心的方法。boolean enqueueMessage(Message msg, long when){}和Message next()方法，Looper类中遗留的第二个问题Message msg = queue.next();会在这里解释。 入队方法 前面巴拉巴拉一通判断，内部的target不能是null,Message对象不能被占用，线程不能退出。。。。 这里的mMessages变量起到了与Message中sPool相同的作用，它是队列的指针，指向消息队列的头，只是这里维护的队列是要被处理的消息队列。但是由于sendMsgDelay方法的存在，入队时不能单纯的链接消息，还需要判断时间戳。 if (p == null || when == 0 || when &lt; p.when)这个判断if(是第一个消息 ||要被处理的时间是0 ||要被处理的时间小于当前队列头消息的时间也就是已经到达处理这个消息的时间)，此时将会将消息链接在队列头部msg.next = p;，同时指针指向它mMessages = msg;,并且此消息是不要被唤醒的needWake = mBlocked;,这个操作与Message中的操作十分相似，不多做介绍。 else语句块中表明此消息是一个延时消息，此时进行的操作是采用了一个for循环，完成的功能是找到这个消息被处理的时间when，大于这个时间的第一个消息，将它插入到该位置。如果没有找到会一直循环，最后找到preMsg指向的前一个消息和p = mMessage指向的后一消息，进行链接操作，msg.next = p; prev.next = msg;就是普通的链接操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950boolean enqueueMessage(Message msg, long when) &#123;if (msg.target == null) &#123;throw new IllegalArgumentException("Message must have a target.");&#125;if (msg.isInUse()) &#123;throw new IllegalStateException(msg + " This message is already in use.");&#125;synchronized (this) &#123;if (mQuitting) &#123;IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w("MessageQueue", e.getMessage(), e);msg.recycle();return false;&#125;//核心方法从这里开始msg.markInUse();msg.when = when;Message p = mMessages;boolean needWake;if (p == null || when == 0 || when &lt; p.when) &#123;// New head, wake up the event queue if blocked.msg.next = p;mMessages = msg;needWake = mBlocked;&#125; else &#123;// Inserted within the middle of the queue. Usually we don't have to wake// up the event queue unless there is a barrier at the head of the queue// and the message is the earliest asynchronous message in the queue.needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();Message prev;for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125;&#125;msg.next = p; // invariant: p == prev.nextprev.next = msg;&#125;// We can assume mPtr != 0 because mQuitting is false.if (needWake) &#123; nativeWake(mPtr);&#125;&#125;return true;&#125; 出队方法 之前在Looper.loop()方法中看到有这么一段代码,结合MessageQueue的出队方法，可以发现这是一个循环轮询消息队列的操作。在死循环中调用了Message msg = queue.next(); // might block方法，当返回msg==null，循环体结束，什么时候会结束，看next()方法中返回null的只有一种情况就是线程结束时，返回null，线程结束，他的Looper自然应该结束。 死循环实际是发生在MessageQueue中的，我在注释中写了说明。关于MessageQueue的很多本地方法的介绍，大家可以参考这里 12345Message msg = queue.next(); // might blockif (msg == null) &#123;// No message indicates that the message queue is quitting.return;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101Message next() &#123;//// Return here if the message loop has already quit and been disposed.// This can happen if the application tries to restart a looper after quit// which is not supported.final long ptr = mPtr;if (ptr == 0) &#123; return null;&#125;int pendingIdleHandlerCount = -1; // -1 only during first iteration//超时时间int nextPollTimeoutMillis = 0;//开始循环取出消息for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands();&#125;nativePollOnce(ptr, nextPollTimeoutMillis);//接下来进行锁定，开始取出消息synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; //取到消息是空，然后进行一个循环查找下一个可用消息 if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125;if (msg != null) &#123; if (now &lt; msg.when) &#123;// Next message is not ready. Set a timeout to wake up when it is ready.//当前时间没有达到执行这个消息的时间。将会进行超时等待 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; //取出头部的消息返回 // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; return msg;&#125;&#125; else &#123; // No more messages. nextPollTimeoutMillis = -1;&#125;// Process the quit message now that all pending messages have been handled.//线程不存在时返回null，loop()也会随之结束if (mQuitting) &#123; dispose(); return null;&#125;// If first time idle, then get the number of idlers to run.// Idle handles only run if the queue is empty or if the first message// in the queue (possibly a barrier) is due to be handled in the future.if (pendingIdleHandlerCount &lt; 0&amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size();&#125;//死循环发生在这里，具体还没有很明白，需要再去研究if (pendingIdleHandlerCount &lt;= 0) &#123;// No idle handlers to run. Loop and wait some more. mBlocked = true;continue;&#125;if (mPendingIdleHandlers == null) &#123;mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];&#125;mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);&#125;// Run the idle handlers.// We only ever reach this code block during the first iteration.for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handlerboolean keep = false;try &#123; keep = idler.queueIdle();&#125; catch (Throwable t) &#123;Log.wtf("MessageQueue", "IdleHandler threw exception", t);&#125;if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125;&#125;&#125;// Reset the idle handler count to 0 so we do not run them again.pendingIdleHandlerCount = 0;// While calling an idle handler, a new message could have been delivered// so go back and look again for a pending message without waiting.nextPollTimeoutMillis = 0; &#125;&#125; Handler类成员变量12345678//从这里看得出Handler很好的连接了Looper和MessageQueuefinal MessageQueue mQueue;final Looper mLooper;//这是一个接口，用来处理消息，下面是具体实现，也是我们通常要实现的方法。final Callback mCallback;public interface Callback &#123; public boolean handleMessage(Message msg);&#125; 构造方法 重载了多个构造方法，老规矩，我们只看没有最底层的构造方法和我们最常用的构造方法 123456789101112131415161718//常用空参构造方法public Handler() &#123; this(null, false);&#125;//根构造方法public Handler(Callback callback, boolean async) &#123;//获得当前线程的Looper，大家还记得Looper.myLooper()方法吧，return sThreadLocal.get();mLooper = Looper.myLooper();if (mLooper == null) &#123;//必须先调用Looper.prepare()throw new RuntimeException("Can't create handler inside thread that has not called Looper.prepare()");&#125;//拿到Looper的MessageQueue,这个MessageQueue是Looper创建的。mQueue = mLooper.mQueue;//这个是回调，用来处理消息mCallback = callback;mAsynchronous = async;&#125; 成员方法 obtain()方法，这个方法不做解释，返回的是Message的obtain()方法，详细请看Message类的分析。 发送消息，我们浏览一下所有发送消息的方法。方法很多，大致的思想是，填充消息，发送消息，很多方法都是重载互相调用的，关注最后一个方法，它调用了MessageQueue的入队方法，同时将msg.target设置为this,将这个消息插入到了队列中，也就是被发送的Message持有发送它的Handler的引用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//以下是各种发送消息的方法，可以浏览一下。public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;public final boolean postAtTime(Runnable r, long uptimeMillis)&#123; return sendMessageAtTime(getPostMessage(r), uptimeMillis);&#125;public final boolean postAtTime(Runnable r, Object token, long uptimeMillis)&#123; return sendMessageAtTime(getPostMessage(r, token), uptimeMillis);&#125;public final boolean postDelayed(Runnable r, long delayMillis)&#123; return sendMessageDelayed(getPostMessage(r), delayMillis);&#125;public final boolean postAtFrontOfQueue(Runnable r)&#123; return sendMessageAtFrontOfQueue(getPostMessage(r));&#125;public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendEmptyMessage(int what)&#123; return sendEmptyMessageDelayed(what, 0);&#125;public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis);&#125;public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageAtTime(msg, uptimeMillis);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123;delayMillis = 0;&#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException(this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;public final boolean sendMessageAtFrontOfQueue(Message msg) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException(this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, 0);&#125;//这两个方法是发送Runnable任务时会调用的方法private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125;private static Message getPostMessage(Runnable r, Object token) &#123; Message m = Message.obtain(); m.obj = token; m.callback = r; return m;&#125;//消息入队，同时Message将会持有发送它的Handler的引用private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123;msg.setAsynchronous(true);&#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 事件分发与处理 还记得Looper中遗留的问题吗？msg.target.dispatchMessage(msg);结合发送消息的方法，可以得出，msg.target就是发送它的那个Handler,处理消息时调用dispatchMessage方法，也就是下面的方法，所以，Message携带它的发送者，谁发送的消息誰来处理它。 分析一下下面的逻辑。msg.callback是消息中包含的任务，如果是一个任务的消息，那么不需要外部处理，直接调用该Runnable任务的run方法，所以还是在当前线程执行，并没有开启新的线程，不要看到Runnable就想到线程，这也是我以前的一个误区 不是一个Runnable任务，mCallback是一个接口，在介绍成员变量是提到过，他可以通过构造方法在外部实现，当然不是必须实现的，如果实现了这个接口，那么调用这个接口的mCallback.handleMessage(msg)方法处理消息。 如果没有实现这个接口，则调用handleMessage(msg);方法，这个方法是空的，需要你在子类中重载，如果你没有重载他不会执行任何操作。这算提供了处理消息的两种方式。 1234567891011121314151617public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125;private static void handleCallback(Message message) &#123; message.callback.run();&#125;public void handleMessage(Message msg) &#123;&#125; ##总结 线程中Handler消息机制的使用,Looper类中给出了很好的示例代码。注意的是在非UI线程需要我们显式的调用Looper.prepare(); Looper.loop();方法来完成消息的轮询。 123456789101112class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop(); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SourceCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码分析]]></title>
    <url>%2Farticle%2F1697740661%2F</url>
    <content type="text"><![CDATA[开始看源代码了才知道android和java的源代码有好多出入，我把java和android源码比较了一下，相似的还是多的。我是以android源码为主，因为感觉android比较繁琐，不同的地方会贴java的代码对比。 java真的设计的很好，很多类内部实现差别很大，但是在外部看起来是一样的，比如LinkedList和ArrayList,设计良好的API使我们不需要去关注内部的实现，举个例子说，我们需要一个绳子，他可以是真丝制成的，那么它比较坚固，也可以是牛皮制成的，那么它可以不怕水，但是对使用绳子的人来说，他声明自己需要的绳子需要具有什么样的特性，但是他却不知道真丝的需要什么工艺，牛皮的又需要什么工艺。我们程序员就是使用绳子的人，各种各样的List就是绳子，虽然内部实现大相径庭，但是都对外开放了一条绳子的外表，使得我们可以极为方便的使用它，这体现了面向对象的编程思想，也可以使java程序员更加专注的实现功能而不尽量少的关心逻辑和算法。 ArrayList类 ArrayList内部基于数组实现,继承了AbstractList类，实现了Cloneable接口表示其可被克隆复制，实现了Serializable接口表示其可被序列化，实现了RandomAccess接口，表示其可快速随机访问（但是这个接口是空的，只是表示它具有这样的特性）。1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements Cloneable, Serializable, RandomAccess&#123;&#125; 一些常量和成员 android中提供了最小容量，java中并没有这个成员，而是使用了10这个数字作为初始容量。 1234567//anrdroid源码//最小容量private static final int MIN_CAPACITY_INCREMENT = 12;//元素数量int size;//对象数组，transient表示在序列化时它会被忽略。。啥意思？transient Object[] array; 初始化指定初始容量构造 首先容量大于0，如果容量==0会使用EmptyArray.OBJECT来初始化，在android的源码里面链接不到EmptyArray这个类，去了这个网站看到了源码，EmptyArray.OBJECT是一个容量是0的数组。所以也就是说，如果指定容量==0则创建一个容量是0的对象数组，反之创建一个指定容量大小的数组。(java中没有做这个判断，本来这个判断就什么用) 1234567//android 源码public ArrayList(int capacity) &#123; if (capacity &lt; 0) &#123; throw new IllegalArgumentException("capacity &lt; 0: " + capacity); &#125; array = (capacity == 0 ? EmptyArray.OBJECT : new Object[capacity]); &#125; 无参构造函数 同上，初始容量是0。但是java源码中初始容量是10。 12345678//android 源码 public ArrayList() &#123; array = EmptyArray.OBJECT; &#125; //java源码 public ArrayList() &#123;this(10); &#125; 初始化时拷贝集合 主要的操作是判断是不是一个对象数组，如果是直接内部数组直接指向，如果不是进行一次拷贝，java中所有类都继承自Object。这是为了防止基本数据类型吗？（&lt;-这是我不懂的地方）用的方法不一样，java代码更少一点。 System.arraycopy()方法是native修饰的，使用C实现的底层方法。 Arrays.copyOf()函数内部也使用了System.arraycopy()方法。 就是我不懂的那个地方了,感觉使用这个方法可以解决不是对象数组的问题，但是不懂这个判断是为了什么，System.arraycopy又是如何内部实现的。 1234//android 源码if (a.getClass() != Object[].class) &#123;System.arraycopy(a, 0, newArray, 0, a.length);&#125; 1234567891011121314//android 源码public ArrayList(Collection&lt;? extends E&gt; collection) &#123; if (collection == null) &#123; throw new NullPointerException("collection == null"); &#125; Object[] a = collection.toArray(); if (a.getClass() != Object[].class) &#123; Object[] newArray = new Object[a.length]; System.arraycopy(a, 0, newArray, 0, a.length); a = newArray; &#125; array = a; size = a.length;&#125; 12345678//java源码public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; Add方法Android中的实现123456789101112131415161718192021222324252627282930313233343536@Override public boolean add(E object) &#123; Object[] a = array; int s = size; if (s == a.length) &#123; Object[] newArray = new Object[s + (s &lt; (MIN_CAPACITY_INCREMENT / 2) ? MIN_CAPACITY_INCREMENT : s &gt;&gt; 1)]; System.arraycopy(a, 0, newArray, 0, s); array = a = newArray; &#125; a[s] = object; size = s + 1; modCount++; return true; &#125; @Override public void add(int index, E object) &#123; Object[] a = array; int s = size; if (index &gt; s || index &lt; 0) &#123; throwIndexOutOfBoundsException(index, s); &#125; if (s &lt; a.length) &#123; System.arraycopy(a, index, a, index + 1, s - index); &#125; else &#123; // assert s == a.length; Object[] newArray = new Object[newCapacity(s)]; System.arraycopy(a, 0, newArray, 0, index); System.arraycopy(a, index, newArray, index + 1, s - index); array = a = newArray; &#125; a[index] = object; size = s + 1; modCount++; &#125; Java中的实现 跟android基本一样的，之所以代码简单了，是因为java将判断扩容的操作放在了方法实现，但是androd只是将计算新容量的方法提取出来了。 123456789101112131415public boolean add(E e) &#123; ensureCapacity(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125;public void add(int index, E element) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( "Index: "+index+", Size: "+size); ensureCapacity(size+1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; 核心代码分析 解释一下下面这段代码，在java中也是如此实现的只是提取到了方法中，会在下面的扩容机制中说明。 首先最后都进行了一个赋值操作a[index] = object;前面的代码的工作就是将这个位置空出来。代码5 如果当前的size没有超过length,则将index位置之后的位置向后移动一位，将index位置空出来（代码1），如果超过长度了，则进行一次扩容（代码2），将数据拷贝到新数组（代码3），再将数组后移一位（代码4） 它是怎么移动的呢？System.arraycopy(a, index, newArray, index + 1, s - index)了解参数的含义（src,源数组中开始复制的位置，dest,目标数组开始粘贴的位置，复制的长度），这样就明白了，包括代码1是一样的意思，a数组和newArray数组是相同的，将a中index开始的数据复制到newArray中index+1开始的位置，然后复制的长度是s-index,刚好index位置被空出来了，举个例子，数据a={21，22，23，25，26}，newArray={21，22，23，25，26},需要在3的位置插入一个24，则将3开始的size-index(5-3=2)长度的数组也就是25，26，复制到newArray中index+1(3+1=4)开始的位置，得到新数组21，22，23，空，25，26，然后array[3]=24; 123456789101112Object[] a = array;int s = size;if (s &lt; a.length) &#123;System.arraycopy(a, index, a, index + 1, s - index);//---1&#125; else &#123; Object[] newArray = new Object[newCapacity(s)];//---2System.arraycopy(a, 0, newArray, 0, index);//---3System.arraycopy(a, index, newArray, index + 1, s - index);//---4array = a = newArray;&#125;a[index] = object;//5size = s + 1; 扩容机制 单独拿出来是因为android和java扩容机制稍有不同 Android中的实现 扩容时，如果当前容量小于6则让其等于12，否则扩大为原来的两倍。 12345678private static int newCapacity(int currentCapacity) &#123;int increment = (currentCapacity &lt; (MIN_CAPACITY_INCREMENT / 2) ?MIN_CAPACITY_INCREMENT : currentCapacity &gt;&gt; 1);return currentCapacity + increment;&#125;//这只是计算了新的容量，真正的扩容如此实现Object[] newArray = new Object[newCapacity(s)];System.arraycopy(a, 0, newArray, 0, index); java中的实现, java中数组拷贝都是用Arrays.copyOf()方法的，基本原理相同。 可以发现java扩容将容量扩大到了原来容量的1.5倍。 这里有一行代码,看注释的意思是这个方法更加优化了，调皮的程序员a.大意是minCapacity 通常更加逼近size. 1if (newCapacity &lt; minCapacity) newCapacity = minCapacity; 123456789101112public void ensureCapacity(int minCapacity) &#123; modCount++; int oldCapacity = elementData.length; if (minCapacity &gt; oldCapacity) &#123; Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; if (newCapacity &lt; minCapacity) newCapacity = minCapacity; // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125;&#125; 综上 就是核心方法了吧，已经可以了解到它基本的原理，当然还有indexOf(),contains(),remove(),writeObject(),readObject(),内部迭代器的实现，toArray()的实现，set(),addAll()…..其中的原理与上面提到的很多都是相同的，感兴趣的可以自行了解，这里不介绍了，后面有时间再贴一下吧。]]></content>
      <categories>
        <category>Study</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SourceCode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView Adapter 3]]></title>
    <url>%2Farticle%2F294185431%2F</url>
    <content type="text"><![CDATA[前言 上一篇文章介绍了如何进行分类适配，虽然比较完美的实现了分类适配以及复用，但是代码相当繁琐，我们有两种类型时已经出现了多层if嵌套，如果有三四种类型，估计自己都要转晕了，而且就像我们对单类型适配器抽象时做的，避免重复代码！如果没看过上一篇，建议浏览一下，这里写的很多都是基于第一篇的。 抽象ViewHolder12345678910111213141516171819202122232425public static class MultiViewHolder extends ViewHolder&#123; /** * SparseArray */ private SparseArray&lt;View&gt; cacheViews; private View itemView; public MultiViewHolder(View itemView, int viewCount) &#123; super(); this.itemView = itemView; cacheViews = new SparseArray&lt;View&gt;(viewCount); &#125; @Override public View getView(int resId) &#123; View v = cacheViews.get(resId); if (v == null) &#123; v = itemView.findViewById(resId); if (v != null) &#123; cacheViews.put(resId, v); &#125; &#125; return v; &#125;&#125; 使用接口获取对象的类型 我们在分类适配的时候不可避免的要获得数据的对象，以此作为根据装载不同的布局文件. 123456789/** 1. 接口，分类适配的对象需要实现的接口，目的是约束实体类实现getType方法 2. 3. @author chendong 4. */public interface MultiEasyAdapterInterface &#123; public int getType();&#125; 抽象分类适配器 我们需要避免在子类中避免重复编码，同时在子类实现自己的方法，使用抽象父类。 我们不了解传递进来的数据是什么类型，使用泛型。 我们需要限制传进来的数据必须实现获得获得子类的方法，所以必须要求数据实现MultiEasyAdapterInterface接口，使用泛型限定符确定上限。 12public abstract class MultiEasyAdapter&lt;T extends MultiEasyAdapterInterface&gt; extends BaseAdapter &#123;&#125; 成员变量12private LayoutInflater layoutInflater;private List&lt;T&gt; datas; 分析一下其他成员，根据上一篇传统分类适配的写法，我们姑且忽略类型的差异 每个类型需要一个布局资源文件id 每个类型布局文件中字UI控件的个数（用来优化） 每个类型一个唯一的键值（用来解决复用Item空指针的问题） 我们用一个实体类存储这些信息 123456789101112131415161718192021222324252627282930** * 存储类型信息的实体类 * * @author chendong * @功能：分类适配器配置信息实体类 */public class MultiEasyAdapterEntity &#123; /** * @param type * item类型，int类型变量，Item是什么类型的就填写什么类型 * @param resId * 资源id，对应类型的资源id，你需要装载的资源文件的ID * @param viewCount * 资源文件中对应的需要获取的视图的个数 */ public MultiEasyAdapterEntity(int type, int resId, int viewCount) &#123; super(); this.resId = resId; this.viewCount = viewCount; &#125; private int type; private int resId; private int viewCount; public MultiEasyAdapterEntity() &#123; super(); &#125;&#125; 可能有点繁琐，type和viewCount 可以省略掉，加入type是为了更灵活的获得数据类型，viewCount则是为了优化SparseArray,综上第三个成员变量，就是使用type作为键，MultiEasyAdapterEntity作为值的一个SparseArray，他的作用就是存储不同类型的数据适配时需要的配置信息，有点类似配置文件的意思。 1private SparseArray&lt;MultiEasyAdapterEntity&gt; Res4Type; 完善代码 结合分类适配的方法，变量我们已经存储到了SparseArray中，所以代码就很清晰了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * version 2&lt;br/&gt;注意事项：类型数为n时，那么定义的类型必须在0-n-1之间，这是使用listview自带缓存的要求。 * 抽象适配器升级版，可以进行分类适配，使用了模板方法模式，将设置item显示内容的部分抽象到了类外&lt;br/&gt; * @param &lt;T&gt; &lt;br/&gt;必须实现MultiEasyAdapterInterface接口&#123;@link MultiEasyAdapterInterface&#125;&lt;br/&gt; * @author chendong */public abstract class MultiEasyAdapter&lt;T extends MultiEasyAdapterInterface&gt; extends BaseAdapter &#123; private LayoutInflater layoutInflater; private List&lt;T&gt; datas; private SparseArray&lt;MultiEasyAdapterEntity&gt; Res4Type; private Context context; /** * @param context 上下文对象 * @param datas 数据集 * @param Res4Type 资源配置文件&#123;@link MultiEasyAdapterEntity&#125;this is like a config entity */ public MultiEasyAdapter(Context context, List&lt;T&gt; datas, SparseArray&lt;MultiEasyAdapterEntity&gt; Res4Type) &#123; super(); this.layoutInflater = LayoutInflater.from(context); this.datas = datas; this.Res4Type = Res4Type; this.context = context; &#125; protected Context getContext()&#123; return context; &#125; protected List&lt;T&gt; getDatas()&#123; return datas; &#125; public void swapData(List&lt;T&gt; datas)&#123; this.datas = datas; notifyDataSetChanged(); &#125; @Override public int getViewTypeCount() &#123; return Res4Type.size(); &#125; @Override public int getItemViewType(int position) &#123; return datas.get(position).getType(); &#125; public int getCount() &#123; return datas.size(); &#125; public Object getItem(int position) &#123; return datas.get(position); &#125; public long getItemId(int position) &#123; return position; &#125; public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; /* get the type*/ int type = datas.get(position).getType(); if (convertView == null) &#123; int resId = Res4Type.get(type).getResId(); convertView = layoutInflater.inflate(resId, parent, false); holder = new ViewHolder(convertView, Res4Type.get(type) .getViewCount()); convertView.setTag(holder); bindListener4View(holder,datas.get(position), type, position); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; bindData4View(holder,datas.get(position), type, position); return convertView; &#125; /** * 绑定数据 * bind data * * @param holder the viewholder * @param type data&apos;s type * @param data data */ public abstract void bindData4View(ViewHolder holder, T data, int type,int pos); /** * 绑定监听 * bind listener * * @param holder the viewholder * @param type data&apos;s type * @param pos position */ public abstract void bindListener4View(ViewHolder holder, T data, int type,int pos);&#125; 测试1234567891011121314151617181920212223242526272829303132333435363738listview = (ListView) findViewById(R.id.listview); list = new ArrayList&lt;Student&gt;(); for (int i = 0; i &lt; 20; i++) &#123; if (i % 5 == 0) list.add(new Student(&quot;name&quot; + i, &quot;age&quot; + i, &quot;sex&quot;, 3)); else list.add(new Student(&quot;name&quot; + i, &quot;age&quot; + i, &quot;sex&quot;, i % 2 == 0 ? 1 : 2)); &#125; SparseArray&lt;MultiEasyAdapterEntity&gt; sparseArray = new SparseArray&lt;MultiEasyAdapterEntity&gt;( 3); sparseArray.put(1, new MultiEasyAdapterEntity(1, R.layout.item_type1, 4)); sparseArray.put(2, new MultiEasyAdapterEntity(2, R.layout.item_type2, 4)); sparseArray.put(3, new MultiEasyAdapterEntity(3, R.layout.item_type3, 4)); listview.setAdapter(new MultiEasyAdapter&lt;Student&gt;( getApplicationContext(), list, sparseArray) &#123; @Override public void bindData4View(ViewHolder holder, Student data, int type) &#123; ((TextView) holder.getView(R.id.tv_name)).setText(data .getName()); ((TextView) holder.getView(R.id.tv_sex)).setText(data.getSex()); ((TextView) holder.getView(R.id.tv_age)).setText(data.getAge() + &quot;&quot;); if (type == 3) ((TextView) holder.getView(R.id.tv_type)).setText(data .getType()+&quot;&quot;); &#125;@Override public void bindListener4View(ViewHolder holder, Student data, int type) &#123; //绑定监听事件 &#125; &#125;); 效果 大家可以看到三中布局适配的没有问题，只有蓝色背景的布局显示了type,他是类型3的数据]]></content>
      <categories>
        <category>Android</category>
        <category>Adapter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ListView</tag>
        <tag>Adapter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView Adapter 2]]></title>
    <url>%2Farticle%2F1720703307%2F</url>
    <content type="text"><![CDATA[前言 在使用适配器为ListView填充数据时，数据类型往往不是单一的，单一的数据显示太单调，对数据格式要求也比较高，我们在项目中往往使用网络请求获取json数据然后将其显示在Item中，此时获取的数据类型可能会有两到三种格式，此时就用到了分类适配，使用分类适配可以更加友好显示ListView。 既然需要分类适配，我们就必须拿到数据的类型，你的数据也就必须直接或者间接的实现获取类型的方法，其实ListView中已经包含了这个获取类型的方法，当然你也可以使用自己的获取类型的方法。 12345678910//重写以下两个方法，listview在内部会准备getViewTypeCount()个缓冲区，用来复用同种类型的View,不同类型的View不会出现复用错误。@Overridepublic int getItemViewType(int position) &#123; int type = Integer.parseInt(newsEntities.get(position).getType()); return type;&#125;@Overridepublic int getViewTypeCount() &#123; return count;&#125; 进行分类适配12345678910111213141516171819202122232425262728293031323334public View getView(int position, View convertView, ViewGroup parent) &#123; if (getItemViewType(position) == 1) &#123; ViewHolderVertical holder = null; if (convertView == null) &#123; convertView = layoutInflater.inflate( R.layout.item_firstpagelist_vertical, parent, false); holder = new ViewHolderVertical(); holder.iv = (ImageView) convertView .findViewById(R.id.item_firstpagelist_vertical_iv); //获取其他的控件.... convertView.setTag(holder); &#125; else &#123; holder = (ViewHolderVertical) convertView.getTag(); &#125; NewsEntity entity = newsEntities.get(position); //为控件设置显示的数据.... &#125; else &#123; ViewHolder holder = null; if (convertView == null) &#123; convertView = layoutInflater.inflate( R.layout.item_firstpagelist_horizontal, parent, false); holder = new ViewHolder(); holder.iv = (ImageView) convertView .findViewById(R.id.item_firstpagelist_iv); //获取其他的控件.... convertView.setTag(holder); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; NewsEntity entity = newsEntities.get(position); //为控件设置显示的数据.... &#125; return convertView; &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Adapter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ListView</tag>
        <tag>Adapter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView Adapter 1]]></title>
    <url>%2Farticle%2F4287006971%2F</url>
    <content type="text"><![CDATA[前言 介绍一下适配器的抽象，在我们做项目的时候会有很多很多地方使用ListView，也就意味着需要写很多很多的适配器，当我们写的项目很大时就会很烦很烦，每次都要写同样的代码片实现类似的功能，所以我们就有必要对传统的适配器抽象一下。 传统适配器的优化写法 核心代码就是getVIew()方法，在里面我们进行Item的复用，而相对于其他方法就会显得很多余，因为每个适配器都在重复相同的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class FirstpageGridAdapter extends BaseAdapter &#123; /* gridview数据 */ private String[] choices = new String[] &#123; &quot;新房&quot;, &quot;二手房&quot;, &quot;租房&quot;, &quot;资讯&quot;, &quot;打折优惠&quot;, &quot;最新开盘&quot;, &quot;房贷计算&quot;, &quot;更多&quot; &#125;; private int[] images = new int[] &#123; R.drawable.selector_xinfang, R.drawable.selector_ershou, R.drawable.selector_zufang, R.drawable.selector_zixun, R.drawable.selector_youhui, R.drawable.selector_kaipan, R.drawable.selector_calculator, R.drawable.selector_more &#125;; private LayoutInflater layoutInflater; private onClickChildIbListener listener; public FirstpageGridAdapter(Context context, onClickChildIbListener listener) &#123; super(); this.layoutInflater = LayoutInflater.from(context); this.listener = listener; &#125; public interface onClickChildIbListener &#123; public void clickChild(int pos,View view); &#125; public int getCount() &#123; return choices.length; &#125; public Object getItem(int position) &#123; return choices[position]; &#125; public long getItemId(int position) &#123; return position; &#125; public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; if (convertView == null) &#123; holder = new ViewHolder(); convertView = layoutInflater.inflate(R.layout.item_main_grid, parent, false); holder.ib = (ImageButton) convertView .findViewById(R.id.item_main_grid_ib); holder.tv = (TextView) convertView .findViewById(R.id.item_main_grid_tv); convertView.setTag(holder); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; holder.ib.setBackgroundResource(images[position]); holder.tv.setText(choices[position]); final int pos = position; holder.ib.setOnClickListener(new OnClickListener() &#123; public void onClick(View v) &#123; listener.clickChild(pos,v); &#125; &#125;); return convertView; &#125; private class ViewHolder &#123; ImageButton ib; TextView tv; &#125;&#125; 抽象ViewHolder 我们可以分析一下ViewHolder类，它维护一个Item的一组UI组件，如果我们要使用使用通用的ViewHolder就会遇到一个问题，你不知道不同的布局有什么组件在里面，如何维护一组UI呢，数组？链表？或者Map?当查找View时我们使用id来进行查找，那么想在ViewHolder中查找View就需要使用id作为键，我们选择使用SparseArray，也就是稀疏数组，什么是稀疏数组，使用id（大整数）作为键值存储数据会造成大多数的未被使用，如果使用一般的表存储会造成很大的浪费，稀疏数组对数组进行了压缩，节约了很大空间，详见这里 1private SparseArray&lt;View&gt; cacheViews; 使用稀疏数组存储UI控件以后我们需要一个获取UI控件的方法，方法很清晰的，itemView是传递进来的父控件，就是convertView从中根据id获取控件 1234567891011@Override public View getView(int resId) &#123; View v = cacheViews.get(resId); if (v == null) &#123; v = itemView.findViewById(resId); if (v != null) &#123; cacheViews.put(resId, v); &#125; &#125; return v; &#125; ViewHolder完整代码，这里传入了一个viewCount,为什么呢？就像ArrayList一样，不定义空间大小时初始容量16，超出空间大小时每次增加25，但就是初始容量的16对于我们来说已经是浪费了，一个Item不可能有16个控件那么多。指定大小提高内存使用。 12345678910111213141516171819202122232425262728293031/** * * @author chendong * 用来实现复用加载的单类型ViewHolder * */ public static class SingleViewHolder&#123; /** * 使用SparseArray */ private SparseArray&lt;View&gt; cacheViews; private View itemView; public SingleViewHolder(View itemView, int viewCount) &#123; super(); this.itemView = itemView; cacheViews = new SparseArray&lt;View&gt;(viewCount); &#125; @Override public View getView(int resId) &#123; View v = cacheViews.get(resId); if (v == null) &#123; v = itemView.findViewById(resId); if (v != null) &#123; cacheViews.put(resId, v); &#125; &#125; return v; &#125; &#125; 抽象适配器 传统的适配器有太多的重复代码需要编写，我们可以把重复的代码在父类中编写好，使得子类可以直接复用，！使用抽象父类 父类的getView()方法中使用了一个抽象方法，使用了一个设计模式模板方法模式，将方法的实现推迟到了子类中 泛型，传递的数据类型是不确定的，使用泛型可以解决这个问题，泛型的使用不了解的建议搜一下，后面深入的介绍会使用更复杂的泛型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** 1. 抽象适配器，使用了模板方法模式，将设置item显示内容的部分抽象到了类外 这是单类型的抽象适配 2. 3. @author chendong 4. 5. @param &lt;T&gt; 6. 泛型 */public abstract class SingleEasyAdapter&lt;T&gt; extends BaseAdapter &#123; private LayoutInflater layoutInflater; private int resId; private List&lt;T&gt; datas; private int viewCount = 5; /** * @param context * 上下文对象，建议使用getApplicationContext(); * @param resId * item布局id * @param datas * 数据集 * @param viewCount * item中的view个数，用来优化SparseArray&lt;View&gt; */ public SingleEasyAdapter(Context context, int resId, List&lt;T&gt; datas, int viewCount) &#123; super(); this.layoutInflater = LayoutInflater.from(context); this.resId = resId; this.datas = datas; this.viewCount = viewCount; &#125; public int getCount() &#123; return datas.size(); &#125; public Object getItem(int position) &#123; return datas.get(position); &#125; public long getItemId(int position) &#123; return position; &#125; public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; if (convertView == null) &#123; convertView = layoutInflater.inflate(resId, parent, false); holder = new ViewHolder(convertView, viewCount); convertView.setTag(holder); //在这里绑定监听，避免重复绑定。 bindListener4View(holder, datas.get(position), position); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; bindData4View(holder, datas.get(position), position); return convertView; &#125; /** * 绑定数据 * * @param holder * @param data */ public abstract void bindData4View(ViewHolder holder, T data, int pos); /** * 绑定监听 * * @param holder * @param pos */ public abstract void bindListener4View(ViewHolder holder, T data, int pos); &#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * 抽象适配器，使用了模板方法模式，将设置item显示内容的部分抽象到了类外 这是单类型的抽象适配 * * @param &lt;T&gt; 泛型 * @author chendong */public abstract class SingleEasyAdapter&lt;T&gt; extends BaseAdapter &#123; private LayoutInflater layoutInflater; private int resId; private List&lt;T&gt; datas; private int viewCount = 5; private Context context; /** * @param context 上下文对象，建议使用getApplicationContext(); * @param resId item布局id * @param datas 数据集 * @param viewCount item中的view个数，用来优化SparseArray&lt;View&gt; */ public SingleEasyAdapter(Context context, int resId, List&lt;T&gt; datas, int viewCount) &#123; super(); this.layoutInflater = LayoutInflater.from(context); this.resId = resId; this.datas = datas; this.viewCount = viewCount; this.context = context; &#125; public Context getContext() &#123; return this.context; &#125; public List&lt;T&gt; getData() &#123; return datas; &#125; public void swapData(List&lt;T&gt; datas) &#123; this.datas = datas; notifyDataSetChanged(); &#125; public int getCount() &#123; return datas.size(); &#125; public Object getItem(int position) &#123; return datas.get(position); &#125; public long getItemId(int position) &#123; return position; &#125; public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; if (convertView == null) &#123; convertView = layoutInflater.inflate(resId, parent, false); holder = new ViewHolder(convertView, viewCount); convertView.setTag(holder); //在这里绑定监听 bindListener4View(holder, datas.get(position), position); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; bindData4View(holder, datas.get(position), position); return convertView; &#125; /** * 绑定数据 * * @param holder * @param data */ public abstract void bindData4View(ViewHolder holder, T data, int pos); /** * 绑定监听 * * @param holder * @param pos */ public abstract void bindListener4View(ViewHolder holder, T data, int pos);&#125; 测试123456789101112131415161718192021222324listview = (ListView) findViewById(R.id.listview); list = new ArrayList&lt;Student&gt;(); for (int i = 0; i &lt; 20; i++) &#123; if (i % 5 == 0) list.add(new Student(&quot;name&quot; + i, &quot;age&quot; + i, &quot;sex&quot;, 3)); else list.add(new Student(&quot;name&quot; + i, &quot;age&quot; + i, &quot;sex&quot;, i % 2 == 0 ? 1 : 2)); &#125; listview.setAdapter(new SingleEasyAdapter&lt;Student&gt;( getApplicationContext(), R.layout.item_type1, list, 4) &#123; @Override public void bindData4View(SingleViewHolder holder, Student data，int pos) &#123; ((TextView)holder.getView(R.id.tv_name)).setText(data.getName()); //此处省略若干代码 &#125;@Override public void bindListener4View(SingleViewHolder holder, Student data，int pos) &#123; //此处省略若干代码 &#125; &#125;); 效果 可以看到我们只用了很少的代码就完成了功能，而且很清晰，简单地适配不需要创建适配器类了，使用匿名的也很快就可以实现。演示有点丑，基本都实现了。 总结 将适配器抽象出来作为一个类库，再使用的时候就会简单很多很多，当然如果你的适配器数据很复杂，那么也可以继承抽象父类生成自己的类。!]]></content>
      <categories>
        <category>Android</category>
        <category>Adapter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ListView</tag>
        <tag>Adapter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap源码分析]]></title>
    <url>%2Farticle%2F1753510098%2F</url>
    <content type="text"><![CDATA[对HashMap源码的简单分析 前言 基本的数据结构有，数组，链表，树，图。 数组的特点是长度固定，空间连续，占用内存很大，空间复杂度是O(n),但是寻址容易，时间复杂度O(1).总结：寻址容易，插入删除困难。 链表的特点是长度可变，存储空间离散，占用内存小，空间复杂度是O(1),但是寻址困难，时间复杂度为O(n).总结：寻址困难，插入删除容易。 哈希表基于数组结构，采用键值的方式存储数据，插入删除容易，寻址是根据键值直接查找数据，时间复杂度是O(1)，但是使用哈希值存储数据总会出现哈希冲突，解决哈希冲突的方法主要有，开放定址法（再散列），再哈希法，链地址法（拉链法），建立公共溢出区。 缺点：存储空间填满时需要将其复制到另一个更大的数组结构中，并进行再哈希计算，这是哈希表内存占用的暴涨点，这是基于数组结构的一个缺点。 哈希表不能以一种特定的顺序遍历数据结构中的所有数据，如果需要按序存储，使用哈希表并不合适 介绍 HashMap是线程不安全的HashTable是线程安全的。 HashMap就是基于链地址法实现的数据存储。也就是链表的数组。 HashMap允许键 值 为null。HashTable是不允许的。 在Android和Java里面对HashMap的实现，稍有不同，开始我还以为是我的jdk有问题。 在HashMap的基础数组中，每一个数组项称之为一个桶，HashMap就是基于这种桶+链表的结构。 存储方式，使用key值取哈希，一般的算法是hash(key)/len获得他存放位置的下标，这样就将key与下标对应起来。 存储的数据结构 总结来说，HashMap就是数组+内部类（Entry）实现，Entry中具有下一个Entry的引用，由此构成了链表的结构。之前看过有人介绍说是Set+静态内部类，其实并不是。第一行的代码是用来对HashMap进行操作时使用的变量，比如迭代HashMap所有的子项，添加一个EntrySet到HashMap中，删除，修改。。。。 12private transient Set&lt;Entry&lt;K, V&gt;&gt; entrySet;transient HashMapEntry&lt;K, V&gt;[] table; HashMapEntry HashMap中有一个很重要的存储结构HashMapEntry,用来保存键值对，和下一个Entry的引用，这就形成了一个链表结构。 在Java中，这个静态内部类叫Entry,在android中叫HashMapEntry，在功能上应该是相似的。是一个存储数据的基础bean,关注一下源码： 123456789101112131415161718192021222324252627282930313233343536373839static class HashMapEntry&lt;K, V&gt; implements Entry&lt;K, V&gt; &#123; final K key; V value; final int hash; HashMapEntry&lt;K, V&gt; next; HashMapEntry(K key, V value, int hash, HashMapEntry&lt;K, V&gt; next) &#123; this.key = key; this.value = value; this.hash = hash; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V value) &#123; V oldValue = this.value; this.value = value; return oldValue; &#125; @Override public final boolean equals(Object o) &#123; if (!(o instanceof Entry)) &#123; return false; &#125; Entry&lt;?, ?&gt; e = (Entry&lt;?, ?&gt;) o; return Objects.equal(e.getKey(), key) &amp;&amp; Objects.equal(e.getValue(), value); &#125; @Override public final int hashCode() &#123; return (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode()); &#125; @Override public final String toString() &#123; return key + "=" + value; &#125;&#125; 哈希值的计算 存储数据是根据key的哈希值来存储的，类似这样的方法hash(key.hashcode()) Java和Android中对求哈希值的操作相似但是哈希算法不同，当进行存取操作时，key都需要使用这个算法进行中转。 在Android中使用的是Collections类下的静态方法及进行哈希计算，但是这里的h是key的hashcode(),看注释使用的是Wang/Jenkins哈希算法的变体,源代码： 1234567891011//java实现private static int secondaryHash(int h) &#123; // Spread bits to regularize both segment and index locations, // using variant of single-word Wang/Jenkins hash. h += (h &lt;&lt; 15) ^ 0xffffcd7d; h ^= (h &gt;&gt;&gt; 10); h += (h &lt;&lt; 3); h ^= (h &gt;&gt;&gt; 6); h += (h &lt;&lt; 2) + (h &lt;&lt; 14); return h ^ (h &gt;&gt;&gt; 16);&#125; 12345678//android实现static int hash(int h) &#123; // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; put方法 检查键值是否为空，null时将存储到forNullEntry所在的链表中。 获取哈希值之后获得下标索引，检查key是否已经存在，是则替换，否则添加到当前链表，基本思想是这样的，几个不同的点 putForNullKey(value)方法，在Android和Java中都有实现，当键值为null时，分配一个数组的一项，这个数组指向key == null 的Entry 一个不同点，Java中是在添加Entry之后重新计算容量，而Android是在AddNewEntry之前进行。 扩容的方法都是扩大为原来的两倍。 在Android中的实现基本类似，使用Collections静态方法进行二次哈希计算，计算下表索引 123456789101112131415161718192021222324252627282930313233//在java中的实现代码:public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); int hash = hash(key.hashCode()); //计算hash值，使用indexFor（）这个函数获得该哈希值对应数组下标，由此可以得到对应的那个链表。 int i = indexFor(hash, table.length ); for (Entry&lt;K,V&gt; e = table [i]; e != null; e = e.next) &#123; Object k; //关注这部分代码是替换掉已经存在的key对应的value if (e.hash == hash &amp;&amp; ((k = e.key ) == key || key.equals(k))) &#123; V oldValue = e. value; e. value = value; e.recordAccess( this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null ; &#125; //解释一下这部分代码，做的操作就是将新添加的Entry放在链表的头部，而原来的链表会接在这个新的Entry后面。void addEntry(int hash, K key, V value, int bucketIndex) &#123;//注意这里的bucketIndex是上一个函数得到的数组下标。取到该数组项链接的Entry给了临时变量eEntry&lt;K,V&gt; e = table [bucketIndex];//新建了一个Entry将其链接到了数组项上，然后把e给了新的Entry的Next,也就是后面的链表重新链接到了新的Entry后面，而新的Entry作为了该链表的第一项。table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);//添加之后重新计算容量。if (size ++ &gt;= threshold) resize(2 * table.length );&#125; 12345678910111213141516171819202122232425262728293031//android中的实现@Override public V put(K key, V value) &#123; if (key == null) &#123; return putValueForNullKey(value); &#125; int hash = Collections.secondaryHash(key); HashMapEntry&lt;K, V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); for (HashMapEntry&lt;K, V&gt; e = tab[index]; e != null; e = e.next) &#123; if (e.hash == hash &amp;&amp; key.equals(e.key)) &#123; preModify(e); V oldValue = e.value; e.value = value; return oldValue; &#125; &#125; // No entry for (non-null) key is present; create one modCount++; //注意这里是先进行扩容后进行添加的 if (size++ &gt; threshold) &#123; tab = doubleCapacity(); index = hash &amp; (tab.length - 1); &#125; addNewEntry(key, value, hash, index); return null;&#125;//Android添加代码就更简单了，不过也很好理解，操作与java中是一样的。不过方法很巧//妙，简化了代码，让我想起了InputStream is = new FileInputStream("path")is = new BufferedInputStream(is)`void addNewEntry(K key, V value, int hash, int index) &#123;table[index] = new HashMapEntry&lt;K, V&gt;(key, value, hash, table[index]);&#125; get方法 同样的获取hashcode,再哈希计算哈希值，获得下标索引，得到对应链表，遍历链表得到结果，在Java和Android中实现大同小异. 1234567891011121314//java中的实现public V get(Object key) &#123; if (key == null) return getForNullKey(); int hash = hash(key.hashCode()); for (Entry&lt;K,V&gt; e = table [indexFor(hash, table.length )]; e != null; e = e. next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value ; &#125; return null; &#125; 123456789101112131415161718//Android中的实现public V get(Object key) &#123; if (key == null) &#123; HashMapEntry&lt;K, V&gt; e = entryForNullKey; return e == null ? null : e.value; &#125; int hash = Collections.secondaryHash(key); HashMapEntry&lt;K, V&gt;[] tab = table; for (HashMapEntry&lt;K, V&gt; e = tab[hash &amp; (tab.length - 1)]; e != null; e = e.next) &#123; K eKey = e.key; if (eKey == key || (e.hash == hash &amp;&amp; key.equals(eKey))) &#123; return e.value; &#125; &#125; return null;&#125; 初始化 在Java和Android中HashMap的初始化略有不同,Android中初始容量是2，Java中初始容量是16。 Java实现 Java中的初始容量和负载因子是学习Java比较经典的内容，看一下Java中HashMap的默认构造方法 123456789static final int DEFAULT_INITIAL_CAPACITY = 16;static final float DEFAULT_LOAD_FACTOR = 0.75f;public HashMap() &#123;//默认的构造方法会初始化一个容量是16，负载因子0.75的HashMap,threshold有阈值的意思，就是当前容量可以承受的负载,当超过这个负载时就会进行扩容。this.loadFactor = DEFAULT_LOAD_FACTOR;threshold = (int )(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR );table = new Entry[DEFAULT_INITIAL_CAPACITY];init();&#125; 带有参数的构造方法实现 12345678910111213141516171819202122232425262728293031323334//指定容量和负载因子时会检查容量和负载因子的值是不是有问题//然后会进行一个位运算算法获得-》大于当前要求的容量的-》最小的2的幂//（也就是如果是7--》8如果是9--》16）public HashMap(int initialCapacity, float loadFactor) &#123;if (initialCapacity &lt; 0)throw new IllegalArgumentException("Illegal initial capacity: " +initialCapacity);if (initialCapacity &gt; MAXIMUM_CAPACITY)initialCapacity = MAXIMUM_CAPACITY;if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))throw new IllegalArgumentException("Illegal load factor: " +loadFactor);// Find a power of 2 &gt;= initialCapacity//算法原理：capacity初始为1，当capacity小于initialCapacity时左移一位，就是*2,直到找到大于当前要求的容量最小的2的幂int capacity = 1;while (capacity &lt; initialCapacity)capacity &lt;&lt;= 1;this.loadFactor = loadFactor;threshold = (int )(capacity * loadFactor);table = new Entry[capacity];init();&#125;//容量增加，transfer(newTable);会将原来的数据再哈希重新放入数据void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length ; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor); &#125; 在Android中的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//默认的初始最小容量是4，一个静态的初始数组的容量是最小容量无符号右移1位，也就是2，默认构造时，会将该静态数组交给table,这里有一行源码的注释（ Forces first put invocation to replace EMPTY_TABLE），意思是根据第一次put方法加入的数量来扩充数组，此时负载容量是-1，添加时会立刻扩充容量，这可能也是为什么Android中添加元素是先检查扩充容量再添加的原因。。在put时第一次百分百检测到容量不够，此时进行一次doubleCapacity()将容量加倍，在这个方法中会调用private static final int MINIMUM_CAPACITY = 4;private static final Entry[] EMPTY_TABLE = new HashMapEntry[MINIMUM_CAPACITY &gt;&gt;&gt; 1];public HashMap() &#123; table = (HashMapEntry&lt;K, V&gt;[]) EMPTY_TABLE; threshold = -1; // Forces first put invocation to replace EMPTY_TABLE&#125;//容量增长或初始化时会调用该方法，重置阈值，与Java稍有不同，使用固定的容量的3/4来作为阈值，Java中还要比较容量的大小，取Math.min(容量，)private HashMapEntry&lt;K, V&gt;[] doubleCapacity() &#123; HashMapEntry&lt;K, V&gt;[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; return oldTable; &#125; int newCapacity = oldCapacity * 2; HashMapEntry&lt;K, V&gt;[] newTable = makeTable(newCapacity); if (size == 0) &#123; return newTable; &#125; for (int j = 0; j &lt; oldCapacity; j++) &#123; /* * Rehash the bucket using the minimum number of field writes. * This is the most subtle and delicate code in the class. */ HashMapEntry&lt;K, V&gt; e = oldTable[j]; if (e == null) &#123; continue; &#125; int highBit = e.hash &amp; oldCapacity; HashMapEntry&lt;K, V&gt; broken = null; newTable[j | highBit] = e; for (HashMapEntry&lt;K, V&gt; n = e.next; n != null; e = n, n = n.next) &#123; int nextHighBit = n.hash &amp; oldCapacity; if (nextHighBit != highBit) &#123; if (broken == null) newTable[j | nextHighBit] = n; else broken.next = n; broken = e; highBit = nextHighBit; &#125; &#125; if (broken != null) broken.next = null; &#125; return newTable;&#125;private HashMapEntry&lt;K, V&gt;[] makeTable(int newCapacity) &#123; @SuppressWarnings("unchecked") HashMapEntry&lt;K, V&gt;[] newTable = (HashMapEntry&lt;K, V&gt;[]) new HashMapEntry[newCapacity]; table = newTable; //阈值时是容量的3/4,使用了位运算 threshold = (newCapacity &gt;&gt; 1) + (newCapacity &gt;&gt; 2); // 3/4 capacity return newTable;&#125;//同样的检查机制，然后使用了一个方法，又是Collections类中的方法Collections.roundUpToPowerOfTwo(capacity);，作用是一样的，将容量修改为大于输入容量的最小的2的幂。但是使用二进制实现，会不会更牛逼一点。public HashMap(int capacity) &#123; if (capacity &lt; 0) &#123; throw new IllegalArgumentException("Capacity: " + capacity); &#125; if (capacity == 0) &#123; @SuppressWarnings("unchecked") HashMapEntry&lt;K, V&gt;[] tab = (HashMapEntry&lt;K, V&gt;[]) EMPTY_TABLE; table = tab; threshold = -1; // Forces first put() to replace EMPTY_TABLE return; &#125; if (capacity &lt; MINIMUM_CAPACITY) &#123; capacity = MINIMUM_CAPACITY; &#125; else if (capacity &gt; MAXIMUM_CAPACITY) &#123; capacity = MAXIMUM_CAPACITY; &#125; else &#123; capacity = Collections.roundUpToPowerOfTwo(capacity); &#125; makeTable(capacity);&#125;//看不懂啊，应该收藏一下关于二进制的算法，高大上的别人都看不懂public static int roundUpToPowerOfTwo(int i) &#123; i--; // If input is a power of two, shift its high-order bit right. // "Smear" the high-order bit all the way to the right. i |= i &gt;&gt;&gt; 1; i |= i &gt;&gt;&gt; 2; i |= i &gt;&gt;&gt; 4; i |= i &gt;&gt;&gt; 8; i |= i &gt;&gt;&gt; 16; return i + 1;&#125; 更多 JDK1.8在容量过大时使用红黑树存储数据，事件复杂度O(logn),对于红黑树不是很了解，算法很菜，暂时放放吧。 阈值 = 容量 负载因子，当容量超过阈值时会进行扩容和再散列，此时是hashmap的内存占用的增长点，扩容会将容量扩大为原来的两倍然后将数据拷贝到新的区域进行再散列。但是这里有个问题不太懂：HashMap扩容，每次添加一个元素size++,当size&gt;阈值（容量负载因子）时进行扩容，但是HashMap是基于数组+链表的，添加的元素不一定集中到一个数组项。举个例子说，当一个hashmap容量是16，阈值就是12，此时添加的元素如果有12个了，但是却只是集中在某几个数组项所在 的链表中，那么此时进行扩容合适吗？暂时合理的解释是hash（）算法可以很好的将数据分散在所有的数组项中，那么这种比较也是比较合理的。 为什么要将初始容量计算得到大于该容量的最小的2的幂？我们可以看一下这个代码int index = hash &amp; (tab.length - 1);在java中有相同的设计是一个函数indexfor(int hash)在计算hashcode对应的数组下标时使用hash&amp;len-1代替了hash%len，只有在len是2的幂时，这两个方法才是等价不等效的。可能不太好理解，举个例子：len是16时，二进制10000，len-1是01111，如果得到的hash小于16时，比如是3吧，进行&amp;运算01111&amp;00011得到的结果是3，也就是本身。确实等价于3%16，再比如大于16，是19吧，再大也是一个意思，也就是01111&amp;10011得到的结果是3，等价于19%16，右数第5位以上的1都被过滤掉了，说这么多只是解释一下确实hash&amp;len-1等价于hash%len，但是使用位运算效率会大大提高，在源码中位运算随处可见。ps:我总觉的还有别的作用，但是没有了解到。]]></content>
      <categories>
        <category>Study</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SourceCode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView]]></title>
    <url>%2Farticle%2F2021227864%2F</url>
    <content type="text"><![CDATA[RecycerView 是类似于 ListView 和 GridView 的控件，可以使用列表的形式展示数据，使用不同的 LayoutManager 来实现单列，网格，瀑布流等展示效果。相比原来的列表控件要强大的多。 LayoutManager 在代码中设置LayoutManager，需要在设置adapter之前设置LayoutManager 12345678RecyclerView.LayoutManager layoutManager = null;//线性布局，第二个参数支持水平垂直两种方向，第三个参数用来设置是否反向显示layoutManager = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false);//网格布局，第二个参数设置列数，第三个参数支持水平垂直两种方向，第四个参数用来设置是否反向显示layoutManager = new GridLayoutManager(this,3,GridLayoutManager.HORIZONTAL,false);//瀑布流布局，第一个参数设置列数，第二个参数支持水平垂直两种方向 layoutManager = new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL);recyclerView.setLayoutManager(layoutManager); ViewHolder 继承Recycler.ViewHolder实现自定义ViewHolder 1234567891011121314151617//这里只是实现简单的功能，旨在介绍了解RecyclerView的使用。//需要注意的一点是，RecyclerView并没有实现OnItemClickListener事件，也就是我们无法直接获得Item的点击事件。//采用的方法是在最外层的父布局添加点击事件来模拟Item点击。//getAdapterPosition();函数获取当前Item在Adapter中的位置//getLayoutPosition());函数获得当前Item在布局中的位置class CustomViewHolder extends RecyclerView.ViewHolder &#123; TextView tv; public CustomViewHolder (View itemView) &#123; super(itemView); tv = (TextView) itemView.findViewById(R.id.test_tv); itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.i("chendong", "点击了item" + getAdapterPosition() + " layout --"+getLayoutPosition()); &#125; &#125;); &#125; &#125; Adapter 继承Recycler.Adapter实现适配器 123456789101112131415161718192021222324252627282930class ContentAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; &#123; public ContentAdapter() &#123; //在这里获得需要的参数 &#125; @Override public int getItemViewType(int position) &#123; //获取数据的类型，用于多类型适配 &#125; @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; //获取对应类型的ViewHolder,加载不同的布局，类似ListView中getView（）的代码，示例代码： View view = getLayoutInflater().inflate(R.layout.test, parent, false); return new CustomViewHolder(view); &#125; @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; //向ViewHolder中的控件绑定数据,这里用的是强转，也可以使用泛型直接生成CustomViewHolder，但是多类型适配时还是需要强转。 CustomViewHolder temp = (CustomViewHolder)holder; holder.tv.setText("a"); &#125; @Override public int getItemCount() &#123; //获取Item个数 return 0; &#125; &#125; 数据更新1234567891011121314151617//类似ListView的数据更新，但是开放了更多方法，由于RecyclerView继承自ViewGroup，可以轻松实现对其中每一个控件的操作，而不用更新整个列表。//舒心列表adapter.notifyDataSetChanged();//删除某一位置的Itemadapter.notifyItemRemoved(0);//修改某一位置的Itemadapter.notifyItemChanged(0);//向某一位置掺入Itemadapter.notifyItemInserted(0);//将pos1的Item移动到pos2adapter.notifyItemMoved(0,1);//通知部分Item改变adapter.notifyItemRangeChanged(0,4);//向0-4的位置插入数据adapter.notifyItemRangeInserted(0,4);//移除0-4的数据adapter.notifyItemRangeRemoved(0,4); 分割线 RecyclerView提供了插入分隔线的方法，但是是个抽象类，需要我们自己重写，并且没有实现好的默认分隔线。1234567891011121314151617recyclerView.addItemDecoration(new RecyclerView.ItemDecoration() &#123;//onDraw方法先于绘制Item @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDraw(c, parent, state); &#125;//onDrawOver在绘制Item之后，一般我们选择复写其中一个即可。 @Override public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDrawOver(c, parent, state); &#125;//getItemOffsets 可以通过outRect.set()为每个Item设置一定的偏移量，主要用于绘制 @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); &#125; &#125;); 动画效果 RecyclerView为数据的更新增加了动画效果,并且提供了一个默认的动画，我们可以通过实现ItemAnimator实现自己的动画效果。 1recyclerView.setItemAnimator(new DefaultItemAnimator()); 总结 RecyclerView采用插拔式的数据填充，提供了更加强大的显示效果，可以轻松实现，各个方向的ListView,GridView,瀑布流效果，简单方便。但在进行多类型分类适配时需要创建大量的ViewHolder，需要我们进一步取封装和完善。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义控件—继承ViewGroup]]></title>
    <url>%2Farticle%2F844112004%2F</url>
    <content type="text"><![CDATA[前言 继承ViewGroup是自定义控件的一般方法，根据需要选择需要继承的ViewGroup的子类，本章将使用纯代码添加控件,方式确实不直观，但是可以用来练习使用代码操作控件的方法，毕竟不是所有的代码都可以用xml文件代替。 案例介绍 这次的目的实现一个类似这样的组合控件，出现这种需求是因为需要在一个ListView中添加一个类似ListView的部分，但是数量很少，可以不需要使用ListView,而是使用动态添加控件的方式。 代码 完全使用代码来写控件，没有xml布局，调试的时候是个大问题，写的代码往往不能实时的显示在预览界面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181public class SpecialItemView extends RelativeLayout &#123; //分析该布局定义以下组件 //图片 private ImageView imgIcon; //标题 private TextView txtTitle; //子标题 private TextView txtSubTitle; //专辑数量 private TextView txtNum; //右边更多按钮 private ImageButton ibArrow; //下方横线，因为最后一行是不显示横线的 private ImageView ivLine; /** * 代码中new时使用 * * @param context */ public SpecialItemView(Context context) &#123; this(context, null); &#125; /** * 在xml文件中使用 * * @param context * @param attrs */ public SpecialItemView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context, attrs); &#125; /** * 初始化 * * @param context * @param attributeSet */ private void init(Context context, AttributeSet attributeSet) &#123; //获取屏幕宽度 int width = context.getResources().getDisplayMetrics().widthPixels; //设置当前控件的padding this.setPadding(6,10,6,10); //初始化控件 imgIcon = new ImageView(context); //LayoutParams对象用来控制控件在ViewGroup中显示的样子 RelativeLayout.LayoutParams layoutParams = new LayoutParams((int) (width*0.2),(int) (width*0.2)); //垂直居中相当于layout_centervertical=true layoutParams.addRule(CENTER_VERTICAL); //配置控件 imgIcon.setScaleType(ImageView.ScaleType.CENTER_CROP); imgIcon.setLayoutParams(layoutParams); //相当于android:id imgIcon.setId(R.id.sp_item_icon); imgIcon.setImageResource(R.mipmap.finding_zone_img); //添加控件到ViewGroup addView(imgIcon); //除了可以设置为具体的数值，也可以使用常量，相当于xml文件中使用android：layout_width = "wrap_content" layoutParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); //左边margin layoutParams.leftMargin = 20; //相当于android:aligntop="R.id.sp_item_icon" layoutParams.addRule(ALIGN_TOP, R.id.sp_item_icon); layoutParams.addRule(RIGHT_OF, R.id.sp_item_icon); //以下是textview的设置 txtTitle.setText("标题"); txtTitle = new TextView(context); txtTitle.setId(R.id.sp_item_title); txtTitle.setTextSize(TypedValue.COMPLEX_UNIT_SP,18); txtTitle.setTextColor(Color.BLACK); txtTitle.setLayoutParams(layoutParams); txtTitle.setSingleLine(); txtTitle.setEllipsize(TextUtils.TruncateAt.END); addView(txtTitle); txtSubTitle = new TextView(context); txtSubTitle.setId(R.id.sp_item_subtitle); layoutParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); //todo sp2dp layoutParams.addRule(CENTER_VERTICAL); layoutParams.addRule(ALIGN_LEFT, R.id.sp_item_title); txtSubTitle.setText("字标题"); //todo sp2dp txtSubTitle.setTextSize(TypedValue.COMPLEX_UNIT_SP, 16); txtSubTitle.setTextColor(Color.GRAY); txtSubTitle.setLayoutParams(layoutParams); txtSubTitle.setPadding(0,0,16,0); txtSubTitle.setSingleLine(); txtSubTitle.setEllipsize(TextUtils.TruncateAt.END); addView(txtSubTitle); txtNum = new TextView(context); txtNum.setId(R.id.sp_item_subtitle); layoutParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); //todo sp2dp layoutParams.addRule(ALIGN_LEFT, R.id.sp_item_title); layoutParams.addRule(ALIGN_BOTTOM, R.id.sp_item_icon); txtNum.setText("共有几张专辑"); //todo sp2dp txtNum.setTextSize(TypedValue.COMPLEX_UNIT_SP, 16); txtNum.setTextColor(Color.GRAY); txtNum.setLayoutParams(layoutParams); txtNum.setSingleLine(); txtNum.setEllipsize(TextUtils.TruncateAt.END); txtNum.setGravity(CENTER_VERTICAL); //图标必须经过setbounds Drawable leftD = ContextCompat.getDrawable(getContext(), R.mipmap.finding_album_img); leftD.setBounds(0, 0, 20, 0); txtNum.setCompoundDrawablesWithIntrinsicBounds(leftD, null, null, null); txtNum.setId(R.id.sp_item_num); addView(txtNum); ibArrow = new ImageButton(context); ibArrow.setId(R.id.sp_item_subtitle); layoutParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); //todo sp2dp layoutParams.addRule(CENTER_VERTICAL); layoutParams.addRule(ALIGN_PARENT_RIGHT); //todo sp2dp layoutParams.rightMargin = 16; ibArrow.setBackgroundResource(R.drawable.selector_more); //todo sp2dp ibArrow.setLayoutParams(layoutParams); addView(ibArrow); ivLine = new ImageView(context); layoutParams = new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,1); layoutParams.addRule(ALIGN_LEFT,R.id.sp_item_title); layoutParams.addRule(BELOW,R.id.sp_item_num); //todo sp2dp layoutParams.topMargin=10; ivLine.setLayoutParams(layoutParams); ivLine.setBackgroundResource(R.drawable.shape_line); addView(ivLine); &#125; public void setTitle(String txt)&#123; txtTitle.setText(txt==null?"":txt); &#125; public void setSubTitle(String txt)&#123; txtSubTitle.setText(txt==null?"":txt); &#125; public void setNum(String txt)&#123; txtNum.setText(txt==null?"":txt); &#125; public void setShowLine(int xx)&#123; ivLine.setVisibility(xx); &#125; public void setImg(String url)&#123; Picasso.with(getContext()).load(url).into(imgIcon); &#125; public ImageView getImgIcon()&#123; return imgIcon; &#125; public ImageButton getImgArrow()&#123; return ibArrow; &#125; private OnMoreClick onMoreClick; public //使用接口将ibArrow点击事件传递出去 public interface OnMoreClick&#123; void click(); &#125;&#125; 在xml文件中使用1234&lt;com.march.himalayasfm.app.widgets.SpecialItemView android:layout_width="match_parent" android:layout_height="wrap_content" /&gt;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CardView]]></title>
    <url>%2Farticle%2F2807458501%2F</url>
    <content type="text"><![CDATA[本文介绍 CardView 的用法 compile &#39;com.android.support:cardview-v7:21.+ xml文件1234567891011121314&lt;android.support.v7.widget.CardViewandroid:layout_marginTop="20dp" android:layout_width="wrap_content"android:layout_height="wrap_content"app:cardCornerRadius="10dp"app:cardElevation="5dp"app:contentPadding="10dp" app:cardPreventCornerOverlap="true"&gt;&lt;ImageView android:scaleType="centerCrop"android:src="@mipmap/test" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt;&lt;/android.support.v7.widget.CardView&gt; 几个属性值1234567891011121314app:cardElevation=&quot;5dp&quot;//阴影app:cardElevation 阴影的大小app:cardMaxElevation 阴影最大高度app:cardBackgroundColor 卡片的背景色app:cardCornerRadius 卡片的圆角大小app:contentPadding 卡片内容于边距的间隔app:contentPaddingBottomapp:contentPaddingTopapp:contentPaddingLeftapp:contentPaddingRightapp:contentPaddingStartapp:contentPaddingEndapp:cardUseCompatPadding 设置内边距，V21+的版本和之前的版本仍旧具有一样的计算方式app:cardPreventConrerOverlap 在V20和之前的版本中添加内边距，这个属性为了防止内容和边角的重叠]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ADB命令大全]]></title>
    <url>%2Farticle%2F4015034291%2F</url>
    <content type="text"><![CDATA[ADB，即 Android Debug Bridge，它是 Android 开发/测试人员不可替代的强大工具，也是 Android 设备玩家的好玩具。 持续更新中，欢迎提 PR 和 Issue 补充指正，觉得有用的可以将 此 GitHub 仓库 Star 收藏备用。 注：有部分命令的支持情况可能与 Android 系统版本及定制 ROM 的实现有关。 基本用法 命令语法 为命令指定目标设备 启动/停止 查看 adb 版本 以 root 权限运行 adbd 指定 adb server 的网络端口 设备连接管理 查询已连接设备/模拟器 USB 连接 无线连接（需要借助 USB 线） 无线连接（无需借助 USB 线） 应用管理 查看应用列表 所有应用 系统应用 第三方应用 包名包含某字符串的应用 安装 APK 卸载应用 清除应用数据与缓存 查看前台 Activity 与应用交互 调起 Activity 调起 Service 发送广播 强制停止应用 文件管理 复制设备里的文件到电脑 复制电脑里的文件到设备 模拟按键/输入 电源键 菜单键 HOME 键 返回键 音量控制 媒体控制 点亮/熄灭屏幕 滑动解锁 输入文本 查看日志 Android 日志 按级别过滤日志 按 tag 和级别过滤日志 日志格式 清空日志 内核日志 查看设备信息 型号 电池状况 屏幕分辨率 屏幕密度 显示屏参数 android_id IMEI Android 系统版本 Mac 地址 CPU 信息 内存信息 更多硬件与系统属性 实用功能 屏幕截图 录制屏幕 重新挂载 system 分区为可写 查看连接过的 WiFi 密码 设置系统日期和时间 重启手机 检测设备是否已 root 使用 Monkey 进行压力测试 开启/关闭 WiFi 刷机相关命令 重启到 Recovery 模式 从 Recovery 重启到 Android 重启到 Fastboot 模式 通过 sideload 更新系统 更多 adb shell 命令 查看进程 查看实时资源占用情况 其它 adb 的非官方实现 致谢 参考链接 基本用法命令语法adb 命令的基本语法如下： 1adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt; 如果只有一个设备/模拟器连接时，可以省略掉 [-d|-e|-s &lt;serialNumber&gt;] 这一部分，直接使用 adb &lt;command&gt;。 为命令指定目标设备如果有多个设备/模拟器连接，则需要为命令指定目标设备。 参数 含义 -d 指定当前唯一通过 USB 连接的 Android 设备为命令目标 -e 指定当前唯一运行的模拟器为命令目标 -s &lt;serialNumber&gt; 指定相应 serialNumber 号的设备/模拟器为命令目标 在多个设备/模拟器连接的情况下较常用的是 -s &lt;serialNumber&gt; 参数，serialNumber 可以通过 adb devices 命令获取。如： 12345$ adb devicesList of devices attachedcf264b8f deviceemulator-5554 device 输出里的 cf264b8f 和 emulator-5554 即为 serialNumber。比如这时想指定 cf264b8f 这个设备来运行 adb 命令获取屏幕分辨率： 1adb -s cf264b8f shell wm size 遇到多设备/模拟器的情况均使用这几个参数为命令指定目标设备，下文中为简化描述，不再重复。 启动/停止启动 adb server 命令： 1adb start-server （一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。） 停止 adb server 命令： 1adb kill-server 查看 adb 版本命令： 1adb version 示例输出： 12Android Debug Bridge version 1.0.36Revision 8f855a3d9b35-android 以 root 权限运行 adbdadb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。 所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 adb xxx 执行。这时可以 adb shell 然后 su 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。 命令： 1adb root 正常输出： 1restarting adbd as root 现在再运行 adb shell，看看命令行提示符是不是变成 # 了？ 有些手机 root 后也无法通过 adb root 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 adbd cannot run as root in production builds，此时可以先安装 adbd Insecure，然后 adb root 试试。 相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 adb unroot 命令。 指定 adb server 的网络端口命令： 1adb -P &lt;port&gt; start-server 默认端口为 5037。 设备连接管理查询已连接设备/模拟器命令： 1adb devices 输出示例： 123List of devices attachedcf264b8f deviceemulator-5554 device 输出格式为 [serialNumber] [state]，serialNumber 即我们常说的 SN，state 有如下几种： offline —— 表示设备未连接成功或无响应。 device —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。 no device —— 没有设备/模拟器连接。 以上输出显示当前已经连接了两台设备/模拟器，cf264b8f 与 emulator-5554 分别是它们的 SN。从 emulator-5554 这个名字可以看出它是一个 Android 模拟器。 常见异常输出： 没有设备/模拟器连接成功。 1List of devices attached 设备/模拟器未连接到 adb 或无响应。 12List of devices attachedcf264b8f offline USB 连接通过 USB 连接来正常使用 adb 需要保证几点： 硬件状态正常。 包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好。 Android 设备的开发者选项和 USB 调试模式已开启。 可以到「设置」-「开发者选项」-「Android 调试」查看。 如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。 设备驱动状态正常。 这一点貌似在 Linux 和 Mac OS X 下不用操心，在 Windows 下有可能遇到需要安装驱动的情况，确认这一点可以右键「计算机」-「属性」，到「设备管理器」里查看相关设备上是否有黄色感叹号或问号，如果没有就说明驱动状态已经好了。否则可以下载一个手机助手类程序来安装驱动先。 通过 USB 线连接好电脑和设备后确认状态。 1adb devices 如果能看到 1xxxxxx device 说明连接成功。 无线连接（需要借助 USB 线）除了可以通过 USB 连接设备与电脑来使用 adb，也可以通过无线连接——虽然连接过程中也有需要使用 USB 的步骤，但是连接成功之后你的设备就可以在一定范围内摆脱 USB 连接线的限制啦！ 操作步骤： 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 将设备与电脑通过 USB 线连接。 应确保连接成功（可运行 adb devices 看是否能列出该设备）。 让设备在 5555 端口监听 TCP/IP 连接： 1adb tcpip 5555 断开 USB 连接。 找到设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到。 通过 IP 地址连接设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 确认连接状态。 1adb devices 如果能看到 1&lt;device-ip-address&gt;:5555 device 说明连接成功。 如果连接不了，请确认 Android 设备与电脑是连接到了同一个 WiFi，然后再次执行 adb connect &lt;device-ip-address&gt; 那一步； 如果还是不行的话，通过 adb kill-server 重新启动 adb 然后从头再来一次试试。 断开无线连接 命令： 1adb disconnect &lt;device-ip-address&gt; 无线连接（无需借助 USB 线）注：需要 root 权限。 上一节「无线连接（需要借助 USB 线）」是官方文档里介绍的方法，需要借助于 USB 数据线来实现无线连接。 既然我们想要实现无线连接，那能不能所有步骤下来都是无线的呢？答案是能的。 在 Android 设备上安装一个终端模拟器。 已经安装过的设备可以跳过此步。我使用的终端模拟器下载地址是：Terminal Emulator for Android Downloads 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 打开 Android 设备上的终端模拟器，在里面依次运行命令： 12susetprop service.adb.tcp.port 5555 找到 Android 设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到。 在电脑上通过 adb 和 IP 地址连接 Android 设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 如果能看到 connected to &lt;device-ip-address&gt;:5555 这样的输出则表示连接成功。 应用管理查看应用列表查看应用列表的基本命令格式是 1adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER] 即在 adb shell pm list packages 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下： 参数 显示列表 无 所有应用 -f 显示应用关联的 apk 文件 -d 只显示 disabled 的应用 -e 只显示 enabled 的应用 -s 只显示系统应用 -3 只显示第三方应用 -i 显示应用的 installer -u 包含已卸载应用 &lt;FILTER&gt; 包名包含 &lt;FILTER&gt; 字符串 所有应用命令： 1adb shell pm list packages 输出示例： 12345678910111213package:com.android.smoketestpackage:com.example.android.livecubespackage:com.android.providers.telephonypackage:com.google.android.googlequicksearchboxpackage:com.android.providers.calendarpackage:com.android.providers.mediapackage:com.android.protipspackage:com.android.documentsuipackage:com.android.gallerypackage:com.android.externalstorage...// other packages here... 系统应用命令： 1adb shell pm list packages -s 第三方应用命令： 1adb shell pm list packages -3 包名包含某字符串的应用比如要查看包名包含字符串 mazhuang 的应用列表，命令： 1adb shell pm list packages mazhuang 当然也可以使用 grep 来过滤： 1adb shell pm list packages | grep mazhuang 安装 APK命令格式： 1adb install [-lrtsdg] &lt;path_to_apk&gt; 参数： adb install 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下： 参数 含义 -l 将应用安装到保护目录 /mnt/asec -r 允许覆盖安装 -t 允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=&quot;true&quot; 的应用 -s 将应用安装到 sdcard -d 允许降级覆盖安装 -g 授予所有运行时权限 运行命令后如果见到类似如下输出（状态为 Success）代表安装成功： 123[100%] /data/local/tmp/1.apk pkg: /data/local/tmp/1.apkSuccess 上面是当前最新版 v1.0.36 的 adb 的输出，会显示 push apk 文件到手机的进度百分比。 使用旧版本 adb 的输出则是这样的： 12312040 KB/s (22205609 bytes in 1.801s) pkg: /data/local/tmp/SogouInput_android_v8.3_sweb.apkSuccess 而如果状态为 Failure 则表示安装失败，比如： 123[100%] /data/local/tmp/map-20160831.apk pkg: /data/local/tmp/map-20160831.apkFailure [INSTALL_FAILED_ALREADY_EXISTS] 常见安装失败输出代码、含义及可能的解决办法如下： 输出 含义 解决办法 INSTALL_FAILED_ALREADY_EXISTS 应用已经存在 使用 -r 参数 INSTALL_FAILED_INVALID_APK 无效的 APK 文件 INSTALL_FAILED_INVALID_URI 无效的 APK 文件名 确保 APK 文件名里无中文 INSTALL_FAILED_INSUFFICIENT_STORAGE 空间不足 清理空间 INSTALL_FAILED_DUPLICATE_PACKAGE 已经存在同名程序 INSTALL_FAILED_NO_SHARED_USER 请求的共享用户不存在 INSTALL_FAILED_UPDATE_INCOMPATIBLE 已经安装过签名不一样的同名应用，且数据没有移除 INSTALL_FAILED_SHARED_USER_INCOMPATIBLE 请求的共享用户存在但签名不一致 INSTALL_FAILED_MISSING_SHARED_LIBRARY 安装包使用了设备上不可用的共享库 INSTALL_FAILED_REPLACE_COULDNT_DELETE 替换时无法删除 INSTALL_FAILED_DEXOPT dex 优化验证失败或空间不足 INSTALL_FAILED_OLDER_SDK 设备系统版本低于应用要求 INSTALL_FAILED_CONFLICTING_PROVIDER 设备里已经存在与应用里同名的 content provider INSTALL_FAILED_NEWER_SDK 设备系统版本高于应用要求 INSTALL_FAILED_TEST_ONLY 应用是 test-only 的，但安装时没有指定 -t 参数 INSTALL_FAILED_CPU_ABI_INCOMPATIBLE 包含不兼容设备 CPU 应用程序二进制接口的 native code INSTALL_FAILED_MISSING_FEATURE 应用使用了设备不可用的功能 INSTALL_FAILED_CONTAINER_ERROR sdcard 访问失败 确认 sdcard 可用，或者安装到内置存储 INSTALL_FAILED_INVALID_INSTALL_LOCATION 不能安装到指定位置 切换安装位置，添加或删除 -s 参数 INSTALL_FAILED_MEDIA_UNAVAILABLE 安装位置不可用 一般为 sdcard，确认 sdcard 可用或安装到内置存储 INSTALL_FAILED_VERIFICATION_TIMEOUT 验证安装包超时 INSTALL_FAILED_VERIFICATION_FAILURE 验证安装包失败 INSTALL_FAILED_PACKAGE_CHANGED 应用与调用程序期望的不一致 INSTALL_FAILED_UID_CHANGED 以前安装过该应用，与本次分配的 UID 不一致 清除以前安装过的残留文件 INSTALL_FAILED_VERSION_DOWNGRADE 已经安装了该应用更高版本 使用 -d 参数 INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE 已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限 INSTALL_PARSE_FAILED_NOT_APK 指定路径不是文件，或不是以 .apk 结尾 INSTALL_PARSE_FAILED_BAD_MANIFEST 无法解析的 AndroidManifest.xml 文件 INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION 解析器遇到异常 INSTALL_PARSE_FAILED_NO_CERTIFICATES 安装包没有签名 INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES 已安装该应用，且签名与 APK 文件不一致 先卸载设备上的该应用，再安装 INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING 解析 APK 文件时遇到 CertificateEncodingException INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME manifest 文件里没有或者使用了无效的包名 INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID manifest 文件里指定了无效的共享用户 ID INSTALL_PARSE_FAILED_MANIFEST_MALFORMED 解析 manifest 文件时遇到结构性错误 INSTALL_PARSE_FAILED_MANIFEST_EMPTY 在 manifest 文件里找不到找可操作标签（instrumentation 或 application） INSTALL_FAILED_INTERNAL_ERROR 因系统问题安装失败 INSTALL_FAILED_USER_RESTRICTED 用户被限制安装应用 INSTALL_FAILED_DUPLICATE_PERMISSION 应用尝试定义一个已经存在的权限名称 INSTALL_FAILED_NO_MATCHING_ABIS 应用包含设备的应用程序二进制接口不支持的 native code INSTALL_CANCELED_BY_USER 应用安装需要在设备上确认，但未操作设备或点了取消 在设备上同意安装 INSTALL_FAILED_ACWF_INCOMPATIBLE 应用程序与设备不兼容 does not contain AndroidManifest.xml 无效的 APK 文件 is not a valid zip file 无效的 APK 文件 Offline 设备未连接成功 先将设备与 adb 连接成功 unauthorized 设备未授权允许调试 error: device not found 没有连接成功的设备 先将设备与 adb 连接成功 protocol failure 设备已断开连接 先将设备与 adb 连接成功 Unknown option: -s Android 2.2 以下不支持安装到 sdcard 不使用 -s 参数 No space left on devicerm 空间不足 清理空间 Permission denied … sdcard … sdcard 不可用 参考：PackageManager.java adb install 内部原理简介 adb install 实际是分三步完成： push apk 文件到 /data/local/tmp。 调用 pm install 安装。 删除 /data/local/tmp 下的对应 apk 文件。 所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。 卸载应用命令： 1adb uninstall [-k] &lt;packagename&gt; &lt;packagename&gt; 表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录。 命令示例： 1adb uninstall com.qihoo360.mobilesafe 表示卸载 360 手机卫士。 清除应用数据与缓存命令： 1adb shell pm clear &lt;packagename&gt; &lt;packagename&gt; 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。 命令示例： 1adb shell pm clear com.qihoo360.mobilesafe 表示清除 360 手机卫士的数据和缓存。 查看前台 Activity命令： 1adb shell dumpsys activity activities | grep mFocusedActivity 输出示例： 1mFocusedActivity: ActivityRecord&#123;8079d7e u0 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher t42&#125; 其中的 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher 就是当前处于前台的 Activity。 与应用交互主要是使用 am &lt;command&gt; 命令，常用的 &lt;command&gt; 如下： command 用途 start [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Activity startservice [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Service broadcast [options] &lt;INTENT&gt; 发送 &lt;INTENT&gt; 指定的广播 force-stop &lt;packagename&gt; 停止 &lt;packagename&gt; 相关的进程 &lt;INTENT&gt; 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。 用于决定 intent 对象的选项如下： 参数 含义 -a &lt;ACTION&gt; 指定 action，比如 android.intent.action.VIEW -c &lt;CATEGORY&gt; 指定 category，比如 android.intent.category.APP_CONTACTS -n &lt;COMPONENT&gt; 指定完整 component 名，用于明确指定启动哪个 Activity，如 com.example.app/.ExampleActivity &lt;INTENT&gt; 里还能带数据，就像写代码时的 Bundle 一样： 参数 含义 --esn &lt;EXTRA_KEY&gt; null 值（只有 key 名） `-e –es ` string 值 --ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt; boolean 值 --ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt; integer 值 --el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt; long 值 --ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt; float 值 --eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt; URI --ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt; component name --eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...] integer 数组 --ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...] long 数组 调起 Activity命令格式： 1adb shell am start [options] &lt;INTENT&gt; 例如： 1adb shell am start -n com.tencent.mm/.ui.LauncherUI 表示调起微信主界面。 1adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity --es "toast" "hello, world" 表示调起 org.mazhuang.boottimemeasure/.MainActivity 并传给它 string 数据键值对 toast - hello, world。 调起 Service命令格式： 1adb shell am startservice [options] &lt;INTENT&gt; 例如： 1adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService 表示调起微信的某 Service。 发送广播命令格式： 1adb shell am broadcast [options] &lt;INTENT&gt; 例如： 1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n org.mazhuang.boottimemeasure/.BootCompletedReceiver 表示向 org.mazhuang.boottimemeasure/.BootCompletedReceiver 发送一个 BOOT_COMPLETED 广播，这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。 强制停止应用命令： 1adb shell am force-stop &lt;packagename&gt; 命令示例： 1adb shell am force-stop com.qihoo360.mobilesafe 表示停止 360 安全卫士的一切进程与服务。 文件管理复制设备里的文件到电脑命令： 1adb pull &lt;设备里的文件路径&gt; [电脑上的目录] 其中 电脑上的目录 参数可以省略，默认复制到当前目录。 例： 1adb pull /sdcard/sr.mp4 ~/tmp/ 小技巧：设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 adb shell 和 su 命令在 adb shell 里获取 root 权限后，先 cp /path/on/device /sdcard/filename 将文件复制到 sdcard，然后 adb pull /sdcard/filename /path/on/pc。 复制电脑里的文件到设备命令： 1adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt; 例： 1adb push ~/sr.mp4 /sdcard/ 小技巧：设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 adb push /path/on/pc /sdcard/filename，然后 adb shell 和 su 在 adb shell 里获取 root 权限后，cp /sdcard/filename /path/on/device。 模拟按键/输入在 adb shell 里有个很实用的命令叫 input，通过它可以做一些有趣的事情。 input 命令的完整 help 信息如下： 12345678910111213141516171819202122Usage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]The sources are: mouse keyboard joystick touchnavigation touchpad trackball stylus dpad gesture touchscreen gamepadThe commands and default sources are: text &lt;string&gt; (Default: touchscreen) keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard) tap &lt;x&gt; &lt;y&gt; (Default: touchscreen) swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen) press (Default: trackball) roll &lt;dx&gt; &lt;dy&gt; (Default: trackball) 比如使用 adb shell input keyevent &lt;keycode&gt; 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 KeyEvent，摘引部分我觉得有意思的如下： keycode 含义 3 HOME 键 4 返回键 5 打开拨号应用 6 挂断电话 24 增加音量 25 降低音量 26 电源键 27 拍照（需要在相机应用里） 64 打开浏览器 82 菜单键 85 播放/暂停 86 停止播放 87 播放下一首 88 播放上一首 122 移动光标到行首或列表顶部 123 移动光标到行末或列表底部 126 恢复播放 127 暂停播放 164 静音 176 打开系统设置 187 切换应用 207 打开联系人 208 打开日历 209 打开音乐 210 打开计算器 220 降低屏幕亮度 221 提高屏幕亮度 223 系统休眠 224 点亮屏幕 231 打开语音助手 276 如果没有 wakelock 则让系统休眠 下面是 input 命令的一些用法举例。 电源键命令： 1adb shell input keyevent 26 执行效果相当于按电源键。 菜单键命令： 1adb shell input keyevent 82 HOME 键命令： 1adb shell input keyevent 3 返回键命令： 1adb shell input keyevent 4 音量控制增加音量： 1adb shell input keyevent 24 降低音量： 1adb shell input keyevent 25 静音： 1adb shell input keyevent 164 媒体控制播放/暂停： 1adb shell input keyevent 85 停止播放： 1adb shell input keyevent 86 播放下一首： 1adb shell input keyevent 87 播放上一首： 1adb shell input keyevent 88 恢复播放： 1adb shell input keyevent 126 暂停播放： 1adb shell input keyevent 127 点亮/熄灭屏幕可以通过上文讲述过的模拟电源键来切换点亮和熄灭屏幕，但如果明确地想要点亮或者熄灭屏幕，那可以使用如下方法。 点亮屏幕： 1adb shell input keyevent 224 熄灭屏幕： 1adb shell input keyevent 223 滑动解锁如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 input swipe 来解锁。 命令（参数以机型 Nexus 5，向上滑动手势解锁举例）： 1adb shell input swipe 300 1000 300 500 参数 300 1000 300 500 分别表示起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标。 输入文本在焦点处于某文本框时，可以通过 input 命令来输入文本。 命令： 1adb shell input text hello 现在 hello 出现在文本框了。 查看日志Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。 Android 日志命令格式： 1[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ... 常用用法列举如下： 按级别过滤日志Android 的日志分为如下几个级别： V —— Verbose（最低，输出得最多） D —— Debug I —— Info W —— Warning E —— Error F —— Fatal S —— Silent（最高，啥也不输出） 按某级别过滤日志则会将该级别及以上的日志输出。 比如，命令： 1adb logcat *:W 会将 Warning、Error、Fatal 和 Silent 日志输出。 按 tag 和级别过滤日志比如，命令： 1adb logcat ActivityManager:I MyApp:D *:S 表示输出 tag ActivityManager 的 Info 以上级别日志，输出 tag MyApp 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。 日志格式可以用 adb logcat -v &lt;format&gt; 选项指定日志输出格式。 日志支持按以下几种 &lt;format&gt;： brief 默认格式。格式为： 1&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 1D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 process 格式为： 1&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt; 示例： 1D( 1785) Disconnected process message: 10, size: 0 (HeadsetStateMachine) tag 格式为： 1&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt; 示例： 1D/HeadsetStateMachine: Disconnected process message: 10, size: 0 raw 格式为： 1&lt;message&gt; 示例： 1Disconnected process message: 10, size: 0 time 格式为： 1&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 108-28 22:39:39.974 D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 threadtime 格式为： 1&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt; 示例： 108-28 22:39:39.974 1785 1832 D HeadsetStateMachine: Disconnected process message: 10, size: 0 long 格式为： 12[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ]&lt;message&gt; 示例： 12[ 08-28 22:39:39.974 1785: 1832 D/HeadsetStateMachine ]Disconnected process message: 10, size: 0 指定格式可与上面的过滤同时使用。比如： 1adb logcat -v long ActivityManager:I *:S 清空日志1adb logcat -c 内核日志命令： 1adb shell dmesg 输出示例： 1234567&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs&lt;4&gt;[14201.755954] Restarting tasks ... done.&lt;6&gt;[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC&lt;6&gt;[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC&lt;6&gt;[14201.872498] PM: Syncing filesystems ... done. 中括号里的 [14201.684016] 代表内核开始启动后的时间，单位为秒。 通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 Freeing init memory 那一行前面的时间就是。 查看设备信息型号命令： 1adb shell getprop ro.product.model 输出示例： 1Nexus 5 电池状况命令： 1adb shell dumpsys battery 输入示例： 123456789101112Current Battery Service state: AC powered: false USB powered: true Wireless powered: false status: 2 health: 2 present: true level: 44 scale: 100 voltage: 3872 temperature: 280 technology: Li-poly 其中 scale 代表最大电量，level 代表当前电量。上面的输出表示还剩下 44% 的电量。 屏幕分辨率命令： 1adb shell wm size 输出示例： 1Physical size: 1080x1920 该设备屏幕分辨率为 1080px * 1920px。 屏幕密度命令： 1adb shell wm density 输出示例： 1Physical density: 420 该设备屏幕密度为 420dpi。 显示屏参数命令： 1adb shell dumpsys window displays 输出示例： 1234WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays) Display: mDisplayId=0 init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731 deferred=false layoutNeeded=false 其中 mDisplayId 为 显示屏编号，init 是初始分辨率和屏幕密度，app 的高度比 init 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。 android_id命令： 1adb shell settings get secure android_id 输出示例： 151b6be48bac8c569 IMEI在 Android 4.4 及以下版本可通过如下命令获取 IMEI： 1adb shell dumpsys iphonesubinfo 输出示例： 123Phone Subscriber Info: Phone Type = GSM Device ID = 860955027785041 其中的 Device ID 就是 IMEI。 而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）： 123adb shellsuservice call iphonesubinfo 1 输出示例： 1234Result: Parcel( 0x00000000: 00000000 0000000f 00360038 00390030 '........8.6.0.9.' 0x00000010: 00350035 00320030 00370037 00350038 '5.5.0.2.7.7.8.5.' 0x00000020: 00340030 00000031 '0.4.1... ') 把里面的有效内容提取出来就是 IMEI 了，比如这里的是 860955027785041。 参考：adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop Android 系统版本命令： 1adb shell getprop ro.build.version.release 输出示例： 15.0.2 Mac 地址命令： 1adb shell cat /sys/class/net/wlan0/address 输出示例： 1f8:a9:d0:17:42:4d CPU 信息命令： 1adb shell cat /proc/cpuinfo 输出示例： 1234567891011121314151617181920212223Processor : ARMv7 Processor rev 0 (v7l)processor : 0BogoMIPS : 38.40processor : 1BogoMIPS : 38.40processor : 2BogoMIPS : 38.40processor : 3BogoMIPS : 38.40Features : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivtCPU implementer : 0x51CPU architecture: 7CPU variant : 0x2CPU part : 0x06fCPU revision : 0Hardware : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree)Revision : 000bSerial : 0000000000000000 这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是 Qualcomm MSM 8974，processor 的编号是 0 到 3，所以它是四核的，采用的架构是 ARMv7 Processor rev 0 (v71)。 内存信息命令： 1adb shell cat /proc/meminfo 输出示例： 12345678910111213141516171819202122232425262728293031323334353637MemTotal: 1027424 kBMemFree: 486564 kBBuffers: 15224 kBCached: 72464 kBSwapCached: 24152 kBActive: 110572 kBInactive: 259060 kBActive(anon): 79176 kBInactive(anon): 207736 kBActive(file): 31396 kBInactive(file): 51324 kBUnevictable: 3948 kBMlocked: 0 kBHighTotal: 409600 kBHighFree: 132612 kBLowTotal: 617824 kBLowFree: 353952 kBSwapTotal: 262140 kBSwapFree: 207572 kBDirty: 0 kBWriteback: 0 kBAnonPages: 265324 kBMapped: 47072 kBShmem: 1020 kBSlab: 57372 kBSReclaimable: 7692 kBSUnreclaim: 49680 kBKernelStack: 4512 kBPageTables: 5912 kBNFS_Unstable: 0 kBBounce: 0 kBWritebackTmp: 0 kBCommitLimit: 775852 kBCommitted_AS: 13520632 kBVmallocTotal: 385024 kBVmallocUsed: 61004 kBVmallocChunk: 209668 kB 其中，MemTotal 就是设备的总内存，MemFree 是当前空闲内存。 更多硬件与系统属性设备的更多硬件与系统属性可以通过如下命令查看： 1adb shell cat /system/build.prop 这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。 输出里还包括一些其它有用的信息，它们也可通过 adb shell getprop &lt;属性名&gt; 命令单独查看，列举一部分属性如下： 属性名 含义 ro.build.version.sdk SDK 版本 ro.build.version.release Android 系统版本 ro.build.version.security_patch Android 安全补丁程序级别 ro.product.model 型号 ro.product.brand 品牌 ro.product.name 设备名 ro.product.board 处理器型号 ro.product.cpu.abilist CPU 支持的 abi 列表 persist.sys.isUsbOtgEnabled 是否支持 OTG dalvik.vm.heapsize 每个应用程序的内存上限 ro.sf.lcd_density 屏幕密度 实用功能屏幕截图命令： 1adb shell screencap -p /sdcard/sc.png 然后将 png 文件导出到电脑： 1adb pull /sdcard/sc.png 可以使用 adb shell screencap -h 查看 screencap 命令的帮助信息，下面是两个有意义的参数及含义： 参数 含义 -p 指定保存文件为 png 格式 -d display-id 指定截图的显示屏编号（有多显示屏的情况下） 实测如果指定文件名以 .png 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。 录制屏幕录制屏幕以 mp4 格式保存到 /sdcard： 1adb shell screenrecord /sdcard/filename.mp4 需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。 如果需要导出到电脑： 1adb pull /sdcard/filename.mp4 可以使用 adb shell screenrecord --help 查看 screenrecord 命令的帮助信息，下面是常见参数及含义： 参数 含义 –size WIDTHxHEIGHT 视频的尺寸，比如 1280x720，默认是屏幕分辨率。 –bit-rate RATE 视频的比特率，默认是 4Mbps。 –time-limit TIME 录制时长，单位秒。 –verbose 输出更多信息。 重新挂载 system 分区为可写注：需要 root 权限。 /system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 /system 进行写操作，所以需要重新挂载它为可读写。 步骤： 进入 shell 并切换到 root 用户权限。 命令： 12adb shellsu 查看当前分区挂载情况。 命令： 1mount 输出示例： 12345678910111213141516171819202122232425rootfs / rootfs ro,relatime 0 0tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0proc /proc proc rw,relatime 0 0sysfs /sys sysfs rw,seclabel,relatime 0 0selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0debugfs /sys/kernel/debug debugfs rw,relatime 0 0none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0none /acct cgroup rw,relatime,cpuacct 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0none /dev/memcg cgroup rw,relatime,memory 0 0none /dev/cpuctl cgroup rw,relatime,cpu 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0/dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0 找到其中我们关注的带 /system 的那一行： 1/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0 重新挂载。 命令： 1mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system 这里的 /dev/block/platform/msm_sdcc.1/by-name/system 就是我们从上一步的输出里得到的文件路径。 如果输出没有提示错误的话，操作就成功了，可以对 /system 下的文件为所欲为了。 查看连接过的 WiFi 密码注：需要 root 权限。 命令： 123adb shellsucat /data/misc/wifi/*.conf 输出示例： 123456789101112131415161718network=&#123; ssid="TP-LINK_9DFC" scan_ssid=1 psk="123456789" key_mgmt=WPA-PSK group=CCMP TKIP auth_alg=OPEN sim_num=1 priority=13893&#125;network=&#123; ssid="TP-LINK_F11E" psk="987654321" key_mgmt=WPA-PSK sim_num=1 priority=17293&#125; ssid 即为我们在 WLAN 设置里看到的名称，psk 为密码，key_mgmt 为安全加密方式。 设置系统日期和时间注：需要 root 权限。 命令： 123adb shellsudate -s 20160823.131500 表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。 重启手机命令： 1adb reboot 检测设备是否已 root命令： 12adb shellsu 此时命令行提示符是 $ 则表示没有 root 权限，是 # 则表示已 root。 使用 Monkey 进行压力测试Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。 简单用法： 1adb shell monkey -p &lt;packagename&gt; -v 500 表示向 &lt;packagename&gt; 指定的应用程序发送 500 个伪随机事件。 Monkey 的详细用法参考 官方文档。 开启/关闭 WiFi注：需要 root 权限。 有时需要控制设备的 WiFi 状态，可以用以下指令完成。 开启 WiFi： 12adb rootadb shell svc wifi enable 关闭 WiFi： 12adb rootadb shell svc wifi disable 若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 Killed。 刷机相关命令重启到 Recovery 模式命令： 1adb reboot recovery 从 Recovery 重启到 Android命令： 1adb reboot 重启到 Fastboot 模式命令： 1adb reboot bootloader 通过 sideload 更新系统如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。 以 Recovery 模式下更新为例： 重启到 Recovery 模式。 命令： 1adb reboot recovery 在设备的 Recovery 界面上操作进入 Apply update-Apply from ADB。 注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 Apply update from ADB。 通过 adb 上传和更新系统。 命令： 1adb sideload &lt;path-to-update.zip&gt; 更多 adb shell 命令Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 adb shell 里可以调用。本文档前面的部分内容已经用到了 adb shell 命令。 查看进程命令： 1adb shell ps 输出示例： 12345678USER PID PPID VSIZE RSS WCHAN PC NAMEroot 1 0 8904 788 ffffffff 00000000 S /initroot 2 0 0 0 ffffffff 00000000 S kthreadd...u0_a71 7779 5926 1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classicu0_a58 7963 5926 1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure...shell 8750 217 10640 740 00000000 b6f28340 R ps 各列含义： 列名 含义 USER 所属用户 PID 进程 ID PPID 父进程 ID NAME 进程名 查看实时资源占用情况命令： 1adb shell top 输出示例： 1234567891011121314User 0%, System 6%, IOW 0%, IRQ 0%User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307 PID PR CPU% S #THR VSS RSS PCY UID Name 8763 0 3% R 1 10640K 1064K fg shell top 131 0 3% S 1 0K 0K fg root dhd_dpc 6144 0 0% S 115 1682004K 115916K fg system system_server 132 0 0% S 1 0K 0K fg root dhd_rxf 1731 0 0% S 6 20288K 788K fg root /system/bin/mpdecision 217 0 0% S 6 18008K 356K fg shell /sbin/adbd ... 7779 2 0% S 19 1538748K 48896K bg u0_a71 com.sohu.inputmethod.sogou:classic 7963 0 0% S 18 1561916K 59568K fg u0_a58 org.mazhuang.boottimemeasure ... 各列含义： 列名 含义 PID 进程 ID PR 优先级 CPU% 当前瞬间占用 CPU 百分比 S 进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程） #THR 线程数 VSS Virtual Set Size 虚拟耗用内存（包含共享库占用的内存） RSS Resident Set Size 实际使用物理内存（包含共享库占用的内存） PCY 调度策略优先级，SP_BACKGROUND/SPFOREGROUND UID 进程所有者的用户 ID NAME 进程名 top 命令还支持一些命令行参数，详细用法如下： 1234567Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ] -m num 最多显示多少个进程 -n num 刷新多少次后退出 -d num 刷新时间间隔（单位秒，默认值 5） -s col 按某列排序（可用 col 值：cpu, vss, rss, thr） -t 显示线程信息 -h 显示帮助文档 其它如下是其它常用命令的简单描述，前文已经专门讲过的命令不再额外说明： 命令 功能 cat 显示文件内容 cd 切换目录 chmod 改变文件的存取模式/访问权限 df 查看磁盘空间使用情况 grep 过滤输出 kill 杀死指定 PID 的进程 ls 列举目录内容 mount 挂载目录的查看和管理 mv 移动或重命名文件 ps 查看正在运行的进程 rm 删除文件 top 查看进程的资源占用情况 adb 的非官方实现 fb-adb - A better shell for Android devices (for Mac). 致谢感谢朋友们无私的分享与补充。 zxning linhua55 codeskyblue seasonyuu fan123199 参考链接 Android Debug Bridge ADB Shell Commands logcat Command-line Tool Android ADB命令大全 adb 命令行的使用记录 Android ADB命令大全(通过ADB命令查看wifi密码、MAC地址、设备信息、操作文件、查看文件、日志信息、卸载、启动和安装APK等) 那些做Android开发必须知道的ADB命令 adb shell top 像高手一样使用ADB命令行（2）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jave IO流之压缩流（zip,Gzip）]]></title>
    <url>%2Farticle%2F837682646%2F</url>
    <content type="text"><![CDATA[JAVAIO流是java的一个很重要的部分，清晰有很复杂，各种各样的流分管不同的功能。正确使用IO流可以让你的输入输出效率增加，这篇博客主要说一下压缩流的使用，使用JAVA内置API压缩解压缩文件。 ZIP压缩主要的用到的API是123ZipFileZipInputStreamZipOutputStream 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.Closeable;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.util.Enumeration;import java.util.zip.ZipEntry;import java.util.zip.ZipException;import java.util.zip.ZipFile;import java.util.zip.ZipInputStream;import java.util.zip.ZipOutputStream;/** * * @author chendong * * &lt;/br&gt;使用java内置APIZipFile完成对文件的压缩解压缩操作 * * &lt;/br&gt;文件中如果有中文名称加压后的文件会出现乱码，但是解压之后又ok了，可以使用中文 * * &lt;/br&gt;提供了大文件异步加压解压的方法，使用回调检测是否完成 * * &lt;/br&gt;提供小文件同步加压解压更加方便 * */public class ZipUtils &#123; /** * 用于大文件加压解压的回调监听 * * @author chendong * */ public interface OnZipOverListener &#123; void onZipOver(); &#125; public interface OnUnZipOverListener &#123; void onUnZipOver(); &#125; /** * 压缩 &lt;/br&gt;构造源文件 * * @param src * 源文件路径 * @param dest * 目标文件路径 * @throws FileNotFoundException */ public static void zip(String src, String dest, OnZipOverListener listener) &#123; File srcFile = new File(src); zip(srcFile, dest, listener); &#125; /** * 压缩 &lt;/br&gt;生成压缩输出文件流 * * @param srcFile * @param dest * @throws FileNotFoundException */ public static void zip(File srcFile, String dest, OnZipOverListener listener) &#123; ZipOutputStream destOs = null; try &#123; destOs = new ZipOutputStream(new FileOutputStream(dest)); zip(srcFile, destOs, ""); close(destOs); if (listener != null) listener.onZipOver(); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; close(destOs); &#125; &#125; /** * 压缩,使用递归 &lt;/br&gt;写文件 &lt;/br&gt;主要操作在这个函数中，使用递归如果是一个文件，将其写入流中否则进行递归 &lt;/br&gt;ZipEntry * 类是java.util.zip包下的一个类， ZipEntry 类用于表示 ZIP 文件条目。 利用这个类压缩和解压zip文件 * * @param srcFile * @param destOs * @param string * @throws IOException */ private static void zip(File srcFile, ZipOutputStream destOs, String base) &#123; BufferedInputStream bis = null; try &#123; if (srcFile.isDirectory()) &#123; /* 如果源文件是目录 */ File[] files = srcFile.listFiles(); destOs.putNextEntry(new ZipEntry(base + "/")); base = base.length() == 0 ? "" : base + "/"; for (int i = 0; i &lt; files.length; i++) &#123; zip(files[i], destOs, base + files[i].getName()); &#125; &#125; else &#123; /* 如果是文件 */ destOs.putNextEntry(new ZipEntry(base)); bis = new BufferedInputStream(new FileInputStream(srcFile)); byte[] buffer = new byte[1024]; int len = 0; while ((len = bis.read(buffer)) != -1) &#123; destOs.write(buffer, 0, len); &#125; close(bis); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; close(bis); &#125; &#125; /** * 解压 * * @param src * 源文件，需要是zip文件 * @param dest * 目标文件， */ public static void unzip(String src, String dest, OnUnZipOverListener listener) &#123; File destFile = new File(dest); /* 目标文件不存在，创建之 */ if (!destFile.exists()) &#123; destFile.mkdirs(); &#125; /* 构造源文件 */ File srcFile = new File(src); if (!srcFile.exists()) &#123; return; &#125; unzip(srcFile, dest, listener); &#125; /** * 解压 * * @param srcFile * @param destFile */ public static void unzip(File srcFile, String dest, OnUnZipOverListener listener) &#123; BufferedInputStream bis = null; BufferedOutputStream bos = null; try &#123; ZipFile srcZipFile = new ZipFile(srcFile); /* 获得zipentry的枚举 */ Enumeration e = srcZipFile.entries(); ZipEntry entry = null;// ZipInputStream zis = new ZipInputStream(// new FileInputStream(srcFile)); // while((entry=zis.getNextEntry())!=null)&#123; while (e.hasMoreElements()) &#123; entry = (ZipEntry) e.nextElement(); if (entry.toString().equals("/")) &#123; continue; &#125; bis = new BufferedInputStream(srcZipFile.getInputStream(entry)); /* 构建对应输出流 */ bos = new BufferedOutputStream(new FileOutputStream(dest + "/" + entry.getName())); int len = 0; byte[] buffer = new byte[1024]; while ((len = bis.read(buffer)) != -1) &#123; bos.write(buffer, 0, len); &#125; bos.flush(); close(bis); close(bos); &#125; if (listener != null) listener.onUnZipOver(); &#125; catch (ZipException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; close(bis); close(bos); &#125; &#125; /** * 压缩单个或者多个文件,但是不可以同时压缩文件和文件夹 * * @param src * 想要压缩的文件路径，不可以是文件夹 * @param dest * 目标路径，xx.zip */ public static void zipFile(String[] src, String dest, OnZipOverListener listener) &#123; File parent = new File(new File(dest).getParent() + "/temp"); if (!parent.exists()) &#123; parent.mkdirs(); &#125; BufferedInputStream bis = null; BufferedOutputStream bos = null; File file = null; try &#123; int len = 0; byte[] buffer = new byte[1024]; for (String path : src) &#123; file = new File(path); bis = new BufferedInputStream(new FileInputStream(file)); bos = new BufferedOutputStream(new FileOutputStream( parent.getAbsolutePath() + "/" + file.getName())); while ((len = bis.read(buffer)) != -1) &#123; bos.write(buffer, 0, len); &#125; bos.flush(); close(bos); close(bis); &#125; zip(parent, dest, listener); for (File ff : parent.listFiles()) &#123; ff.delete(); &#125; parent.delete(); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; close(bos); close(bis); &#125; &#125; private static void close(Closeable close) &#123; if (close != null) &#123; try &#123; close.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; GZIP压缩 这个没太搞懂，一直在弄加压解压有点烦了，改天再说吧，贴一下已经实现的简单功能。就是加压一个文件，本身GZIP就是一对一的，也就是说每次只能压缩一个文件，我们需要压缩多个问价的时候要使用tar先打包，看到网上有实现这个功能的，但是使用的阿帕奇的第三方库，就没去试,这部分的有点仓促，主要是烦了，写完这个我就去看点别的了，老看一个东西烦得慌，改天会在完善吧。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.Closeable;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.util.zip.GZIPInputStream;import java.util.zip.GZIPOutputStream;/** * * 使用java内置API完成文件的加压解压&lt;/br&gt; * 使用gzip压缩压缩效果更好，但是gzip压缩只能是一对一的，也就是说一个压缩包只能解压出一个文件，所以想压缩多个文件时就需要先使用tar压成一个包 * ，再用gzip压缩 * * @author chendong * */public class GZipUtils &#123; /** * gzip压缩，将一个文件压缩到制定包 * * @param src * @param dest */ public static void gzip(String src) &#123; File srcFile = new File(src); if (!srcFile.exists()) &#123; return; &#125; BufferedInputStream bis = null; GZIPOutputStream gos = null; File destFile = new File(src + ".gz"); try &#123; /* 获得输入流 */ bis = new BufferedInputStream(new FileInputStream(src)); /* 获得压缩输出流 */ gos = new GZIPOutputStream(new BufferedOutputStream( new FileOutputStream(destFile))); int len = 0; byte[] buffer = new byte[1024]; while ((len = bis.read(buffer)) != -1) &#123; gos.write(buffer, 0, len); &#125; gos.flush(); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; close(gos); close(bis); &#125; &#125; /** * 解压 * @param src * @param dest */ public static void ungzip(String src, String dest) &#123; File destFile = new File(dest); File srcFile = new File(src); GZIPInputStream gis = null; BufferedOutputStream bos = null; try &#123; if (!destFile.exists()) &#123; destFile.createNewFile(); &#125; if (!srcFile.exists()) &#123; return; &#125; bos = new BufferedOutputStream(new FileOutputStream(destFile)); gis = new GZIPInputStream(new FileInputStream(srcFile)); int len = 0; byte[] buffer = new byte[1024]; while ((len = gis.read(buffer)) != -1) &#123; bos.write(buffer, 0, len); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; close(bos); close(gis); &#125; &#125; public static void pack(File files[]) &#123; &#125; private static void close(Closeable close) &#123; if (close != null) &#123; try &#123; close.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Study</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保存照片和视频到相册显示]]></title>
    <url>%2Farticle%2F1969447237%2F</url>
    <content type="text"><![CDATA[照片和视频保存到本地的方法大致都是通过流的方式写入文件里面就可以达到保存到文件夹的目的，但是你保存到文件夹的资源却不一定能够在相册显示出来，只能翻看文件管理。怎么能够将保存到本地的照片视频显示在系统相册中，最常用的方式是发送广播扫描的方式来通知系统扫描文件夹，但是这种方式经常不起作用，根本原因在于，向系统发送广播时系统只会去扫描系统资源的相册，如果你保存的文件夹是自己建立的，那么你发广播时系统是不会扫描到的。解决这个问题，想要显示在相册需要将数据插入到ContentProvider中，因此对于非系统能够扫描到的相册我们使用手动插入的方式。 保存到系统资源相册系统相册指的的是Camera、DCIM等等这些目录对应的相册，可能还有其他系统会自动扫描的相册，但是暂时没有去整理这些。对于系统相册来说，只需要发送广播进行扫描即可，数据会自动添加到ContentProvider中，当然如果不发送广播，在手机重启或者过一段时间之后，扫描操作仍会开启，因此绝对绝对不可以自己去进行插入操作，否则相册中会出现两张相同的照片。 12345678910111213/** * 针对系统文夹只需要扫描,不用插入内容提供者,不然会重复 * * @param context 上下文 * @param filePath 文件路径 */private static void scanFile(Context context, String filePath) &#123; if (!checkFile(filePath)) return; Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE); intent.setData(Uri.fromFile(new File(filePath))); context.sendBroadcast(intent);&#125; 保存到非系统资源相册保存到非系统资源相册中时，我们就需要进行ContentProvider的插入更新，来达到可以在相册显示的目的。 初始化 ContentValues 公共字段照片和视频是有一些公共字段，写一个初始化公共字段的方法，简化MediaStore字段的写入操作。 12345678910111213141516171819/** * 插入时初始化公共字段 * * @param filePath 文件 * @param time ms * @return ContentValues */private static ContentValues initCommonContentValues(String filePath, long time) &#123; ContentValues values = new ContentValues(); File saveFile = new File(filePath); long timeMillis = getTimeWrap(time); values.put(MediaStore.MediaColumns.TITLE, saveFile.getName()); values.put(MediaStore.MediaColumns.DISPLAY_NAME, saveFile.getName()); values.put(MediaStore.MediaColumns.DATE_MODIFIED, timeMillis); values.put(MediaStore.MediaColumns.DATE_ADDED, timeMillis); values.put(MediaStore.MediaColumns.DATA, saveFile.getAbsolutePath()); values.put(MediaStore.MediaColumns.SIZE, saveFile.length()); return values;&#125; 插入照片资源保存照片到本地，并通知相册显示，需要注意的时间的单位必须是ms 123456789101112131415161718192021222324252627/** * 保存到照片到本地，并插入MediaStore以保证相册可以查看到 * 这是更优化的方法，防止读取的照片获取不到宽高 * * @param context 上下文 * @param filePath 文件路径 * @param createTime 创建时间 &lt;=0时为当前时间 ms * @param width 宽度 * @param height 高度 */public static void insertImageToMediaStore(Context context, String filePath, long createTime, int width, int height) &#123; if (!checkFile(filePath)) return; createTime = getTimeWrap(createTime); ContentValues values = initCommonContentValues(filePath, createTime); values.put(MediaStore.Images.ImageColumns.DATE_TAKEN, createTime); values.put(MediaStore.Images.ImageColumns.ORIENTATION, 0); values.put(MediaStore.Images.ImageColumns.ORIENTATION, 0); if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.JELLY_BEAN) &#123; if (width &gt; 0) values.put(MediaStore.Images.ImageColumns.WIDTH, 0); if (height &gt; 0) values.put(MediaStore.Images.ImageColumns.HEIGHT, 0); &#125; values.put(MediaStore.MediaColumns.MIME_TYPE, getPhotoMimeType(filePath)); context.getApplicationContext().getContentResolver() .insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);&#125; 插入视频资源保存视频到本地，并通知相册显示，需要注意的时间的单位必须是ms 123456789101112131415161718192021222324252627/** * 保存到视频到本地，并插入MediaStore以保证相册可以查看到 * 这是更优化的方法，防止读取的视频获取不到宽高 * * @param context 上下文 * @param filePath 文件路径 * @param createTime 创建时间 &lt;=0时为当前时间 ms * @param duration 视频长度 ms * @param width 宽度 * @param height 高度 */public static void insertVideoToMediaStore(Context context, String filePath, long createTime, int width, int height, long duration) &#123; if (!checkFile(filePath)) return; createTime = getTimeWrap(createTime); ContentValues values = initCommonContentValues(filePath, createTime); values.put(MediaStore.Video.VideoColumns.DATE_TAKEN, createTime); if (duration &gt; 0) values.put(MediaStore.Video.VideoColumns.DURATION, duration); if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.JELLY_BEAN) &#123; if (width &gt; 0) values.put(MediaStore.Video.VideoColumns.WIDTH, width); if (height &gt; 0) values.put(MediaStore.Video.VideoColumns.HEIGHT, height); &#125; values.put(MediaStore.MediaColumns.MIME_TYPE, getVideoMimeType(filePath)); context.getContentResolver().insert(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, values);&#125; 注意在应用过程中发现，vivo手机和魅族手机部分机型只支持在文件管理中查看视频，使用本文描述的方法添加后没有效果，用微信保存视频试了一下同样不能在相册中将视频显示出来，应该是手机的原因，特此声明。 附源码贴一下工具类源代码，多了一些辅助方法，比如获取mime_type的参数等方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174/** * CreateAt : 2017/5/24 * Describe : 相册更新通知帮助类 * 创建时间单位ms * 视频时长单位ms * * @author chendong */public class AlbumNotifyHelper &#123; public static final String TAG = AlbumNotifyHelper.class.getSimpleName(); /////////////////////////////////////////////////////////////////////////// // 下面是对外公开的重载的方法 /////////////////////////////////////////////////////////////////////////// public static void notifyScanDcim(Context context, String filePath) &#123; scanFile(context, filePath); &#125; public static void insertVideoToMediaStore(Context context, String filePath, long dateTaken, long duration) &#123; insertVideoToMediaStore(context, filePath, dateTaken, 0, 0, duration); &#125; public static void insertVideoToMediaStore(Context context, VideoUtil.VideoInfo videoInfo) &#123; insertVideoToMediaStore(context, videoInfo.originalVideoFilePath, videoInfo.dateTaken, videoInfo.width, videoInfo.height, videoInfo.duringTime); &#125; public static void insertImageToMediaStore(Context context, String filePath, long createTime) &#123; insertImageToMediaStore(context, filePath, createTime, 0, 0); &#125; /////////////////////////////////////////////////////////////////////////// // 扫描系统相册核心方法 /////////////////////////////////////////////////////////////////////////// /** * 针对系统文夹只需要扫描,不用插入内容提供者,不然会重复 * * @param context 上下文 * @param filePath 文件路径 */ public static void scanFile(Context context, String filePath) &#123; if (!checkFile(filePath)) return; Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE); intent.setData(Uri.fromFile(new File(filePath))); context.sendBroadcast(intent); &#125; /////////////////////////////////////////////////////////////////////////// // 非系统相册像MediaContent中插入数据，核心方法 /////////////////////////////////////////////////////////////////////////// /** * 针对非系统文件夹下的文件,使用该方法 * 插入时初始化公共字段 * * @param filePath 文件 * @param time ms * @return ContentValues */ private static ContentValues initCommonContentValues(String filePath, long time) &#123; ContentValues values = new ContentValues(); File saveFile = new File(filePath); long timeMillis = getTimeWrap(time); values.put(MediaStore.MediaColumns.TITLE, saveFile.getName()); values.put(MediaStore.MediaColumns.DISPLAY_NAME, saveFile.getName()); values.put(MediaStore.MediaColumns.DATE_MODIFIED, timeMillis); values.put(MediaStore.MediaColumns.DATE_ADDED, timeMillis); values.put(MediaStore.MediaColumns.DATA, saveFile.getAbsolutePath()); values.put(MediaStore.MediaColumns.SIZE, saveFile.length()); return values; &#125; /** * 保存到照片到本地，并插入MediaStore以保证相册可以查看到,这是更优化的方法，防止读取的照片获取不到宽高 * * @param context 上下文 * @param filePath 文件路径 * @param createTime 创建时间 &lt;=0时为当前时间 ms * @param width 宽度 * @param height 高度 */ public static void insertImageToMediaStore(Context context, String filePath, long createTime, int width, int height) &#123; if (!checkFile(filePath)) return; createTime = getTimeWrap(createTime); ContentValues values = initCommonContentValues(filePath, createTime); values.put(MediaStore.Images.ImageColumns.DATE_TAKEN, createTime); values.put(MediaStore.Images.ImageColumns.ORIENTATION, 0); values.put(MediaStore.Images.ImageColumns.ORIENTATION, 0); if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.JELLY_BEAN) &#123; if (width &gt; 0) values.put(MediaStore.Images.ImageColumns.WIDTH, 0); if (height &gt; 0) values.put(MediaStore.Images.ImageColumns.HEIGHT, 0); &#125; values.put(MediaStore.MediaColumns.MIME_TYPE, getPhotoMimeType(filePath)); context.getApplicationContext().getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values); &#125; /** * 保存到视频到本地，并插入MediaStore以保证相册可以查看到,这是更优化的方法，防止读取的视频获取不到宽高 * * @param context 上下文 * @param filePath 文件路径 * @param createTime 创建时间 &lt;=0时为当前时间 ms * @param duration 视频长度 ms * @param width 宽度 * @param height 高度 */ public static void insertVideoToMediaStore(Context context, String filePath, long createTime, int width, int height, long duration) &#123; if (!checkFile(filePath)) return; createTime = getTimeWrap(createTime); ContentValues values = initCommonContentValues(filePath, createTime); values.put(MediaStore.Video.VideoColumns.DATE_TAKEN, createTime); if (duration &gt; 0) values.put(MediaStore.Video.VideoColumns.DURATION, duration); if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.JELLY_BEAN) &#123; if (width &gt; 0) values.put(MediaStore.Video.VideoColumns.WIDTH, width); if (height &gt; 0) values.put(MediaStore.Video.VideoColumns.HEIGHT, height); &#125; values.put(MediaStore.MediaColumns.MIME_TYPE, getVideoMimeType(filePath)); context.getContentResolver().insert(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, values); &#125; // 是不是系统相册 private static boolean isSystemDcim(String path) &#123; return path.toLowerCase().contains(&quot;dcim&quot;) || path.toLowerCase().contains(&quot;camera&quot;); &#125; // 获取照片的mine_type private static String getPhotoMimeType(String path) &#123; String lowerPath = path.toLowerCase(); if (lowerPath.endsWith(&quot;jpg&quot;) || lowerPath.endsWith(&quot;jpeg&quot;)) &#123; return &quot;image/jpeg&quot;; &#125; else if (lowerPath.endsWith(&quot;png&quot;)) &#123; return &quot;image/png&quot;; &#125; else if (lowerPath.endsWith(&quot;gif&quot;)) &#123; return &quot;image/gif&quot;; &#125; return &quot;image/jpeg&quot;; &#125; // 获取video的mine_type,暂时只支持mp4,3gp private static String getVideoMimeType(String path) &#123; String lowerPath = path.toLowerCase(); if (lowerPath.endsWith(&quot;mp4&quot;) || lowerPath.endsWith(&quot;mpeg4&quot;)) &#123; return &quot;video/mp4&quot;; &#125; else if (lowerPath.endsWith(&quot;3gp&quot;)) &#123; return &quot;video/3gp&quot;; &#125; return &quot;video/mp4&quot;; &#125; // 获得转化后的时间 private static long getTimeWrap(long time) &#123; if (time &lt;= 0) &#123; return System.currentTimeMillis(); &#125; return time; &#125; // 检测文件存在 private static boolean checkFile(String filePath) &#123; boolean result = FileUtil.fileIsExist(filePath); Log.e(TAG, &quot;文件不存在 path = &quot; + filePath); return result; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义控件九宫格滑动解锁]]></title>
    <url>%2Farticle%2F2317215752%2F</url>
    <content type="text"><![CDATA[1. 前言 最近想给自己做的的app添加一个滑动解锁的功能，用的是乐视的手机，就模仿它的效果实现. 视频演示一下效果 GitHub 2. LockPoint实体 每个点是一个实体（LockPoint）用来存储这个点的所有信息，包括点的物理位置(x,y)和点的index位置(0-8) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class LockPoint &#123; // 点的位置 0-8 int index; // 点的x,y坐标 float x, y; // 构造方法，初始化一个点 LockPoint(int index, float x, float y) &#123; this.index = index; this.x = x; this.y = y; &#125; // 构造方法，从另一个点初始化 LockPoint(LockPoint p) &#123; this.x = p.x; this.y = p.y; this.index = p.index; &#125; // 默认构造方法，初始化为一个空的点 LockPoint() &#123; this.x = -1; this.y = -1; this.index = -1; &#125; // 判断该点是不是一个空的点 boolean isEmpty() &#123; return this.x == -1 &amp;&amp; this.y == -1; &#125; // 重新给位置赋值 void init(float x, float y) &#123; this.x = x; this.y = y; &#125; // 设置为另一点的值 void init(LockPoint p) &#123; this.x = p.x; this.y = p.y; this.index = p.index; &#125; // 判断一个位置是不是在该点触摸范围内,touchSensitiveRange为触摸有效半径 boolean isTouchIn(float judgeX, float judgeY) &#123; return judgeX &lt; x + touchSensitiveRange &amp;&amp; judgeX &gt; x - touchSensitiveRange &amp;&amp; judgeY &lt; y + touchSensitiveRange &amp;&amp; judgeY &gt; y - touchSensitiveRange; &#125; // 重写equals和hashCode @Override public boolean equals(Object o) &#123; LockPoint p = (LockPoint) o; return p.x == x &amp;&amp; p.y == y; &#125; @Override public int hashCode() &#123; return 2; &#125; String out(String tag) &#123; return tag + " : x = " + x + " , y = " + y; &#125; &#125; 3. 初始化 初始化九个点的位置，需要根据控件的大小动态计算，因此在onMeare()之后进行 需求是需要将九个点放在控件中间，来适应控件大小的变化，首先确定第一个点距离左边的距离startSpace，两个点之间的距离 =（控件宽度 - 2 * startSpace）／2 123456789101112int size = getMeasuredWidth(); // 将宽高设置为一样的，正方形 setMeasuredDimension(size, size); // 初始化屏幕中的九个点的位置和下标 initLockPointArray = new LockPoint[9]; // startSpace 为距离左边的距离，计算九个点的位置,保证九个点放在控件中间 if (startSpace == AUTO_START_SPACING) &#123; //默认是控件的1/4 startSpace = size / 4; &#125; // 计算每两个点之间的间隔 internalSpace = (size - 2 * startSpace) / 2; 初始化九个点的位置 12345678// 初始化九个点的位置 int index = 0; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; initLockPointArray[index] = new LockPoint(index, startSpace + j * internalSpace, startSpace + i * internalSpace); index++; &#125; &#125; onMeasure()完整代码 123456789101112131415161718192021222324252627282930// onMeasure之后初始化数据 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int size = getMeasuredWidth(); // 将宽高设置为一样的，正方形 setMeasuredDimension(size, size); // 初始化屏幕中的九个点的位置和下标 if (initLockPointArray == null) &#123; initLockPointArray = new LockPoint[9]; // startSpace 为距离左边的距离，计算九个点的位置放在控件中间 if (startSpace == AUTO_START_SPACING) &#123; startSpace = size / 4; &#125; // 计算每两个点之间的间隔 internalSpace = (size - 2 * startSpace) / 2; // 初始化九个点的位置 int index = 0; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; initLockPointArray[index] = new LockPoint(index, startSpace + j * internalSpace, startSpace + i * internalSpace); index++; &#125; &#125; // 为了在preview时能看到效果 if (isInEditMode()) &#123; historyPointList.addAll(Arrays.asList(initLockPointArray)); &#125; &#125; &#125; 4. onDraw 绘制过程大致分为三个步骤 绘制九个点，这是每次都需要绘制的 1234LockPoint tempPoint;for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; canvas.drawCircle(initLockPointArray[i].x, initLockPointArray[i].y, pointRadius, pointPaint);&#125; 绘制已经划过的点 123456// 绘制之前触过存储起来的的点,绘制第i个点和i+1个点之间的线 if (historyPointList.size() &gt; 0) &#123; for (int i = 0; i &lt; historyPointList.size() - 1; i++) &#123; canvas.drawLine(historyPointList.get(i).x, historyPointList.get(i).y, historyPointList.get(i + 1).x, historyPointList.get(i + 1).y, linePaint); &#125; &#125; 绘制触摸点和最后一个点的连线 123456// 画最后一个点和触摸的点之间的线 if (currentLockPoint != null &amp;&amp; currentLockPoint.x != -1 &amp;&amp; currentLockPoint.y != -1 &amp;&amp; touchPoint.x != -1 &amp;&amp; touchPoint.y != -1) &#123; canvas.drawLine(currentLockPoint.x, currentLockPoint.y, touchPoint.x, touchPoint.y, linePaint); &#125; 5. 事件处理 对用户touch事件进行处理 要记录当前触摸的点，用于绘制跟随手指的连线 检测触摸的点是不是在九个点中某个点的范围内，如果是的话该点要加入被触摸点的列表中 当手指抬起时，清除数据,恢复初始状态 12345678910111213141516171819202122232425262728293031323334353637@Override public boolean onTouchEvent(MotionEvent event) &#123; if (!isEnabled() || isEventOver) return false; int action = MotionEventCompat.getActionMasked(event); switch (action) &#123; // 重新初始化触摸点 case MotionEvent.ACTION_DOWN: touchPoint.init(event.getX(), event.getY()); break; // 移动时检测是否在触摸范围内 case MotionEvent.ACTION_MOVE: touchPoint.init(event.getX(), event.getY()); LockPoint tempPoint; for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; tempPoint = initLockPointArray[i]; if (!historyPointList.contains(tempPoint) &amp;&amp; tempPoint.isTouchIn(event.getX(), event.getY())) &#123; historyPointList.add(new LockPoint(tempPoint)); currentLockPoint.init(tempPoint); break; &#125; &#125; break; // 抬起时结束，重新初始化 case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: touchPoint.init(-1, -1); currentLockPoint.init(-1, -1); historyPointList.clear(); break; &#125; postInvalidate(); return true; &#125; 6. 优化-多点触控事件处理 用户在触摸屏幕时可能有多个手指在操作，上面的代码在单指时没有问题，兼容多点触控的思路是： 当用户触发down事件时，我们可以获取到一个pointerId，这个id唯一的标志了这个指头，后面发生的所有事件都使用用这个pointerId来获取，只处理这个指头的事件，避免事件的错乱。 当我们开始的时候标志的那个手指抬起来了怎么办呢，两个解决方法，第一个就是直接结束整个流程，相当于单指时手指抬起。第二个方法就是转移事件，当一个指头抬起时，从该事件中获取还没抬起的手指，更改标志的pointerId,事件就转移到了另一个手指上，我们关心就是新手指的触摸啦 关于对于事件进行处理的相关机制可以看Android事件机制，写的都是比较基本的东西，后面慢慢完善，不过理解获取多指的事件9⃣️绰绰有余啦 话不多说，上代码，比较需要注意的地方我都标注在注释中，方便查找 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 处理触摸事件，支持多点触摸 @Override public boolean onTouchEvent(MotionEvent event) &#123; // fast stop if (!isEnabled() || isEventOver) return false; // pointerIndex 是事件的在event中的下标 int pointerIndex; // 获取事件掩码 int action = MotionEventCompat.getActionMasked(event); switch (action) &#123; // 重新初始化触摸点 case MotionEvent.ACTION_DOWN: // pointerId 记录当前激活的pointerId activePointerId = event.getPointerId(0); // 根据pointerId查找事件在event中的位置 pointerIndex = event.findPointerIndex(activePointerId); // 根据位置获取到具体的事件的坐标，这里获得的坐标就是我们要记住的那个指头的坐标 touchPoint.init(event.getX(pointerIndex), event.getY(pointerIndex)); break; case MotionEvent.ACTION_MOVE: // 手指移动时还是根据激活的pointerId获取下标index,来进行后续操作，避免事件错乱 pointerIndex = event.findPointerIndex(activePointerId); // pointerIndex &lt; 0表示手指的事件获取不到了，结束响应事件 if (pointerIndex &lt; 0) &#123; Log.e(TAG, "Got ACTION_MOVE event but have an invalid active pointer id."); cancelLockDraw(); return false; &#125; // 根据移动的位置获取坐标，初始化touchPoint的值 touchPoint.init(event.getX(pointerIndex), event.getY(pointerIndex)); LockPoint tempPoint; // 检索触摸点有没有在九个点中的某一个的触摸范围内 for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; tempPoint = initLockPointArray[i]; if (!historyPointList.contains(tempPoint) &amp;&amp; tempPoint.isTouchIn(event.getX(pointerIndex), event.getY(pointerIndex))) &#123; LockPoint centerPoint = findCenterPoint(tempPoint); // 优化，查找两个点之间的点，后面会有介绍 if (!centerPoint.isEmpty()) &#123; activePoint(centerPoint); &#125; activePoint(tempPoint); break; &#125; &#125; break; case MotionEventCompat.ACTION_POINTER_UP: // 多指操作中 非 最后一个手指抬起时触发ACTION_POINTER_UP，此时要获取还在屏幕上的其他手指转移事件的对象 onSecondaryPointerUp(event); break; case MotionEvent.ACTION_UP: // 最后的手指抬起触发 ACTION_UP pointerIndex = event.findPointerIndex(activePointerId); if (pointerIndex &lt; 0) &#123; Log.e(TAG, "Got ACTION_UP event but don't have an active pointer id."); activePointerId = INVALID_POINTER; return false; &#125; // 发布绘制的结果，可能是监听回调之类的 publishResult(); // 置为-1 activePointerId = INVALID_POINTER; break; case MotionEvent.ACTION_CANCEL: // 类似up cancelLockDraw(); activePointerId = INVALID_POINTER; break; &#125; postInvalidate(); return true; &#125; 转移焦点的方法,在各种控件的源代码中随处可见，我也是拷贝出来直接用的，逻辑不是很复杂 123456789101112131415 /** * 当一个手机抬起时，转移焦点 * * @param ev 事件 */private void onSecondaryPointerUp(MotionEvent ev) &#123; final int pointerIndex = MotionEventCompat.getActionIndex(ev); final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex); if (pointerId == activePointerId) &#123; // This was our active pointer going up. Choose a new // active pointer and adjust accordingly. final int newPointerIndex = pointerIndex == 0 ? 1 : 0; activePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex); &#125; &#125; 发布结果 123456789101112131415161718192021222324/** * 发布绘制结果 */ private void publishResult() &#123; if (listener != null) &#123; isEventOver = true; StringBuilder sb = new StringBuilder(); for (LockPoint lockPoint : historyPointList) &#123; sb.append(lockPoint.index); &#125; String passWd = sb.toString(); boolean isFinish = listener.onFinish(LockView.this, passWd, passWd.length()); if (isFinish) &#123; // 输入合法 touchPoint.init(currentLockPoint); &#125; else &#123; // 输入不合法 cancelLockDraw(); isEventOver = false; &#125; &#125; else &#123; cancelLockDraw(); &#125; &#125; 回复初始状态,因为在多处调用了，贴一下 123456789/** * 结束绘制，恢复初始状态 */ private void cancelLockDraw() &#123; touchPoint.init(-1, -1); currentLockPoint.init(-1, -1); historyPointList.clear(); postInvalidate(); &#125; 7. 优化-自动添加两点之间连线上的点 当滑动时越过中间的点之间连接两端，自动查找和添加两点之间的点，手机上的滑动解锁也是这样的逻辑，不然会导致图形很繁琐，不美观而且不符合常见逻辑。也就是说如果当前激发的点和上一个激发的点之间有没有激发的点，那么自动给他激发。 首先如果两个点是相邻的或者是对角线上相邻，那么中间一定不会有空下来的点，需要排除这个情况 123456789101112131415161718/** * 检测相邻 * * @param p1 点1 * @param p2 点2 * @return p1和p2是否相邻，斜对角也算相邻 */ private boolean isAdjacentPoint(LockPoint p1, LockPoint p2) &#123; // internalSpace是初始化时两个点之间的距离，都是简单的计算和情况罗列 if ((p1.x == p2.x &amp;&amp; Math.abs(p1.y - p2.y) == internalSpace) || (p1.y == p2.y &amp;&amp; Math.abs(p1.x - p2.x) == internalSpace) || (Math.abs(p1.x - p2.x) == internalSpace &amp;&amp; Math.abs(p1.y - p2.y) == internalSpace)) &#123; Log.e(TAG, "相邻点，不处理"); return true; &#125; return false; &#125; 然后如何判断一个点位于首尾两个激发点的中间，思路是当这个点在两个点的连线上时且不是首尾两个点就是中间的点。判断的根据是斜率是不是相等，就是初中的数学问题啦。 12345678910111213/** * 判断c点是不是在p1-p2的直线上 * * @param p1 起始点 * @param p2 终止点 * @param c 判断的点 * @return 是否在该线上 */ private boolean isInLine(LockPoint p1, LockPoint p2, LockPoint c) &#123; float k1 = (p1.x - p2.x) * 1f / (p1.y - p2.y); float k2 = (p1.x - c.x) * 1f / (p1.y - c.y); return k1 == k2; &#125; 最后整合一下，去掉不必要的判断，在touch事件中调用 123456789101112131415161718192021222324252627282930313233/** * 检测当前激活的点和上一个激活点之间的是否有没有激发的点 * * @param activePoint 当前被激发的点 * @return 当前激活的点和上一个激活点之间的是否有没有激发的点，没有返回empty的&#123;@link LockPoint#isEmpty()&#125; */ private LockPoint findCenterPoint(LockPoint activePoint) &#123; LockPoint rstPoint = new LockPoint(); // 只有一个点不需要比较 if (historyPointList.size() &lt; 1) &#123; return rstPoint; &#125; LockPoint tempPoint; // 获取上个点 LockPoint preActivePoint = historyPointList.get(historyPointList.size() - 1); // 两个点是不是相邻的，是相邻的是坚决不会中间有点被空出来的 if (isAdjacentPoint(preActivePoint, activePoint)) return rstPoint; for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; tempPoint = initLockPointArray[i]; // 没有被触摸过 &amp;&amp; 不是首点 &amp;&amp; 不是尾点 if (!historyPointList.contains(tempPoint) &amp;&amp; !preActivePoint.equals(tempPoint) &amp;&amp; !activePoint.equals(tempPoint)) &#123; // 在连线上 if (isInLine(preActivePoint, activePoint, tempPoint)) &#123; Log.e(TAG, "点在线上 " + tempPoint.out("temp") + " " + preActivePoint.out("pre") + " " + activePoint.out("active")); rstPoint.init(tempPoint); break; &#125; &#125; &#125; return rstPoint; &#125; 在onTouchEvent中调用 123456LockPoint centerPoint = findCenterPoint(tempPoint); // 优化，查找两个点之间的点 if (!centerPoint.isEmpty()) &#123; activePoint(centerPoint); &#125; activePoint(tempPoint); 8. 优化-给被触摸的点添加动画 当手指触摸到一个点时，添加一个缩放动画来反馈触摸操作 思路时，当触摸到一个点时使用ValueAnimator开启动画，不断改变半径的值，在绘制时达到实现缩放的效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 开始缩放动画 */ private void startScaleAnimation() &#123; if (mScaleAnimator == null) &#123; mScaleAnimator = ValueAnimator.ofFloat(1f, scaleMax, 1f); mScaleAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float scale = (float) animation.getAnimatedValue(); // 不断改变半径的值 scalePointRadius = pointRadius * scale; postInvalidate(); &#125; &#125;); mScaleAnimator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; &#125; @Override public void onAnimationEnd(Animator animation) &#123; // 动画结束后初始化回标准半径的值 scalePointRadius = pointRadius; &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; &#125;); mScaleAnimator.setDuration(scaleAnimDuration); &#125; if (mScaleAnimator.isRunning()) mScaleAnimator.end(); mScaleAnimator.start(); &#125; 同时在onDraw()方法中对刚刚触摸的点要进行绘制,更改onDraw()方法中绘制九个点的部分，对刚刚触摸的点使用缩放后的半径绘制。 1234567891011// 绘制九个点，当动画在执行时被激活的点会被放大 LockPoint tempPoint; for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; tempPoint = initLockPointArray[i]; // 最后触摸的点 if (currentLockPoint != null &amp;&amp; currentLockPoint.equals(tempPoint)) &#123; canvas.drawCircle(tempPoint.x, tempPoint.y, scalePointRadius, pointPaint); &#125; else &#123; canvas.drawCircle(tempPoint.x, tempPoint.y, pointRadius, pointPaint); &#125; &#125; 9. 回调 使用监听将结果回调给使用者，在ACTION_UP时发布结果 12345678910111213141516171819202122232425262728293031323334353637public interface OnLockFinishListener &#123; /** * * @param lockView 控件 * @param passWd 密码 * @param passWsLength 密码长度 * @return 当返回true时，画面将会定格在绘制结束后的状态，比如当密码输入正确的时候 * 返回false时，画面会重新初始化回初始状态，比如密码重新二次输入确认或者密码错误的时候 */ boolean onFinish(LockView lockView, String passWd, int passWsLength); &#125; /** * 发布绘制结果 */ private void publishResult() &#123; if (listener != null) &#123; isEventOver = true; StringBuilder sb = new StringBuilder(); for (LockPoint lockPoint : historyPointList) &#123; sb.append(lockPoint.index); &#125; String passWd = sb.toString(); boolean isFinish = listener.onFinish(LockView.this, passWd, passWd.length()); if (isFinish) &#123; // 画面定格 touchPoint.init(currentLockPoint); &#125; else &#123; // 恢复初始化 cancelLockDraw(); isEventOver = false; &#125; &#125; else &#123; cancelLockDraw(); &#125; &#125; 10. 综上 还遗留了一个点，就是自动添加中间的点时应该也是有动画效果的，暂时还没做，有空补上吧，希望大家指正。 11. 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514/** * Project : CdLibsTest * Package : com.march.cdlibstest.widget * CreateAt : 2016/11/26 * Describe : 自定义控件实现九宫格滑动解锁 * * @author chendong */public class LockView extends View &#123; public static final String TAG = "LOCK_VIEW"; private static final int INVALID_POINTER = -1; private static final int AUTO_START_SPACING = -1; private static final int DEFAULT_MIN_POINT_NUM = 4; // 激活的触摸点id private int activePointerId = INVALID_POINTER; // 四边的间隔，默认是控件的1／4 private int startSpace; // 两点间隔 private int internalSpace; // 点的半径 private int pointRadius; // 动画scale的半径 private float scalePointRadius; // 触摸半径，在点的一定范围内触发 private int touchSensitiveRange; // 线宽度 private int lineWidth; // 点颜色 private int pointColor; // 线颜色 private int lineColor; // 缩放的大小 private float scaleMax; // 动画时间 private int scaleAnimDuration = 150; // 本次绘制结束，调用init()方法恢复初始化 private boolean isEventOver = false; class LockPoint &#123; // 点的位置 0-8 int index; // 点的x,y坐标 float x, y; // 构造方法，初始化一个点 LockPoint(int index, float x, float y) &#123; this.index = index; this.x = x; this.y = y; &#125; // 构造方法，从另一个点初始化 LockPoint(LockPoint p) &#123; this.x = p.x; this.y = p.y; this.index = p.index; &#125; // 默认构造方法，初始化为一个空的点 LockPoint() &#123; this.x = -1; this.y = -1; this.index = -1; &#125; // 判断该点是不是一个空的点 boolean isEmpty() &#123; return this.x == -1 &amp;&amp; this.y == -1; &#125; // 重新给位置赋值 void init(float x, float y) &#123; this.x = x; this.y = y; &#125; // 设置为另一点的值 void init(LockPoint p) &#123; this.x = p.x; this.y = p.y; this.index = p.index; &#125; // 判断一个位置是不是在该点触摸范围内,touchSensitiveRange为触摸有效半径 boolean isTouchIn(float judgeX, float judgeY) &#123; return judgeX &lt; x + touchSensitiveRange &amp;&amp; judgeX &gt; x - touchSensitiveRange &amp;&amp; judgeY &lt; y + touchSensitiveRange &amp;&amp; judgeY &gt; y - touchSensitiveRange; &#125; // 重写equals和hashCode @Override public boolean equals(Object o) &#123; LockPoint p = (LockPoint) o; return p.x == x &amp;&amp; p.y == y; &#125; @Override public int hashCode() &#123; return 2; &#125; String out(String tag) &#123; return tag + " : x = " + x + " , y = " + y; &#125; &#125; // 动画 private ValueAnimator mScaleAnimator; // 初始化的九个点 private LockPoint[] initLockPointArray; // 触摸过的点泪飙 private List&lt;LockPoint&gt; historyPointList; // 触摸的点 private LockPoint touchPoint; // 当前最后一个激活的点 private LockPoint currentLockPoint; // 画线 private Paint linePaint; // 画点 private Paint pointPaint; // 监听 private OnLockFinishListener listener; public interface OnLockFinishListener &#123; /** * * @param lockView 控件 * @param passWd 密码 * @param passWsLength 密码长度 * @return 当返回true时，画面将会定格在绘制结束后的状态 * 返回false时，画面会重新初始化回初始状态 */ boolean onFinish(LockView lockView, String passWd, int passWsLength); &#125; public LockView(Context context) &#123; this(context, null); &#125; public LockView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public LockView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.LockView); float density = getResources().getDisplayMetrics().density; pointRadius = (int) typedArray.getDimension(R.styleable.LockView_lock_pointRadius, (8 * density)); scalePointRadius = pointRadius; touchSensitiveRange = (int) typedArray.getDimension(R.styleable.LockView_lock_touchSensitiveRange, pointRadius * 3); startSpace = (int) typedArray.getDimension(R.styleable.LockView_lock_startSpace, AUTO_START_SPACING); lineWidth = (int) typedArray.getDimension(R.styleable.LockView_lock_lineWidth, (5 * density)); lineColor = typedArray.getColor(R.styleable.LockView_lock_lineColor, Color.WHITE); pointColor = typedArray.getColor(R.styleable.LockView_lock_pointColor, Color.WHITE); scaleAnimDuration = typedArray.getInt(R.styleable.LockView_lock_scaleAnimDuration, 180); scaleMax = typedArray.getFloat(R.styleable.LockView_lock_scaleMax, 2.5f); typedArray.recycle(); historyPointList = new ArrayList&lt;&gt;(); touchPoint = new LockPoint(); currentLockPoint = new LockPoint(); pointPaint = new Paint(); pointPaint.setAntiAlias(true); pointPaint.setColor(pointColor); pointPaint.setStyle(Paint.Style.FILL_AND_STROKE); linePaint = new Paint(); linePaint.setAntiAlias(true); linePaint.setStrokeWidth(lineWidth); linePaint.setColor(lineColor); linePaint.setStyle(Paint.Style.STROKE); &#125; public void setListener(OnLockFinishListener listener) &#123; this.listener = listener; &#125; /** * 开始缩放动画 */ private void startScaleAnimation() &#123; if (mScaleAnimator == null) &#123; mScaleAnimator = ValueAnimator.ofFloat(1f, scaleMax, 1f); mScaleAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float scale = (float) animation.getAnimatedValue(); scalePointRadius = pointRadius * scale; postInvalidate(); &#125; &#125;); mScaleAnimator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; &#125; @Override public void onAnimationEnd(Animator animation) &#123; scalePointRadius = pointRadius; &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; &#125;); mScaleAnimator.setDuration(scaleAnimDuration); &#125; if (mScaleAnimator.isRunning()) mScaleAnimator.end(); mScaleAnimator.start(); &#125; // 处理触摸事件，支持多点触摸 @Override public boolean onTouchEvent(MotionEvent event) &#123; // fast stop if (!isEnabled() || isEventOver) return false; // pointerIndex 是事件的在event中的下标 int pointerIndex; // 获取事件掩码 int action = MotionEventCompat.getActionMasked(event); switch (action) &#123; // 重新初始化触摸点 case MotionEvent.ACTION_DOWN: // pointerId 记录当前激活的pointerId activePointerId = event.getPointerId(0); // 根据pointerId查找事件在event中的位置 pointerIndex = event.findPointerIndex(activePointerId); // 根据位置获取到具体的事件的坐标，这里获得的坐标就是我们要记住的那个指头的坐标 touchPoint.init(event.getX(pointerIndex), event.getY(pointerIndex)); break; case MotionEvent.ACTION_MOVE: // 手指移动时还是根据激活的pointerId获取下标index,来进行后续操作，避免事件错乱 pointerIndex = event.findPointerIndex(activePointerId); // pointerIndex &lt; 0表示手指的事件获取不到了，结束响应事件 if (pointerIndex &lt; 0) &#123; Log.e(TAG, "Got ACTION_MOVE event but have an invalid active pointer id."); cancelLockDraw(); return false; &#125; // 根据移动的位置获取坐标，初始化touchPoint的值 touchPoint.init(event.getX(pointerIndex), event.getY(pointerIndex)); LockPoint tempPoint; // 检索触摸点有没有在九个点中的某一个的触摸范围内 for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; tempPoint = initLockPointArray[i]; if (!historyPointList.contains(tempPoint) &amp;&amp; tempPoint.isTouchIn(event.getX(pointerIndex), event.getY(pointerIndex))) &#123; LockPoint centerPoint = findCenterPoint(tempPoint); if (!centerPoint.isEmpty()) &#123; activePoint(centerPoint); &#125; activePoint(tempPoint); break; &#125; &#125; break; case MotionEventCompat.ACTION_POINTER_UP: // 多指操作中 非 最后一个手指抬起时触发ACTION_POINTER_UP，此时要获取还在屏幕上的其他手指转移事件的对象 onSecondaryPointerUp(event); break; case MotionEvent.ACTION_UP: // 最后的手指抬起触发 ACTION_UP pointerIndex = event.findPointerIndex(activePointerId); if (pointerIndex &lt; 0) &#123; Log.e(TAG, "Got ACTION_UP event but don't have an active pointer id."); activePointerId = INVALID_POINTER; return false; &#125; // 发布绘制的结果，可能是监听回调之类的 publishResult(); // 置为-1 activePointerId = INVALID_POINTER; break; case MotionEvent.ACTION_CANCEL: // 类似up cancelLockDraw(); activePointerId = INVALID_POINTER; break; &#125; postInvalidate(); return true; &#125; /** * 发布绘制结果 */ private void publishResult() &#123; if (listener != null) &#123; isEventOver = true; StringBuilder sb = new StringBuilder(); for (LockPoint lockPoint : historyPointList) &#123; sb.append(lockPoint.index); &#125; String passWd = sb.toString(); boolean isFinish = listener.onFinish(LockView.this, passWd, passWd.length()); if (isFinish) &#123; // 输入合法 touchPoint.init(currentLockPoint); &#125; else &#123; // 输入不合法 cancelLockDraw(); isEventOver = false; &#125; &#125; else &#123; cancelLockDraw(); &#125; &#125; /** * 当一个手机抬起时，转移焦点 * * @param ev 事件 */ private void onSecondaryPointerUp(MotionEvent ev) &#123; final int pointerIndex = MotionEventCompat.getActionIndex(ev); final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex); if (pointerId == activePointerId) &#123; // This was our active pointer going up. Choose a new // active pointer and adjust accordingly. final int newPointerIndex = pointerIndex == 0 ? 1 : 0; activePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex); &#125; &#125; /** * 检测当前激活的点和上一个激活点之间的是否有没有激发的点 * * @param activePoint 当前被激发的点 * @return 当前激活的点和上一个激活点之间的是否有没有激发的点，没有返回empty的&#123;@link LockPoint#isEmpty()&#125; */ private LockPoint findCenterPoint(LockPoint activePoint) &#123; LockPoint rstPoint = new LockPoint(); // 只有一个点不需要比较 if (historyPointList.size() &lt; 1) &#123; return rstPoint; &#125; LockPoint tempPoint; // 获取上个点 LockPoint preActivePoint = historyPointList.get(historyPointList.size() - 1); // 两个点是不是相邻的，是相邻的是坚决不会中间有点被空出来的 if (isAdjacentPoint(preActivePoint, activePoint)) return rstPoint; for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; tempPoint = initLockPointArray[i]; // 没有被触摸过 &amp;&amp; 不是首点 &amp;&amp; 不是尾点 if (!historyPointList.contains(tempPoint) &amp;&amp; !preActivePoint.equals(tempPoint) &amp;&amp; !activePoint.equals(tempPoint)) &#123; if (isInLine(preActivePoint, activePoint, tempPoint)) &#123; Log.e(TAG, "点在线上 " + tempPoint.out("temp") + " " + preActivePoint.out("pre") + " " + activePoint.out("active")); rstPoint.init(tempPoint); break; &#125; &#125; &#125; return rstPoint; &#125; /** * 检测相邻 * * @param p1 点1 * @param p2 点2 * @return p1和p2是否相邻，斜对角也算相邻 */ private boolean isAdjacentPoint(LockPoint p1, LockPoint p2) &#123; if ((p1.x == p2.x &amp;&amp; Math.abs(p1.y - p2.y) == internalSpace) || (p1.y == p2.y &amp;&amp; Math.abs(p1.x - p2.x) == internalSpace) || (Math.abs(p1.x - p2.x) == internalSpace &amp;&amp; Math.abs(p1.y - p2.y) == internalSpace)) &#123; Log.e(TAG, "相邻点，不处理"); return true; &#125; return false; &#125; /** * 判断c点是不是在p1-p2的直线上 * * @param p1 起始点 * @param p2 终止点 * @param c 判断的点 * @return 是否在该线上 */ private boolean isInLine(LockPoint p1, LockPoint p2, LockPoint c) &#123; float k1 = (p1.x - p2.x) * 1f / (p1.y - p2.y); float k2 = (p1.x - c.x) * 1f / (p1.y - c.y); return k1 == k2; &#125; /** * 激活该点，该点将会添加到选中点列表中，然后执行动画 * * @param tempPoint 被激活的点 */ private void activePoint(LockPoint tempPoint) &#123; historyPointList.add(new LockPoint(tempPoint)); currentLockPoint.init(tempPoint); startScaleAnimation(); postInvalidate(); &#125; public void init() &#123; isEventOver = false; cancelLockDraw(); &#125; /** * 结束绘制，恢复初始状态 */ private void cancelLockDraw() &#123; touchPoint.init(-1, -1); currentLockPoint.init(-1, -1); historyPointList.clear(); postInvalidate(); &#125; // onMeasure之后初始化数据 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int size = getMeasuredWidth(); // 将宽高设置为一样的，正方形 setMeasuredDimension(size, size); // 初始化屏幕中的九个点的位置和下标 if (initLockPointArray == null) &#123; initLockPointArray = new LockPoint[9]; // startSpace 为距离左边的距离，计算九个点的位置放在控件中间 if (startSpace == AUTO_START_SPACING) &#123; startSpace = size / 4; &#125; // 计算每两个点之间的间隔 internalSpace = (size - 2 * startSpace) / 2; // 初始化九个点的位置 int index = 0; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; initLockPointArray[index] = new LockPoint(index, startSpace + j * internalSpace, startSpace + i * internalSpace); index++; &#125; &#125; // 为了在preview时能看到效果 if (isInEditMode()) &#123; historyPointList.addAll(Arrays.asList(initLockPointArray)); &#125; &#125; &#125; private void log(Object... objs) &#123; StringBuilder sb = new StringBuilder(); for (Object obj : objs) &#123; sb.append(obj.toString()).append(" "); &#125; Log.e(TAG, sb.toString()); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // fast stop if (initLockPointArray == null) return; log(currentLockPoint.out("current"), touchPoint.out("touch")); // 画最后一个点和触摸的点之间的线 if (currentLockPoint != null &amp;&amp; currentLockPoint.x != -1 &amp;&amp; currentLockPoint.y != -1 &amp;&amp; touchPoint.x != -1 &amp;&amp; touchPoint.y != -1) &#123; canvas.drawLine(currentLockPoint.x, currentLockPoint.y, touchPoint.x, touchPoint.y, linePaint); &#125; // 绘制之前触过存储起来的的点 if (historyPointList.size() &gt; 0) &#123; for (int i = 0; i &lt; historyPointList.size() - 1; i++) &#123; canvas.drawLine(historyPointList.get(i).x, historyPointList.get(i).y, historyPointList.get(i + 1).x, historyPointList.get(i + 1).y, linePaint); &#125; &#125; // 绘制九个点，当动画在执行时被激活的点会被放大 LockPoint tempPoint; for (int i = 0; i &lt; initLockPointArray.length; i++) &#123; tempPoint = initLockPointArray[i]; if (currentLockPoint != null &amp;&amp; currentLockPoint.equals(tempPoint)) &#123; canvas.drawCircle(tempPoint.x, tempPoint.y, scalePointRadius, pointPaint); &#125; else &#123; canvas.drawCircle(tempPoint.x, tempPoint.y, pointRadius, pointPaint); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密解密（DES,AES）]]></title>
    <url>%2Farticle%2F3556316359%2F</url>
    <content type="text"><![CDATA[加密解密的原理是个很麻烦的问题，我之前上过一门课叫密码学，最后也没怎么学懂，所以这里我们只是使用java代码实现加密解密的功能，而不是讨论他的原理。 DES简单介绍 DES(Data Encryption Standard)即数据加密标准，使用56bit密钥，将64bit的明文数据块加密为64bit密文。 DES使用56bit密钥加密，秘钥要求8个字节64bit，每个字节有一位是奇偶校验位。 DES加密强度小，容易被破解 DES加密代码实现123456789101112131415161718192021222324252627282930313233343536373839404142/** * DES加密解密 * @param data 需要加密的数据 * @param key 秘钥，必须是8个字节 * @param mode 加密或者解密模式 * Cipher.ENCRYPT_MODE * Cipher.DECRYPT_MODE * @return */ public static byte[] DESCrypt(byte[] data, byte[] key, int mode) &#123; byte[] result = null; if (data == null || key == null || data.length &lt;= 0 || key.length &lt;= 0) return null; //DES密码必须是8个字节，64bit长度 try &#123; //创建加密引擎 Cipher cipher = Cipher.getInstance("DES"); //指定8个字节密码 DESKeySpec desKeySpec = new DESKeySpec(key); //生成密码工厂 SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance("DES"); //生成密码 SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec); //设置模式，加密解密 cipher.init(mode, secretKey); //加密。设置字节数组作为待加密内容,返回值是最终加密结果 result = cipher.doFinal(data); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeySpecException e) &#123; e.printStackTrace(); &#125; catch (BadPaddingException e) &#123; e.printStackTrace(); &#125; catch (IllegalBlockSizeException e) &#123; e.printStackTrace(); &#125; return result; &#125; AES简单介绍 AES(Advanced Encryption Standard)，即为高级加密标准。在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。AES的区块长度固定为128 比特，密钥长度则可以是128，192或256比特； 低强度加密代码实现12345678910111213141516171819202122232425262728293031/** * AES低强度加密解密 * @param data * @param key * @param mode Cipher.ENCRYPT_MODE * Cipher.DECRYPT_MODE * @return */ public static byte[] AESCrypt(byte[] data,byte[] key,int mode)&#123; byte[] result = null; if (data == null || key == null || data.length &lt;= 0 || key.length &lt;= 0) return null; try &#123; Cipher cipher = Cipher.getInstance("AES"); SecretKeySpec secretKeySpec = new SecretKeySpec(key,"AES"); cipher.init(mode,secretKeySpec); result = cipher.doFinal(data); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (BadPaddingException e) &#123; e.printStackTrace(); &#125; catch (IllegalBlockSizeException e) &#123; e.printStackTrace(); &#125; return result; &#125; 高强度加密，使用iv参数1234567891011121314151617181920212223242526272829303132333435/** * AES高强度加密 * * @param data * @param key * @param iv 用于AES/CBC、PKCS5Padding这个带有加密模式的算法 * @param mode * @return */ public static byte[] AESCrypt(byte[] data, byte[] key, byte[] iv, int mode) &#123; byte[] result = null; if (data == null || key == null || data.length &lt;= 0 || key.length &lt;= 0) return null; try &#123; Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); SecretKeySpec secretKeySpec = new SecretKeySpec(key, "AES"); //准备iv参数，用于支持CBC或者ECB模式 IvParameterSpec ivParameterSpec = new IvParameterSpec(iv); cipher.init(mode, secretKeySpec, ivParameterSpec); result = cipher.doFinal(data); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (BadPaddingException e) &#123; e.printStackTrace(); &#125; catch (IllegalBlockSizeException e) &#123; e.printStackTrace(); &#125; catch (InvalidAlgorithmParameterException e) &#123; e.printStackTrace(); &#125; return result; &#125;]]></content>
      <categories>
        <category>Study</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python发送get/post/put/delete请求]]></title>
    <url>%2Farticle%2F3174426477%2F</url>
    <content type="text"><![CDATA[Get请求12345# 如果没有header可以不传request = urllib2.Request(reqUrl, reqHeader)# reqTimeOut为超时时间，不设置可以不传response = urllib2.urlopen(request, reqTimeOut)print respone.read() Post请求12345# 如果没有header可以不传request = urllib2.Request(reqUrl,reqHeader,postData)# reqTimeOut为超时时间，不设置可以不传response = urllib2.urlopen(request, reqTimeOut)print respone.read() Put请求123456# 如果没有header可以不传request = urllib2.Request(reqUrl,reqHeader,postData)# reqTimeOut为超时时间，不设置可以不传response = urllib2.urlopen(request, reqTimeOut)request.get_method = lambda: 'PUT'print respone.read() Delete请求123456# 如果没有header可以不传request = urllib2.Request(reqUrl,reqHeader,postData)# reqTimeOut为超时时间，不设置可以不传response = urllib2.urlopen(request, reqTimeOut)request.get_method = lambda: 'DELETE'print respone.read() debug12345//使用Handler打印日志httpHandler = urllib2.HTTPHandler(debuglevel=1)httpsHandler = urllib2.HTTPSHandler(debuglevel=1)opener = urllib2.build_opener(httpHandler, httpsHandler)urllib2.install_opener(opener) 总结 一个集合了几种请求的工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# -*-coding:utf-8 -*-import urllib2from httptst.Singleton import singleton__metaclass = type@singletonclass HttpHelper: def __init__(self): pass name = 'http helper' # header __reqHeader = &#123;&#125; # url __reqUrl = '' # time __reqTimeOut = 0 # 构建Get请求 def __buildGetRequest(self): if len(self.__reqHeader) == 0: request = urllib2.Request(self.__reqUrl) else: request = urllib2.Request(self.__reqUrl, headers=self.__reqHeader) return request # 构建post,put,delete请求 def __buildPostPutDeleteRequest(self, postData): if len(self.__reqHeader) == 0: request = urllib2.Request(self.__reqUrl, data=postData) else: request = urllib2.Request(self.__reqUrl, headers=self.__reqHeader, data=postData) return request # 添加header def headers(self, headers): self.__reqHeader = headers return self # 添加url def url(self, url): print url self.__reqUrl = url return self # 添加超时 def timeOut(self, time): self.__reqTimeOut = time return self # 是否debug def debug(self): httpHandler = urllib2.HTTPHandler(debuglevel=1) httpsHandler = urllib2.HTTPSHandler(debuglevel=1) opener = urllib2.build_opener(httpHandler, httpsHandler) urllib2.install_opener(opener) return self # 处理response def __handleResponse(self, request, func): try: if self.__reqTimeOut == 0: res = urllib2.urlopen(request) else: res = urllib2.urlopen(request, self.__reqTimeOut) func(res.read()) except urllib2.HTTPError, e: print e.code # get请求 def get(self, func): request = self.__buildGetRequest() self.__handleResponse(request, func) # post请求 def post(self, postData, func): request = self.__buildPostPutDeleteRequest(postData=postData) self.__handleResponse(request, func) # put请求 def put(self, putData, func): request = self.__buildPostPutDeleteRequest(postData=putData) request.get_method = lambda: 'PUT' self.__handleResponse(request, func) # delete请求 def delete(self, putData, func): request = self.__buildPostPutDeleteRequest(postData=putData) request.get_method = lambda: 'DELETE' self.__handleResponse(request, func) 测试1234567891011121314def getData(data): print datahttpHelper = HttpHelper()url_baidu = 'http://www.baidu.com'#简单的get请求httpHelper.url(url=url_baidu).get(func=getData)# post请求httpHelper.debug() \ .url(url=url_post_pics) \ .headers(headers=getHeader()) \ .post(postData=post_data_pics, func=getData)# post请求httpHelper.debug().url(url_post_invite_one).headers(getHeader()).post(post_data_invite_one,getData)]]></content>
      <categories>
        <category>Study</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密解密（RSA）]]></title>
    <url>%2Farticle%2F1309915903%2F</url>
    <content type="text"><![CDATA[什么是对称加密，什么是非对称加密？ 加密解密使用同样的密钥，则是对称加密，使用不一样的密钥就是非对称加密，RSA属于非对称加密。 RSA中有公钥和私钥的概念，公钥加密私钥解密，私钥加密公钥解密，也可以使用RSA对消息进行签名 一些常量1234567891011121314151617181920212223242526272829/** * 加密算法RSA */ public static final String KEY_ALGORITHM = "RSA"; /** * 签名算法 */ public static final String SIGNATURE_ALGORITHM = "MD5withRSA"; /** * 获取公钥的key */ public static final String PUBLIC_KEY = "RSAPublicKey"; /** * 获取私钥的key */ public static final String PRIVATE_KEY = "RSAPrivateKey"; /** * RSA最大加密明文大小 */ private static final int MAX_ENCRYPT_BLOCK = 117; /** * RSA最大解密密文大小 */ private static final int MAX_DECRYPT_BLOCK = 128; 2.获取密钥对 这里使用了内置的方法获取生成的公钥私钥，返回的密钥已经经过了Base64编码的处理，是可见的字符串。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 /** * &lt;p&gt; * 生成密钥对(公钥和私钥) * &lt;/p&gt; * * @return * @throws Exception */ public static Map&lt;String, Object&gt; getKeyPair(int size) throws Exception &#123; KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(KEY_ALGORITHM); keyPairGen.initialize(size); KeyPair keyPair = keyPairGen.generateKeyPair(); RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); Map&lt;String, Object&gt; keyMap = new HashMap&lt;String, Object&gt;(2); keyMap.put(PUBLIC_KEY, publicKey); keyMap.put(PRIVATE_KEY, privateKey); return keyMap; &#125;/** * &lt;p&gt; * 获取私钥 * &lt;/p&gt; * * @param keyMap 密钥对 * @return 获取的key已经经过base64编码 * @throws Exception */ public static String getPrivateKey(Map&lt;String, Object&gt; keyMap) throws Exception &#123; Key key = (Key) keyMap.get(PRIVATE_KEY); // return Base64Utils.encode(key.getEncoded()); return Base64.encodeToString(key.getEncoded(), Base64.NO_WRAP); &#125; /** * &lt;p&gt; * 获取公钥 * &lt;/p&gt; * * @param keyMap 密钥对 * @return 获取的key已经经过base64编码 * @throws Exception */ public static String getPublicKey(Map&lt;String, Object&gt; keyMap) throws Exception &#123; Key key = (Key) keyMap.get(PUBLIC_KEY); // return Base64Utils.encode(key.getEncoded()); return Base64.encodeToString(key.getEncoded(), Base64.NO_WRAP); &#125;` 私钥加密123456789101112131415161718192021222324252627282930313233343536373839 /** * &lt;p&gt; * 私钥加密 * &lt;/p&gt; * * @param data 源数据 * @param privateKey 私钥(BASE64编码) * @return * @throws Exception */ public static byte[] encryptByPrivateKey(byte[] data, String privateKey) throws Exception &#123;// byte[] keyBytes = Base64Utils.decode(privateKey); byte[] keyBytes = Base64.decode(privateKey, Base64.NO_WRAP); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key privateK = keyFactory.generatePrivate(pkcs8KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, privateK); int inputLen = data.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段加密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) &#123; cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(data, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_ENCRYPT_BLOCK; &#125; byte[] encryptedData = out.toByteArray(); out.close(); return encryptedData; &#125; 公钥加密123456789101112131415161718192021222324252627282930313233343536373839/** * &lt;p&gt; * 公钥加密 * &lt;/p&gt; * * @param data 源数据 * @param publicKey 公钥(BASE64编码) * @return * @throws Exception */ public static byte[] encryptByPublicKey(byte[] data, String publicKey) throws Exception &#123; byte[] keyBytes = Base64.decode(publicKey, Base64.NO_WRAP); X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key publicK = keyFactory.generatePublic(x509KeySpec); // 对数据加密 Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, publicK); int inputLen = data.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段加密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) &#123; cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(data, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_ENCRYPT_BLOCK; &#125; byte[] encryptedData = out.toByteArray(); out.close(); return encryptedData; &#125; 公钥解密123456789101112131415161718192021222324252627282930313233343536373839/** * &lt;p&gt; * 公钥解密 * &lt;/p&gt; * * @param encryptedData 已加密数据 * @param publicKey 公钥(BASE64编码) * @return * @throws Exception */public static byte[] decryptByPublicKey(byte[] encryptedData, String publicKey) throws Exception &#123; byte[] keyBytes = Base64.decode(publicKey, Base64.NO_WRAP); X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key publicK = keyFactory.generatePublic(x509KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, publicK); int inputLen = encryptedData.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) &#123; cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; &#125; byte[] decryptedData = out.toByteArray(); out.close(); return decryptedData;&#125; 私钥解密1234567891011121314151617181920212223242526272829303132333435363738/** * &lt;P&gt; * 私钥解密 * &lt;/p&gt; * * @param encryptedData 已加密数据 * @param privateKey 私钥(BASE64编码) * @return * @throws Exception */ public static byte[] decryptByPrivateKey(byte[] encryptedData, String privateKey) throws Exception &#123; byte[] keyBytes = Base64.decode(privateKey, Base64.NO_WRAP); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key privateK = keyFactory.generatePrivate(pkcs8KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, privateK); int inputLen = encryptedData.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) &#123; cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; &#125; byte[] decryptedData = out.toByteArray(); out.close(); return decryptedData; &#125; 消息签名123456789101112131415161718192021/** * &lt;p&gt; * 用私钥对信息生成数字签名 * &lt;/p&gt; * * @param data 已加密数据 * @param privateKey 私钥(BASE64编码) * @return * @throws Exception */public static String sign(byte[] data, String privateKey) throws Exception &#123; byte[] keyBytes = Base64.decode(privateKey, Base64.NO_WRAP); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); PrivateKey privateK = keyFactory.generatePrivate(pkcs8KeySpec); Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM); signature.initSign(privateK); signature.update(data); return Base64.encodeToString(signature.sign(), Base64.NO_WRAP);&#125; 验证签名12345678910111213141516171819202122/** * &lt;p&gt; * 使用公钥校验数字签名 * &lt;/p&gt; * * @param data 已加密数据 * @param publicKey 公钥(BASE64编码) * @param sign 数字签名 * @return * @throws Exception */ public static boolean verifySign(byte[] data, String publicKey, String sign) throws Exception &#123; byte[] keyBytes = Base64.decode(publicKey, Base64.NO_WRAP); X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); PublicKey publicK = keyFactory.generatePublic(keySpec); Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM); signature.initVerify(publicK); signature.update(data); return signature.verify(Base64.decode(sign, Base64.NO_WRAP)); &#125; 抽取公共代码 可以发现有很多重复代码，这样写是为了更加清晰，代码抽取一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * * 使用私钥操作时 * @param data * @param key * @param mode * @return * @throws Exception */ public static byte[] UsePrivate(byte[] data, String key,int mode) throws Exception &#123; byte[] keyBytes = Base64.decode(key, Base64.NO_WRAP); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key privateK = keyFactory.generatePrivate(pkcs8KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(mode, privateK); int inputLen = data.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) &#123; cache = cipher.doFinal(data, offSet, MAX_DECRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(data, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; &#125; byte[] decryptedData = out.toByteArray(); out.close(); return decryptedData; &#125; /** * 使用公钥操作 * @param data * @param key * @param mode * @return * @throws Exception */ public static byte[] UsePublic(byte[] data, String key,int mode) throws Exception &#123; byte[] keyBytes = Base64.decode(key, Base64.NO_WRAP); X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key publicK = keyFactory.generatePublic(x509KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(mode, publicK); int inputLen = data.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) &#123; cache = cipher.doFinal(data, offSet, MAX_DECRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(data, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; &#125; byte[] decryptedData = out.toByteArray(); out.close(); return decryptedData; &#125;]]></content>
      <categories>
        <category>Study</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac + AndroidStudio 快捷操作]]></title>
    <url>%2Farticle%2F8d16bcb4%2F</url>
    <content type="text"><![CDATA[快捷键常用123456789101112131415161718- 快速提示alt + Enter- 跳转到某一行command + L- 整理代码alt + command + L- 重命名变量shift + F6- 代码大小写转换shift + command + u- 列选中alt + 鼠标 提取12345- 提取代码块为方法alt + command + M (method)- 提取局部变量为全局变量alt + command + F (field) 搜索／替换12345678910111213141516- 搜索 java 文件command + O- 搜索所有文件shift + command + O - 文件内查找文本command + F- 项目内查找文本shift + command + F- 文件内文本替换command + R- 项目内文本替换shift + command + R- search everywhere 双击 shift project 操作12345678910- 打开 ProjectStructurecommand + ;(分号)- 打开 settingscommand + ,(逗号)- 运行项目control + R- 运行 freelineshift + command + F10 代码快捷用法通用12345678910111213141516171819202122232425User user = new User();// 判断不为空; user.nnif (user != null) &#123;&#125;// 判断为空; user.nullif (user == null) &#123;&#125;// 返回; user.returnreturn user;// instanceof 判断; user.instList temp = user instanceof List ? ((List) list) : null;// 生成条件表达式; 条件表达式.if 如输入 100&gt;10.ifif (100 &gt; 10) &#123; &#125;// 生成while循环; 条件表达式.while 如输入 100&gt;10.whilewhile (100 &gt; 10) &#123; &#125; 快速遍历12345678910111213141516List&lt;String&gt; list = new ArrayList&lt;&gt;();// list.forfor (String s : list) &#123; &#125;// list.forifor (int i = 0; i &lt; list.size(); i++) &#123; &#125;// list.forrfor (int i = list.size() - 1; i &gt;= 0; i--) &#123; &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>DevEnvironment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TabLayout]]></title>
    <url>%2Farticle%2F1315779230%2F</url>
    <content type="text"><![CDATA[本文主要介绍 TabLayout 的详细使用，持续完善中… TabLayout 的基本属性及效果 TabLayout 与 ViewPager 联动 自定义 TabLayout 的 tab 显示 基本属性介绍12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;android.support.design.widget.TabLayout android:id="@+id/fragment_discover_tably" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt; 1. tabModeapp:tabMode="fixed|scrollable" tabMode属性有两个取值:fixed时，所有的tab会居中显示，是不可滑动的，scrollable时，所有的tab会靠左显示，当tab数量很多时，就会呈现滑动的效果，这对适配小屏幕手机至关重要。2. 导航条的高度和颜色app:tabIndicatorHeight="3dp"app:tabIndicatorColor="#af00"3. tab的宽度限制当文字很少时仍旧不会小于tabMinWidth当文字过多时，也不会将tab撑的超过tabMaxWidthapp:tabMaxWidth="150dp"app:tabMinWidth="60dp"4. tab被选中或没有被选中时的颜色app:tabTextColor="@color/black"app:tabSelectedTextColor="@color/colorPrimary"5. 更改Tab上面的TextView的详细显示app:tabTextAppearance="@style/TabLayoutStyle"&lt;style name="TabLayoutStyle" parent="TextAppearance.Design.Tab"&gt; &lt;item name="android:textSize"&gt;16sp&lt;/item&gt; &lt;item name="android:textStyle"&gt;normal&lt;/item&gt;&lt;/style&gt;6. 背景app:tabBackground="@color/transparent"设置tab的背景颜色，默认TabLayout点击时是有光晕效果的，使用该属性可以去掉光晕效果。7. tab间隔默认tab左右两边是有padding的，使用以下属性可以去掉padding，只使用tabPadding是没有效果的，要具体到设置到哪个padding app:tabPadding="0dp"app:tabPaddingBottom="0dp"app:tabPaddingEnd="0dp"app:tabPaddingStart="0dp"app:tabPaddingTop="0dp" 与 ViewPager 联动使用 TabLayout 的 setupWithViewPager() 方法，可以实现与 ViewPager 的联动，但是需要注意的是写 ViewPager 时需要实现 getTitle() 方法，用来设置 tab 的标题。原先给 Tab 设置的标题将会被覆盖掉。 1tabLy.setupWithViewPager(viewPager); 自定义 Tab 显示默认的 TabLayout 是可以显示文字和 Icon 的，但是定制度不是很高，往往不能实现预期效果，不过好在 TabLayout 开放了 setCustomView(childView) 这个 API 来支持我们自定义 TabLayout 的UI，当然自定义显示之后也损失了切换时颜色切换等效果，需要我们自己来处理，下面是我定义了一个辅助类，使用类似 adapter 的形式来加载 TabLayout 的每个 tab 的显示，实现自定义效果，也对选中事件等作了简化操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194/** * CreateAt : 2017/3/29 * Describe : TabLayout适配器,快速实现TabLayout自定义View数据加载 * * @author chendong */public abstract class BaseTabAdapter&lt;T&gt; &#123; public static final String TAG = BaseTabAdapter.class.getSimpleName(); private Context mContext; // 自定义布局layout文件 private int mResId; // 数据源 private List&lt;T&gt; mDatas; // 全部的控件，用来切换时改变显示 private List&lt;TabLayoutViewHolder&gt; mTabLayoutViewHolders; // tabLayout private TabLayout mTabLayout; // 简化的tab点击事件 private OnTabSelectListener&lt;T&gt; mOnTabSelectListener; private boolean mIsReady; /** * Tab选中的接口 * * @param &lt;T&gt; */ public interface OnTabSelectListener&lt;T&gt; &#123; void onSelect(int pos, T data); &#125; protected BaseTabAdapter(Context context, List&lt;T&gt; datas, int resId) &#123; mDatas = datas; mContext = context; mResId = resId; mTabLayoutViewHolders = new ArrayList&lt;&gt;(); &#125; public void attachTabLayout(TabLayout tabLayout) &#123; tabLayout.clearOnTabSelectedListeners(); attachTabLayout(tabLayout, 0); &#125; public void attachTabLayout(TabLayout tabLayout, int posSelect) &#123; mIsReady = false; mTabLayout = tabLayout; // 设置导航条高度=0 tabLayout.setSelectedTabIndicatorHeight(0); tabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; L.e(TAG, "onTabSelected " + tab.getPosition()); int position = tab.getPosition(); if (mIsReady &amp;&amp; mOnTabSelectListener != null) &#123; mOnTabSelectListener.onSelect(position, mDatas.get(position)); &#125; updateStatus(mTabLayoutViewHolders.get(position), mDatas.get(position), true); &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; L.e(TAG, "onTabUnselected " + tab.getPosition()); updateStatus(mTabLayoutViewHolders.get(tab.getPosition()), mDatas.get(tab.getPosition()), false); &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; L.e(TAG, "onTabReselected " + tab.getPosition()); updateStatus(mTabLayoutViewHolders.get(tab.getPosition()), mDatas.get(tab.getPosition()), true); &#125; &#125;); // 初始化view,默认初始化为全部不选中 View childView; TabLayoutViewHolder holder; TabLayout.Tab tab; for (int i = 0; i &lt; mDatas.size(); i++) &#123; childView = LayoutInflater.from(mContext).inflate(mResId, tabLayout, false); holder = new TabLayoutViewHolder(childView); mTabLayoutViewHolders.add(holder); updateStatus(mTabLayoutViewHolders.get(i), mDatas.get(i), false); tab = tabLayout.newTab().setCustomView(childView); tabLayout.addTab(tab); &#125; // 选中初始化选中的那个 TabLayout.Tab tabAt = tabLayout.getTabAt(posSelect); if (tabAt != null) &#123; tabAt.select(); if (mOnTabSelectListener != null) &#123; mOnTabSelectListener.onSelect(posSelect, mDatas.get(posSelect)); &#125; &#125; mIsReady = true; &#125; public void notifyItemChanged(int pos) &#123; if (pos &gt;= 0 &amp;&amp; pos &lt; mDatas.size()) &#123; TabLayout.Tab tabAt; tabAt = mTabLayout.getTabAt(pos); updateStatus(mTabLayoutViewHolders.get(pos), mDatas.get(pos), tabAt != null &amp;&amp; tabAt.isSelected()); &#125; &#125; public void notityDataSetChanged() &#123; TabLayout.Tab tabAt; for (int i = 0; i &lt; mDatas.size(); i++) &#123; tabAt = mTabLayout.getTabAt(i); updateStatus(mTabLayoutViewHolders.get(i), mDatas.get(i), tabAt != null &amp;&amp; tabAt.isSelected()); &#125; &#125; /** * 抽象方法，更新控件状态显示 * * @param holder view holder * @param data 数据 * @param isSelect 是否选中 */ public abstract void updateStatus(TabLayoutViewHolder holder, T data, boolean isSelect); public void setOnTabSelectListener(OnTabSelectListener&lt;T&gt; onTabSelectListener) &#123; mOnTabSelectListener = onTabSelectListener; &#125; public interface OnBuildTabListener&lt;D&gt; &#123; TabLayout.Tab onBuild(TabLayout.Tab tab, D data); &#125; public static &lt;D&gt; void buildTabLayout(TabLayout tabLayout, List&lt;D&gt; datas, OnBuildTabListener&lt;D&gt; listener) &#123; TabLayout.Tab tab; for (D data : datas) &#123; tab = tabLayout.newTab(); tabLayout.addTab(listener.onBuild(tab, data)); &#125; &#125; /** * 公共holder，用来存储和快速获取控件 */ public static class TabLayoutViewHolder &#123; private View parentView; private SparseArray&lt;View&gt; mCacheViews; public View getItemView() &#123; return parentView; &#125; TabLayoutViewHolder(View parentView) &#123; this.parentView = parentView; mCacheViews = new SparseArray&lt;&gt;(); &#125; public &lt;V extends View&gt; V getView(int resId) &#123; V v = (V) mCacheViews.get(resId); if (v == null) &#123; v = (V) parentView.findViewById(resId); if (v != null) &#123; mCacheViews.put(resId, v); &#125; &#125; return v; &#125; &#125; public void setUpViewPager(final ViewPager viewPager) &#123; if (mTabLayout == null) &#123; Log.e("chendong", "TabLayout is null ,invoke attachTabLayout first"); return; &#125; mTabLayout.addOnTabSelectedListener(new MyOnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; if (viewPager != null) viewPager.setCurrentItem(tab.getPosition()); &#125; &#125;); if (viewPager != null) viewPager.addOnPageChangeListener(new MyOnPageChangeListener() &#123; @Override public void onPageSelected(int position) &#123; if (mTabLayout != null) &#123; TabLayout.Tab tabAt = mTabLayout.getTabAt(position); if (tabAt != null) tabAt.select(); &#125; &#125; &#125;); &#125;&#125; how to usage? 123456789101112131415161718BaseTabAdapter&lt;Baby&gt; adapter = new BaseTabAdapter&lt;Baby&gt;(mActivty, babies, R.layout.vip_select_family_baby_item) @Override public void updateStatus(TabLayoutViewHolder holder, Baby data, boolean isSelect) &#123; holder.getView(R.id.parent).getLayoutParams().width = (int) (BaoBaoApplication.DISPLAY_WIDTH / 3f); TextView nameTv = holder.getView(R.id.tv_name); nameTv.setText(data.getBabyName()); holder.getView(R.id.view_line).setBackgroundColor(isSelect ? ContextCompat.getColor(mBaseFragmentActivity, R.color.colorPrimary) : ContextCompat.getColor(mBaseFragmentActivity, R.color.color_EFEFEF)); &#125;&#125;;adapter.setOnTabSelectListener(new BaseTabAdapter.OnTabSelectListener&lt;Baby&gt;() &#123; @Override public void onSelect(int pos, Baby data) &#123; // 请求数据，展示数据 &#125;&#125;);adapter.attachTabLayout(mTabLayout, 1);]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用传统Android组件实现高效数据加载]]></title>
    <url>%2Farticle%2F3092091804%2F</url>
    <content type="text"><![CDATA[前言 本文主要介绍使用ContentProvider + Sqlite + Loader等Android的基本组件实现高内聚低耦合的数据加载的数据设计模式，这是一种传统而高效的数据加载，熟悉这种模式同时也是对ContentProvider的更好掌握。 优势 ContentProvider可以非常简单的调整数据源而不影响其他程序。外部程序不关心数据，只关心返回的Cursor.举个例子，ContentProvider指向的数据库可以随时改变不会影响使用者，同时ContentProvider也可以返回网络数据，使用者只要求结果是Cursor,但是对于数据来自哪里并不关心，这样就实现了数据读取和使用的分离。 提供数据安全保护与权限管理，ContentProvider使用授权机制，对数据在方便访问的同时进行了很好地保护。 强大的API支持，Google官方提供了强大的API. ##Loader特点： 与Activity管理同步，与Activity/Fragment生命周期同步，创建与销毁都会受到Activity/Fragment生命周期的管理。这就意味着我们不需要再去考虑何时去加载数据，使用Loader之后会结合Activity或者Fragment的生命周期自行进行加载和更新。 内部线程异步加载，我们也就不需要再去开启线程获取数据解析数据，大大减少了代码量。 数据源发生改变时实时更新，貌似我们自己的数据数据是无法自动更新的，不过不要紧，只需要一行简单的reStartLoader就可以手动重新加载一下。 数据分层 Loader 写操作 ContentProvider SQLite 定义关系类 定义一个关系类，声明表结构,Uri,授权 1234567891011121314151617181920212223242526public class WebContract &#123; public static final String Tb_History = &quot;tb_history&quot;; public static final String Tb_BookMark = &quot;tb_bookmark&quot;; public static final String Authority = &quot;com.march.db_browser&quot;; public static class History implements BaseColumns &#123; //content://com.march.db_browser/tb_history public static final Uri ContentUri = Uri.parse( &quot;content://&quot; + Authority).buildUpon().appendPath(Tb_History).build(); public static final String Link = &quot;link&quot;; public static final String Icon = &quot;icon&quot;; public static final String Title = &quot;title&quot;; public static final String Time = &quot;time&quot;; &#125; public static class BookMark implements BaseColumns &#123; //content://com.march.db_browser/tb_history public static final Uri ContentUri = Uri.parse( &quot;content://&quot; + Authority).buildUpon().appendPath(Tb_BookMark).build(); public static final String Link = &quot;link&quot;; public static final String Icon = &quot;icon&quot;; public static final String Title = &quot;title&quot;; public static final String Time = &quot;time&quot;; &#125;&#125; 继承ContentProvider 实现数据提供者，设定好Code作为表资源的唯一标示，使用UriMacher匹配 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class WebContentProvider extends ContentProvider &#123;/*为可以访问的数据库表资源定义代号，区分哪个表可以被访问*/private static final int CODE_BOOKMARK = 0x1;private static final int CODE_HISTORY = 0x2;/*使用UriMacher生成访问的Uri*/private static UriMatcher uriMatcher;/*使用静态代码块初始化UriMacher,添加*/static &#123;uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);uriMatcher.addURI(WebContract.Authority, WebContract.Tb_BookMark, CODE_BOOKMARK);uriMatcher.addURI(WebContract.Authority, WebContract.Tb_History, CODE_HISTORY);&#125;private MySqliteOpenHelper mySqliteOpenHelper;private SQLiteDatabase db;@Overridepublic boolean onCreate() &#123;mySqliteOpenHelper = new MySqliteOpenHelper(getContext(), "db_browser", 1);return false;&#125;@Overridepublic Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123;Cursor cursor = null;if (uri != null) &#123;int code = uriMatcher.match(uri);db = mySqliteOpenHelper.getWritableDatabase();switch (code) &#123;case CODE_BOOKMARK:cursor = db.query(WebContract.Tb_BookMark, null, null, null, null, null, null);break;case CODE_HISTORY:cursor = db.query(WebContract.Tb_History, null, null, null, null, null, null);break;&#125;&#125;if (cursor == null) &#123;Log.i("chendong", "cursor is null");&#125; // db.close();//读操作不能关闭连接，写操作需要关闭连接return cursor;&#125;@Overridepublic String getType(Uri uri) &#123;return null;&#125;@Overridepublic Uri insert(Uri uri, ContentValues values) &#123;Uri uri_return = null;if (uri != null) &#123;int code = uriMatcher.match(uri);db = mySqliteOpenHelper.getWritableDatabase();long id = -1;switch (code) &#123;case CODE_BOOKMARK:id = db.insert(WebContract.Tb_BookMark, null, values);break;case CODE_HISTORY:id = db.insert(WebContract.Tb_History, null, values);break;&#125;if (id != -1) &#123;uri_return = ContentUris.withAppendedId(uri, id);&#125;db.close();&#125;return uri_return;&#125;@Overridepublic int delete(Uri uri, String selection, String[] selectionArgs) &#123;// Implement this to handle requests to delete one or more rows.throw new UnsupportedOperationException("Not yet implemented");&#125;@Overridepublic int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123;// TODO: Implement this to handle requests to update one or more rows.throw new UnsupportedOperationException("Not yet implemented");&#125;&#125; 使用Loader加载数据``` adapter = new SimpleCursorAdapter(this, R.layout.item_listview, null, new String[]{WebContract.History.Title, WebContract.History.Link}, new int[]{R.id.item_listview_title, R.id.item_listview_url}, SimpleCursorAdapter.FLAG_REGISTER_CONTENT_OBSERVER); listView.setAdapter(adapter); getLoaderManager().initLoader(0x123, bundle, this); //这是实现的 implements LoaderManager.LoaderCallbacks&lt;Cursor&gt; 的方法 @Override public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) { int action = args.getInt(&quot;action&quot;); CursorLoader cursorLoader = null; Log.i(&quot;chendong&quot;, &quot;action is &quot; + action); if (action == 0) { //history cursorLoader = new CursorLoader(this, WebContract.History.ContentUri, null, null, null, null); } else { cursorLoader = new CursorLoader(this, WebContract.BookMark.ContentUri, null, null, null, null); } return cursorLoader; } @Override public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor data) { Log.i(&quot;chendong&quot;, &quot;get data &quot;); adapter.changeCursor(data); } @Override public void onLoaderReset(Loader&lt;Cursor&gt; loader) { } 使用 getLoaderManager().restartLoader(0x123, bundle, this); 重新加载数据]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android编码解码及其原理]]></title>
    <url>%2Farticle%2F438600076%2F</url>
    <content type="text"><![CDATA[前言 本文用到ASCII表，Base64对照表请自行百度。 概念：编码解码就是使用特定的算法，将数据进行处理，形成数据的另外一种表现形式，编码后的数据可以使用解码算法还原出原始数据。 Base64简介 Base64算法可以将任意的字节数组数据通过算法生成只有（英文大小写，数字，+，/）共64种字符的字符串数据；相当于将任意内容转换为可见字符串表示。 也就是将不可见的数据转换为ASCII码数据，便于在Json和Xml中传递。 Base64Api1234567891011121314//将字节数组编码，返回为StringBase64.encodeToString(byte[] bs,int flag);//将字节数组编码，返回字节数组Base64.encode(byte[] bs,int flag);//将字节数组按指定位置部分编码，返回字符串Base64.encodeToString(byte[] bs,int offset,int lenth);//将字节数组按指定位置部分编码，返回字节数组Base64.encode(byte[] bs,int offset,int lenth);//将编码后的字符串解码返回字节数组Base64.decode(String str,int flag);//将编码后的字节数组解码返回字节数组Base64.decode(byte[],int flag);//将编码后的字节数组按指定位置部分解码，返回字节数组Base64.decode(byte[] bs,int offset,int len); flag常量1234567891011Base64.CRLF 这个参数意思是Win风格的换行符，意思就是使用CR LF这一对作为一行的结尾而不是Unix风格的LFBase64.DEFAULT 这个参数是默认，使用默认的方法来加密Base64.NO_PADDING 这个参数是略去加密字符串最后的”=”Base64.NO_WRAP 这个参数意思是略去所有的换行符（设置后CRLF就没用了）Base64.URL_SAFE 这个参数意思是加密时不使用对URL和文件名有特殊意义的字符来作为加密字符，具体就是以-和_取代+和///习惯上使用Base64.NO_WRAP，使用什么方式编码就需要使用什么方式解码。 Base64原理 Base64在编码时按照三个字节一组分组， 进行处理，每三个字节在编码之后被转换为4个字符。 每个字节有8个bit(也必须是要求有8bit，所以中文是不可以的),三个字节就有24个bit. 但是我们只有64 种字符选择，也就是Base64的字符最多只能用6bit来表示，再大就会超出64的范围，所以编码以后显示的字符开始两位是0. 那么原先24bit的数据要显示在现在每个字符只有6bit的表示方法上，很明显需要4个字符（3*8 == 4*6） 当数据长度在无法满足3的倍数的时候会在末尾添加“=“具体的转换方法直接说可能有点抽象， 字符串Base64编码过程 字符串String str = &quot;0Aa&quot;;首先，原先每个字符是2个字节16bit,对于英文来说前8个bit是0，也就是只有8个bit,现在是3个字符，3*8=24个bit需要显示。 转换 get 0 A a ASCII 48 65 97 二进制表示 00110000 01000001 01100001 现在拼凑成是这样的二进制串( 001100 000100 000101 100001)，将其转化为Base64可以显示的模式，需要每次取6位作为一个Base64字符,前两位补0 get 1 2 3 4 开始 001100 000100 000101 100001 转化 00001100 00000100 00000101 00100001 转为10进制 12 4 5 33 Base64字符 M E F h 二进制数组编码过程 这个例子已经很清晰的解释了Base64的编码过程，网上有人自己实现了Base64编码的类，android源码也不难，这是编码字符串看起来还是比较清晰的，我们也可以更本质一点 byte[] bs = new byte[]{1,10,20};这是一个byte数组，复习一下，1个byte是8个bit,可以表示的范围0-127之间，我们在调用Base64的函数时，本质也是在操作字节数组，同样的原理 byte 1 10 20 二进制表示 00000001 00001010 00010100 6位一组，二进制串000000 010000 101000 010100 get 1 2 3 4 开始 000000 010000 101000 010100 转化 00000000 00010000 00101000 00010100 转为10进制 0 16 40 20 Base64字符 A Q o U Hex编码简介 Hex就是16进制，本质上是将字节数组转化为16进制，然后用字符串的形式表现出来，我们知道16进制的取值范围就是在0-f之间，这样就可以将无法显示的字节数组数据显示出来。 原理方面比起Base64就简单很多了，一个8bit的数据，也就是（xxxx xxxx）,每4个bit可以转化为一个16进制表示，也就是8个bit会转化为（00-ff）之间的16进制数字。 Hex编码实现12345678910111213141516171819202122232425262728293031323334/** * 字节数组转换为字符串 * 一个字节形成两个字符，是原来数据长度的两倍 * * @param data * @return */ public static String toHex(byte[] data) &#123; String ret = null; //todo 将字节数组转换为字符串 if (data != null &amp;&amp; data.length &gt; 0) &#123; StringBuilder sb = new StringBuilder(); for (byte b : data) &#123; //分别获取高四位和低四位转换为字符 int h = (b &gt;&gt; 4) &amp; 0x0f; int l = b &amp; 0x0f; char ch, cl; if (h &gt; 9) &#123;//0x0a~0x0f ch = (char) ('A' + (h - 10)); &#125; else &#123;//0~9 ch = (char) ('0' + h); &#125; if (l &gt; 9) &#123;//0x0a~0x0f cl = (char) ('A' + (l - 10)); &#125; else &#123;//0~9 cl = (char) ('0' + l); &#125; sb.append(ch).append(cl); &#125; ret = sb.toString(); &#125; return ret; &#125; Hex编码原理分析 简单说一下，&amp;运算，两者都为1结果才是1，b&gt;&gt;4&amp;0xf取出高四位，b&amp;0x0f取出低四位，举个例子： 字节是 b = 1010 1111 b&gt;&gt;4 b = 00001010 b&gt;&gt;4&amp;0x0f 也就是 00001010&amp;00001111 —-&gt; 1010高四位取出来了，取得低四位原理一样。后面的操作就是根据数据的大小转换一下格式，因为拿到的数据是十进制的那么范围会在0-15之间，需要转换为16进制的0-f. Hex解码实现12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 将编码字符串解码为字节数组 * * @param data * @return */ public static byte[] fromHex(String data) &#123; byte[] ret = null; //todo 将字符串转换为字节数组 if (data != null) &#123; int len = data.length(); char[] chs = data.toCharArray(); ret = new byte[len/2]; int ih = 0,il=0,v=0,j=0; if (len &gt; 0 &amp;&amp; len % 2 == 0) &#123; for (int i = 0; i &lt; len - 1; i += 2,j++) &#123; char ch = chs[i]; char cl = chs[i+1]; if(ch&gt;=&apos;A&apos;&amp;&amp;ch&lt;=&apos;F&apos;)&#123; ih = 10 + (ch - &apos;A&apos;); &#125;else if(ch &gt;=&apos;a&apos;&amp;&amp;ch&lt;=&apos;f&apos;)&#123; ih = 10 + (ch - &apos;a&apos;); &#125;else if(ch&gt;&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123; ih = ch - &apos;0&apos;; &#125; if(cl&gt;=&apos;A&apos;)&#123; il = 10 + (cl - &apos;A&apos;); &#125;else if(cl &gt;=&apos;a&apos;)&#123; il = 10 + (cl - &apos;a&apos;); &#125;else if(cl&gt;&apos;0&apos;)&#123; il = cl - &apos;0&apos;; &#125; v = ((ih&amp;0x0f)&lt;&lt;4)|(il&amp;0x0f); ret[j] = (byte)v; &#125; &#125; &#125; return ret; &#125; Hex解码原理分析 相当于编码的逆运算，根据字符串每次取两位，转换成int，在进行移位将其拼成一个字节，怎么拼的？v = ((ih&amp;0x0f)&lt;&lt;4)|(il&amp;0x0f); 这一句，假设我们获得的字符串最后转化结果是10和5，也就是1010，0101。10&lt;&lt;4,结果是10100000，然后10100000 | 0101，|运算只要有1则为1，结果是10100101就完成了拼接工作。 总结 Base64和Hex是比较常见的编码方式，对比一下，Base64每3个字节转化为4个字节，每个字节浪费2bit,Hex编码，每个字节转化为两个字节，每个字节浪费4bit,所以说Base64更加节省空间，而且用起来简单得多。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndridStudio 使用 Freeline 加速编译]]></title>
    <url>%2Farticle%2F3239800061%2F</url>
    <content type="text"><![CDATA[buildscript { repositories { jcenter() maven { url “https://jitpack.io“ } maven { url “https://dl.bintray.com/chendongmarch/maven“ } } dependencies { classpath ‘com.android.tools.build:gradle:2.2.2’ classpath ‘com.antfortune.freeline:gradle:0.8.1’ // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files }} apply plugin: ‘com.antfortune.freeline’//阿里增量编译 freeline { hack true productFlavor ‘babyphoto’ applicationProxy false }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>DevEnvironment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MetrailDesign]]></title>
    <url>%2Farticle%2F3353371585%2F</url>
    <content type="text"><![CDATA[Theme123456789101112131415161718&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt;&lt;!--导航栏底色--&gt;&lt;item name="colorPrimary"&gt;@color/accent_material_dark&lt;/item&gt;&lt;!--状态栏底色--&gt;&lt;item name="colorPrimaryDark"&gt;@color/accent_material_light&lt;/item&gt;&lt;!--导航栏上的标题颜色--&gt;&lt;item name="android:textColorPrimary"&gt;@android:color/black&lt;/item&gt;&lt;!--Activity窗口的颜色--&gt;&lt;item name="android:windowBackground"&gt;@color/white&lt;/item&gt;&lt;!--按钮选中或者点击获得焦点后的颜色--&gt;&lt;item name="colorAccent"&gt;@color/accent_material_light&lt;/item&gt;&lt;!--和 colorAccent相反，正常状态下按钮的颜色,所有控价在没有获得焦点时的颜色--&gt;&lt;item name="colorControlNormal"&gt;#ff0000&lt;/item&gt;&lt;!--Button按钮正常状态颜色--&gt;&lt;item name="colorButtonNormal"&gt;@color/accent_material_light&lt;/item&gt;&lt;!--EditText 输入框中字体的颜色--&gt;&lt;item name="editTextColor"&gt;@android:color/white&lt;/item&gt;&lt;/style&gt; ##TextInputLayout XML文件123456789101112&lt;android.support.design.widget.TextInputLayout android:id="@+id/md_textinputlayout" android:layout_width="match_parent" android:layout_height="wrap_content" &gt; &lt;EditText android:id="@+id/md_edittext" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="请输入文本" /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; 代码显示错误信息,文本颜色的需要使用Theme修改1234567891011TextInputLayout tily1=(TextInputLayout) findViewById(R.id.tily1);tily1.setHint("新的Hint");tily1.getEditText().addTextChangedListener(new TextWatcher()); //在监听之中进行如下设置可以显示错误信息int num = 0;if (((num = s.toString().length()) &lt; 6) &amp;&amp; num != 0) &#123; textInputLayout.setErrorEnabled(true); textInputLayout.setError("长度不能小于6");&#125; else &#123; textInputLayout.setErrorEnabled(false);&#125; SnackBar代码1234567891011121314Snackbar snackbar = Snackbar.make(view, "SnackBar测试", Snackbar.LENGTH_SHORT) //点击事件中按钮的颜色 .setActionTextColor(Color.WHITE) //设置点击事件 .setAction("SnackBar", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.i("chendong", "点击了action"); &#125; &#125;);//修改背景颜色snackbar.getView().setBackgroundColor(Color.GRAY);snackbar.show();&#125; FloatingActionButton123456789101112&lt;android.support.design.widget.FloatingActionButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/ic_launcher" android:layout_alignParentRight="true" android:layout_alignParentBottom="true" android:layout_margin="10dp" android:onClick="ClickFloatButton" app:fabSize="normal" app:backgroundTint="#f00" app:elevation="5dp" /&gt; 属性 //上面的文件使用相对布局，可以使用相对锚点的设置定位fab app:layout_anchor=”@id/md_recyclerview”//锚点，基于哪个控件定位 app:layout_anchorGravity=”bottom|right|end”//相对锚点的位置 app:fabSize=”normal”//控件大小，只支持两种大小，mini,normal app:backgroundTint=”#f00”//改变背景颜色，不设置好像是黑的还是跟随主题 app:elevation=”5dp”//阴影12345678910111213141516171819202122232425## AppBarLayout - AppBarLayout本身是一个垂直的LinearLayout，被他包裹的控件将作为ActionBar展示```xml&lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt;&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/md_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:minHeight=&quot;?attr/actionBarSize&quot; android:background=&quot;?attr/colorPrimary&quot; android:layout_marginBottom=&quot;20dp&quot;&gt;&lt;/android.support.v7.widget.Toolbar&gt;&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:padding=&quot;10dp&quot; android:text=&quot;这是appbarlayout测试&quot; android:gravity=&quot;center_horizontal&quot; android:textSize=&quot;20sp&quot;/&gt;&lt;/android.support.design.widget.AppBarLayout&gt; CoordinatorLayout 这个（Coordinator）单词的意思是协调器，它是协调控件之间动画效果的一个布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;android.support.design.widget.CoordinatorLayoutxmlns:android="http://schemas.android.com/apk/res/android"xmlns:tools="http://schemas.android.com/tools"xmlns:app="http://schemas.android.com/apk/res-auto"android:layout_width="match_parent"android:layout_height="match_parent"tools:context="com.awesome.newfeatures.SecondActivity"&gt;&lt;android.support.design.widget.AppBarLayoutandroid:layout_width="match_parent"android:layout_height="wrap_content"&gt;&lt;android.support.v7.widget.Toolbarandroid:id="@+id/md_toolbar"android:layout_width="match_parent"android:layout_height="?attr/actionBarSize"android:minHeight="50dp"android:background="?attr/colorPrimary"android:layout_marginBottom="20dp" app:layout_scrollFlags="scroll|enterAlways"/&gt;&lt;android.support.design.widget.TabLayoutandroid:id="@+id/md_tablayout"android:layout_width="match_parent"android:layout_height="wrap_content"app:tabGravity="fill"app:tabTextColor="#f00"app:tabIndicatorColor="#00f"app:tabMode="fixed"app:tabIndicatorHeight="2dp"/&gt;&lt;/android.support.design.widget.AppBarLayout&gt;&lt;android.support.v7.widget.RecyclerViewandroid:id="@+id/md_recyclerview"android:layout_width="match_parent"android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior"/&gt;&lt;android.support.design.widget.FloatingActionButtonandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:src="@mipmap/ic_launcher"app:backgroundTint="#00f"app:elevation="5dp"android:layout_margin="16dp"app:layout_anchor="@id/md_recyclerview"app:layout_anchorGravity="bottom|right|end"android:onClick="Click"/&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; app:layout_behavior=”@string/appbar_scrolling_view_behavior”//在视图中可滑动的组件使用该属性标示，必须是RecyclerView或NestedScrollView 试验表明，开始使用后面两个属性并没起作用，后来发现需要固定toolbar高度才会起作用。 FloatingActionButton被包裹在CoordinatorLayout中时可以防止SnackBar跳出时遮挡Fab app:layout_scrollFlags=”scroll|enterAlways”//三种取值 属性选择 描述 scroll 所有需要滑动的视图需要定义该属性，不使用该属性的视图将会固定在屏幕顶端this flag should be set for all views that want to scroll off the screen - for views that do not use this flag, they’ll remain pinned to the top of the screen enterAlways 任意向下的操作会导致隐藏视图显示出来this flag ensures that any downward scroll will cause this view to become visible, enabling the ‘quick return’ pattern enterAlwaysCollapsed 这个flag定义的是何时进入（已经消失之后何时再次显示）。假设你定义了一个最小高度（minHeight）同时enterAlways也定义了，那么view将在到达这个最小高度的时候开始显示，并且从这个时候开始慢慢展开，当滚动到顶部的时候展开完。When your view has declared a minHeight and you use this flag, your View will only enter at its minimum height (i.e., ‘collapsed’), only re-expanding to its full height when the scrolling view has reached it’s top. exitUntilCollapsed 这个flag时定义何时退出，当你定义了一个minHeight，这个view将在滚动到达这个最小高度的时候消失。 this flag causes the view to scroll off until it is ‘collapsed’ (its minHeight) before exiting CollapsingToolbarLayout 使用CollapsingToolbarLayout结合CoordinatorLayout实现可缩放的ActionBar,在使用CoordinatorLayout一直实现不了列表滑动到顶端才显示的效果，使用CollapsingToolbarLayout可以实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;android.support.design.widget.CoordinatorLayoutxmlns:android="http://schemas.android.com/apk/res/android"xmlns:tools="http://schemas.android.com/tools"xmlns:app="http://schemas.android.com/apk/res-auto"android:layout_width="match_parent"android:layout_height="match_parent"tools:context="com.awesome.newfeatures.SecondActivity"&gt; //需要固定高度&lt;android.support.design.widget.AppBarLayoutandroid:id="@+id/appbar"android:layout_width="match_parent"android:layout_height="160dp"&gt;&lt;android.support.design.widget.CollapsingToolbarLayoutandroid:layout_width="match_parent"android:layout_height="match_parent"app:contentScrim="?attr/colorPrimary"app:layout_scrollFlags="scroll|exitUntilCollapsed"&gt;&lt;ImageViewandroid:id="@+id/backdrop"android:layout_width="match_parent"android:layout_height="match_parent"android:scaleType="centerCrop"android:src="@mipmap/ic_launcher"app:layout_collapseMode="parallax"/&gt;&lt;android.support.v7.widget.Toolbarandroid:id="@+id/md_toolbar"android:layout_width="match_parent"android:layout_height="?attr/actionBarSize"app:layout_collapseMode="pin"/&gt;&lt;/android.support.design.widget.CollapsingToolbarLayout&gt;&lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerViewandroid:id="@+id/md_recyclerview"android:layout_width="match_parent"android:layout_height="wrap_content"app:layout_behavior="@string/appbar_scrolling_view_behavior"/&gt; &lt;android.support.design.widget.FloatingActionButtonandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:src="@mipmap/ic_launcher"app:backgroundTint="#00f"app:elevation="5dp"android:layout_margin="16dp"app:layout_anchor="@id/md_recyclerview"app:layout_anchorGravity="bottom|right|end"android:onClick="Click"/&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; AppBarLayout高度需要固定 CollapsingToolbarLayout设置app:layout_scrollFlags 1234567- 23.1.0以后新增一个snap可以在拉动到底部时产生缩放效果- app:layout_scrollFlags=&quot;scroll|enterAlways&quot;- app:layout_scrollFlags=&quot;scroll|enterAlwaysCollapsed&quot;- 不论ToolBar是否设置pin模式，将会全部滚出屏幕，任意下拉动画会使隐藏的视图显示出来- app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;- //设置为pin模式的固定在顶端，下拉到顶部才显示出隐藏视图- app:layout_collapseMode=&quot;parallax&quot;//需要固定的视图使用pin模式，需要滑动的视图使用parallax模式 一些属性setTitle(CharSequence)//设置固定在顶端时显示的titlesetContentScrim(Drawable)app:contentScrim=”?attr/colorPrimary”//修改固定在顶端的背景颜色setStatusBarScrim(Drawable)//状态栏背景，5.0以上有效app:layout_collapseParallaxMultiplier=”0.6”//滑动的视觉差，产生的效果是提前将折叠的视图隐藏掉了app:layout_collapseMode=”parallax|pin”//滑动模式，缩放或者固定collapsingToolbarLayout.setTitle(&quot;title&quot;);//设置标题，将会自动进行缩放//设置颜色后将会自动进行颜色过渡collapsingToolbarLayout.setExpandedTitleColor(Color.WHITE);collapsingToolbarLayout.setCollapsedTitleTextColor(Color.GREEN); DrawerLayout+NavigationView 结合之前学的总结在一个布局中，首先DrawerLayout需要有两个子view，上面的一个代表content,下面的NavigationView代表菜单导航，当然你可以替换成自己的布局，用来做其他的事情。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 &lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/md_DrawerLayout" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true" tools:context=".MainActivity" &gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_width="match_parent" android:layout_height="wrap_content" &gt; &lt;android.support.design.widget.AppBarLayout android:id="@+id/appbar" android:layout_width="match_parent" android:layout_height="160dp" &gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id="@+id/md_CollapsingToolbarLayout" android:layout_width="match_parent" android:layout_height="match_parent" app:contentScrim="?attr/colorPrimary" app:layout_scrollFlags="scroll|exitUntilCollapsed" &gt; &lt;ImageView android:id="@+id/backdrop" android:layout_width="match_parent" android:layout_height="match_parent" android:scaleType="centerCrop" android:src="@mipmap/ic_launcher" app:layout_collapseMode="parallax" app:layout_collapseParallaxMultiplier="0.3" /&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/md_toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" app:layout_collapseMode="pin" /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/md_recyclerview" android:layout_width="match_parent" android:layout_height="wrap_content"app:layout_behavior="@string/appbar_scrolling_view_behavior" /&gt; &lt;android.support.design.widget.FloatingActionButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/ic_launcher" app:backgroundTint="#00f" app:elevation="5dp" android:layout_margin="16dp" app:layout_anchor="@id/md_recyclerview" app:layout_anchorGravity="bottom|right|end" android:onClick="Click" /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; &lt;android.support.design.widget.NavigationView android:id="@+id/md_NavigationView" android:layout_width="wrap_content" android:layout_height="match_parent" android:layout_gravity="start" app:headerLayout="@layout/header" app:menu="@menu/drawer" /&gt; &lt;/android.support.v4.widget.DrawerLayout&gt; 几个属性1234567891011121314关于NavigationView中item的字体颜色和icon选中状态颜色是去当前主题theme中的&lt;--正常状态下字体颜色和icon颜色--&gt;&lt;item name=&quot;android:textColorPrimary&quot;&gt;@android:color/darker_gray&lt;/item&gt;&lt;--选中状态icon的颜色和字体颜色--&gt;&lt;item name=&quot;colorPrimary&quot;&gt;@color/accent_material_light&lt;/item&gt;当然你可以通过如下方法或者属性来改变这一状态：setItemBackgroundResource(int)app:itemBackground`//给menu设置背景资源setItemIconTintList(ColorStateList)app:itemIconTint`//给menu的icon设置颜色，对应的属性setItemTextColor(ColorStateList)app:itemTextColor`//给menu的item设置字体颜色，对应的属性app:headerLayout=&quot;@layout/header&quot;//NavigationView的头部布局app:menu=&quot;@menu/drawer&quot;`//NavigationView的菜单文件 代码12345678910111213141516171819mDrawerLayout = (DrawerLayout) findViewById(R.id.md_DrawerLayout);//这个组件将会展示一个图标在左上角，它是一个DrawerListener的子类，使用它可以简单地创建一个抽屉的控制图标，v4包下的该组件可以设置导航图标，但是已经过时，这里使用v7包下的组件，但是没有了设置图标的参数，如果想自定义可以使用自定义的图标，在实现DrawerListener时做处理ActionBarDrawerToggle mDrawerToggle = new ActionBarDrawerToggle(this, mDrawerLayout, toolbar, R.string.close, R.string.open);//没有找到合适的方法修改图标，这个方法没有效果 mDrawerToggle.setHomeAsUpIndicator(R.mipmap.ic_launcher); //初始化状态 mDrawerToggle.syncState(); mDrawerLayout.setDrawerListener(mDrawerToggle); //设置导航栏NavigationView的点击事件 final NavigationView mNavigationView = (NavigationView) findViewById(R.id.md_NavigationView); mNavigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(MenuItem menuItem) &#123; //使用该方法可以选中Item，但是出现了一个问题，点击时有时会造成选中无法取消，试过一个解决办法是获得Menu的所有Item设置不选中可以解决这个问题。 menuItem.setChecked(true); mDrawerLayout.closeDrawers();//关闭抽屉 return true; &#125; &#125;);]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[v4v7 新控件]]></title>
    <url>%2Farticle%2F1947623271%2F</url>
    <content type="text"><![CDATA[AlertDialogv7风格的Dialog相对原来的版本去掉了跳跃弹出的动画，下方按钮去掉了边框，聚集在了右侧，显示时去掉了分隔线。 ToolBar取代原先的ActionBar实现相对完美的定制 xml文件12345678&lt;android.support.v7.widget.Toolbarandroid:id="@+id/md_toolbar"android:layout_width="match_parent"android:layout_height="?attr/actionBarSize"android:minHeight="50dp"android:background="?attr/colorPrimary"android:layout_marginBottom="20dp" &gt; 代码123456789101112131415161718192021 //隐藏系统默认title,我当时修改了theme用的noactionbar的Theme所以这行代码并没用getSupportActionBar().setDisplayShowTitleEnabled(false);Toolbar toolbar = (Toolbar) findViewById(R.id.md_toolbar);//标题toolbar.setTitle("测试");//副标题，显示在标题下方toolbar.setSubtitle("副标题");//logo,显示在标题左侧toolbar.setLogo(R.mipmap.ic_launcher); //导航图标，显示在最左侧，可以使用该图标调出菜单toolbar.setNavigationIcon(android.R.drawable.ic_input_delete);//这个并没有用，设置菜单时重写onCreateOptionMenu即可//toolbar.inflateMenu(R.menu.menu_main);setSupportActionBar(toolbar);toolbar.setOnMenuItemClickListener(new OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem item) &#123;Toast.makeText(MainActivity.this, "点击了" + item.getItemId(), Toast.LENGTH_SHORT).show(); return false; &#125;&#125;); 题外话,如何创建菜单项12345678910111213141516171819202122232425262728293031323334//重写该方法，菜单将会显示在toobar上@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.menu_main, menu); //获取toolbar上的菜单view,也可以在上面的setOnMenuItemClickListener实现更加简单，这里只是一个演示。 MenuItem item = menu.findItem(R.id.action_share); //强转为你需要的view View actionView = item.getActionView(); return super.onCreateOptionsMenu(menu);&#125;//菜单文件，为没有接触过的小伙伴准备的额,相关属性请自行查文档//res/menu/menu_main.xml&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;xmlns:tools=&quot;http://schemas.android.com/tools&quot;tools:context=&quot;.MainActivity&quot;&gt;&lt;itemandroid:id=&quot;@+id/ab_search&quot;android:orderInCategory=&quot;80&quot;android:title=&quot;action_search&quot; app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot;/&gt;&lt;itemandroid:id=&quot;@+id/action_share&quot;android:orderInCategory=&quot;90&quot;android:title=&quot;action_share&quot; app:actionProviderClass=&quot;android.support.v7.widget.ShareActionProvider&quot;app:showAsAction=&quot;ifRoom&quot;/&gt;&lt;itemandroid:id=&quot;@+id/action_settings&quot;android:orderInCategory=&quot;100&quot;android:title=&quot;action_settings&quot;app:showAsAction=&quot;never&quot;/&gt;&lt;/menu&gt; LinearLayoutCompat 在控件中间添加分隔线 1234567891011&lt;android.support.v7.widget.LinearLayoutCompatandroid:layout_width="match_parent"android:layout_height="wrap_content"android:layout_gravity="center|center_horizontal"android:orientation="vertical"app:divider="@drawable/line"app:dividerPadding="4dp"app:showDividers="middle"&gt;.....&lt;/android.support.v7.widget.LinearLayoutCompat&gt; app:divider=”@drawable/line” 给分隔线设置颜色，这里你需要在drawable在定义shape资源，否则将没有效果。 app:dividerPadding=”25dp” 给分隔线设置距离左右边距的距离。 app:showDividers=”middle|beginning|end” 分隔线显示的位置，有四种参数值：middle 每个item之间，beginning最顶端显示分隔线，end 最底端显示分隔线，none不显示间隔线。 ListPopupWindow123456789101112131415161718192021222324public void showListPopup(View view) &#123; String items[] = &#123;"item1", "item2", "item3", "item4", "item5"&#125;; final ListPopupWindow listPopupWindow = new ListPopupWindow(this); //设置ListView类型的适配器 listPopupWindow.setAdapter(new ArrayAdapter&lt;String&gt;(SwipeRefreshActivity.this, android.R.layout.simple_list_item_1, items)); //给每个item设置监听事件 listPopupWindow.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; Toast.makeText(SwipeRefreshActivity.this, "the position is" + position, Toast.LENGTH_SHORT).show(); //listPopupWindow.dismiss(); &#125; &#125;); //设置ListPopupWindow的锚点,也就是弹出框的位置是相对当前参数View的位置来显示， listPopupWindow.setAnchorView(view); //ListPopupWindow 距锚点的距离，也就是相对锚点View的位置 listPopupWindow.setHorizontalOffset(100); listPopupWindow.setVerticalOffset(100); //设置对话框的宽高 listPopupWindow.setWidth(300); listPopupWindow.setHeight(600); listPopupWindow.setModal(false); listPopupWindow.show(); &#125; PopupMenu12345678910111213141516public void showPopupMenu(View view) &#123;//参数View 是设置当前菜单显示的相对于View组件位置，具体位置系统会处理PopupMenu popupMenu = new PopupMenu(this, view);//加载menu布局popupMenu.getMenuInflater().inflate(R.menu.menu_main, popupMenu.getMenu());//设置menu中的item点击事件popupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() &#123;@Overridepublic boolean onMenuItemClick(MenuItem item) &#123;return false;&#125;&#125;);//设置popupWindow消失的点击事件popupMenu.setOnDismissListener(this);popupMenu.show();&#125; 新风格Spinner12345&lt;Spinner android:id="@+id/spinner" style="@android:style/Widget.Holo.Light.Spinner" android:layout_width="wrap_content" android:layout_height="wrap_content"&gt;&lt;/Spinner&gt; v4 SwipeRefreshLayout SwipeRefreshLayout继承自ViewGroup,理论上可以完成任何View的刷新 代码12345678final SwipeRefreshLayout swipeRefreshLayout = (SwipeRefreshLayout) findViewById(R.id.md_SwipeRefreshLayout);//设置进度条的颜色swipeRefreshLayout.setColorSchemeColors(Color.RED, Color.BLUE, Color.GREEN);//设置圆形进度条大小swipeRefreshLayout.setSize(SwipeRefreshLayout.LARGE);//设置进度条背景颜色 swipeRefreshLayout.setProgressBackgroundColorSchemeColor(Color.WHITE);//设置下拉多少距离之后开始刷新数据，不要设置的太大，不然怎么拉都不刷新swipeRefreshLayout.setDistanceToTriggerSync(5);]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件设计原则]]></title>
    <url>%2Farticle%2F1361585574%2F</url>
    <content type="text"><![CDATA[本文主要介绍设计模式的设计和使用。 类是不稳定的，但是抽象相对稳定，依赖于抽象将获得更加稳定的类结构。 设计原则单一指责 每个类只负责单一的功能，避免修改一个功能完成另一个功能的错误出现。 里氏替换/抽象类原则 子类实现父类的抽象方法 子类不要修改父类的非抽象方法 子类实现抽象方法时前置条件（参数）应该更加宽松 子类重写父类的方法后置条件（返回值）应该更加严格 依赖倒置 高层模块不应该依赖于底层模块，二者都应该依赖于抽象 抽象不能依赖于细节，细节要依赖抽象 多用抽象的接口描述动作。抽象难以扩展或者扩展复杂的的动作，降低动作执行者和动作承受者之间的关联 迪米特法则/最少知道原则 每个类对自己依赖的类知道的越少越好，被依赖的类开放公开的方法却封装内部复杂的逻辑 开闭原则 对扩展是开放的对修改是封闭的 使用增加软件实体的方法来扩展功能而不要使用修改代码的方式 接口隔离原则 一个类对另一个类的依赖应该建立在最小的接口上，也就是不要强迫子类实现他不需要的功能，如果需要这么做那么说明这个接口最小接口需要拆分]]></content>
      <categories>
        <category>Study</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发问题常见问题]]></title>
    <url>%2Farticle%2F1817351074%2F</url>
    <content type="text"><![CDATA[方法数量超出限制 使用分包策略 出现exit value 3之类的错误通常是方法数目超出限制了，建议使用分包机制，但这不是解决问题的方法,最重要的还是准确选择类库，精简方法数。 1234567891011121314//引入分包compile 'com.android.support:multidex:1.0.1'／／添加允许多方法defaultConfig &#123; multiDexEnabled true &#125;／／在Application添加分包初始化@Overrideprotected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); MultiDex.install(this); ｝ 方法数统计 推荐一个插件，可以计算每个包下面的方法数目 在app.gradle文件头添加以下插件，会在app/build/outputs/dexcount/debug.txt文件里生成每个包下面的方法数，如下：apply plugin: ‘com.getkeepsafe.dexcount’ 123456789101112methods fields package/class name8 0 &lt;unnamed&gt;21186 8027 android6 0 android.accessibilityservice34 0 android.animation556 33 android.app3 0 android.app.usage2 0 android.appwidget488 50 android.content42 43 android.content.pm106 6 android.content.res79 0 android.database 签名问题12345678910111213141516171819202122//正式签名相关信息signingConfigs &#123; myConfig &#123; storeFile file("相对或者绝对路径") storePassword "sangular123" keyAlias "sangular" keyPassword "sangular123" &#125;&#125;buildTypes &#123; //release版本的正式签名 release &#123; //minifyEnabled true 打包发布时会使用该代码 //proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig signingConfigs.myConfig &#125; //debug版本也用正式签名调试，这样可以在debug版本下使用第三方登陆等功能 debug &#123; signingConfig signingConfigs.myConfig ｝&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidTips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序及搜索算法总结]]></title>
    <url>%2Farticle%2F395850883%2F</url>
    <content type="text"><![CDATA[Arrays.sort()Arrays.sort()使用了两种排序方法，快速排序和优化的合并排序。 快速排序主要是对哪些基本类型数据（int,short,long等）排序。 而合并排序用于对对象类型进行排序。 原因：使用不同类型的排序算法主要是由于快速排序是不稳定的，而合并排序是稳定的。这里的稳定是指比较相等的数据在排序之后仍然按照排序之前的前后顺序排列。对于基本数据类型，稳定性没有意义，而对于对象类型，稳定性是比较重要的，因为对象相等的判断可能只是判断关键属性，最好保持相等对象的非关键属性的顺序与排序前一致。 另外一个原因是由于合并排序相对而言 比较次数 比快速排序少， 移动(对象引用的移动)次数 比快速排序多，而对于对象来说，移动是简单的，只是引用的转换，但是比较相对更加耗时。 合并排序的时间复杂度是n*logn, 快速排序的平均时间复杂度也是n*logn，但是合并排序的需要额外的n个引用的空间。 排序算法实现冒泡排序12345678910111213//冒泡:0 ~ n-1 0 ~ n-1-i//冒泡排序:两两比较,比较n-1趟,每一趟比较n-i-1次public static void BubbleSort(int a[])&#123; int n = a.length; for(int i = 0; i &lt; n - 1; i++) //比较n-1趟 for(int j = 0; j &lt; n - 1 - i; j++)&#123;//比较n-i-1次! if(a[j+1] &lt; a[j])&#123; a[j+1] = a[j+1] ^ a[j]; a[j] = a[j] ^ a[j+1]; a[j+1] = a[j] ^ a[j+1]; &#125; &#125;&#125; 选择排序123456789101112131415161718//选择排序:遍历前n-1个元素,与 i+1 直到 n 个元素比较,记录小数下标public static void SelectSort(int a[])&#123; int n = a.length; for(int i = 0; i &lt; n - 1; i++)&#123; int min = i; for(int j = i + 1; j &lt; n; j++)&#123; if(a[min] &gt; a[j])&#123; min = j; &#125; &#125; if(min != i)&#123; a[i] = a[i] ^ a[min]; a[min] = a[min] ^ a[i]; a[i] = a[min] ^ a[i]; &#125; &#125;&#125; 插入排序1234567891011121314//插入排序:左边为有序区域,遍历第一个直到第n个,与前i个比较 public static void InsertSort(int a[])&#123; int n = a.length; for(int i = 1;i &lt; n; i++) for(int j = i; j &gt; 0; j--)&#123; if(a[j] &lt; a[j-1])&#123; a[j] = a[j] ^ a[j-1]; a[j-1] = a[j-1] ^ a[j]; a[j] = a[j-1] ^ a[j]; &#125; else break; &#125; &#125; 快速排序1234567891011121314151617181920212223public static void quicksort(int n[], int left, int right) &#123; int dp; if (left &lt; right) &#123; dp = partition(n, left, right); quicksort(n, left, dp - 1); quicksort(n, dp + 1, right); &#125; &#125;public static int partition(int n[], int left, int right) &#123; int pivot = n[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; n[right] &gt;= pivot) right--; if (left &lt; right) n[left++] = n[right]; while (left &lt; right &amp;&amp; n[left] &lt;= pivot) left++; if (left &lt; right) n[right--] = n[left]; &#125; n[left] = pivot; return left;&#125; 搜索算法实现二分法搜索123456789101112131415161718public static int HalfSearch(int a[],int target)&#123; int bottom = 0; int top = a.length - 1; int middle = (top + bottom) / 2; while(bottom &lt;= top)&#123; if(a[middle] &gt; target)&#123; top = middle - 1; &#125; else if(a[middle] &lt; target)&#123; bottom = middle + 1; &#125; else &#123; return middle; &#125; middle = (top + bottom) / 2; &#125; return -1; &#125;]]></content>
      <categories>
        <category>Study</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>